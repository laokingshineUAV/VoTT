{"ast":null,"code":"// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\nimport { RequestHeaders, Util, CorrelationIdHelper, TelemetryItemCreator, RemoteDependencyData, DateTimeUtils, DisabledPropertyName, ConfigurationManager, PropertiesPluginIdentifier } from '@microsoft/applicationinsights-common';\nimport { CoreUtils, LoggingSeverity, _InternalMessageId } from '@microsoft/applicationinsights-core-js';\nimport { ajaxRecord } from './ajaxRecord';\nimport { EventHelper } from './ajaxUtils';\n\nvar AjaxMonitor =\n/** @class */\nfunction () {\n  function AjaxMonitor() {\n    this._trackAjaxAttempts = 0;\n    this.identifier = AjaxMonitor.identifier;\n    this.priority = 161;\n    this.currentWindowHost = window && window.location && window.location.host && window.location.host.toLowerCase();\n    this.initialized = false;\n    this._fetchInitialized = false;\n  } ///<summary>Verifies that particalar instance of XMLHttpRequest needs to be monitored</summary>\n  ///<param name=\"excludeAjaxDataValidation\">Optional parameter. True if ajaxData must be excluded from verification</param>\n  ///<returns type=\"bool\">True if instance needs to be monitored, otherwise false</returns>\n\n\n  AjaxMonitor.prototype.isMonitoredInstance = function (xhr, excludeAjaxDataValidation, request, init) {\n    var disabledProperty = false;\n    var ajaxValidation = true;\n    var initialized = false;\n\n    if (typeof request !== 'undefined') {\n      initialized = this._fetchInitialized; // Look for DisabledPropertyName in either Request or RequestInit\n\n      disabledProperty = (typeof request === 'object' ? request[DisabledPropertyName] === true : false) || (init ? init[DisabledPropertyName] === true : false);\n    } else if (typeof xhr !== 'undefined') {\n      initialized = this.initialized;\n      disabledProperty = xhr[DisabledPropertyName] === true;\n      ajaxValidation = excludeAjaxDataValidation === true || !CoreUtils.isNullOrUndefined(xhr.ajaxData);\n    } // checking to see that all interested functions on xhr were instrumented\n\n\n    return initialized // checking on ajaxData to see that it was not removed in user code\n    && ajaxValidation // check that this instance is not not used by ajax call performed inside client side monitoring to send data to collector\n    && !disabledProperty;\n  }; ///<summary>Determines whether ajax monitoring can be enabled on this document</summary>\n  ///<returns>True if Ajax monitoring is supported on this page, otherwise false</returns>\n\n\n  AjaxMonitor.prototype.supportsAjaxMonitoring = function () {\n    var result = true;\n\n    if (CoreUtils.isNullOrUndefined(XMLHttpRequest) || CoreUtils.isNullOrUndefined(XMLHttpRequest.prototype) || CoreUtils.isNullOrUndefined(XMLHttpRequest.prototype.open) || CoreUtils.isNullOrUndefined(XMLHttpRequest.prototype.send) || CoreUtils.isNullOrUndefined(XMLHttpRequest.prototype.abort)) {\n      result = false;\n    } // disable in IE8 or older (https://www.w3schools.com/jsref/jsref_trim_string.asp)\n\n\n    try {\n      \" a \".trim();\n    } catch (ex) {\n      result = false;\n    }\n\n    return result;\n  };\n\n  AjaxMonitor.prototype.instrumentOpen = function () {\n    var originalOpen = XMLHttpRequest.prototype.open;\n    var ajaxMonitorInstance = this;\n\n    XMLHttpRequest.prototype.open = function (method, url, async) {\n      try {\n        if (ajaxMonitorInstance.isMonitoredInstance(this, true) && (!this.ajaxData || !this.ajaxData.xhrMonitoringState.openDone)) {\n          ajaxMonitorInstance.openHandler(this, method, url, async);\n        }\n      } catch (e) {\n        this._core.logger.throwInternal(LoggingSeverity.CRITICAL, _InternalMessageId.FailedMonitorAjaxOpen, \"Failed to monitor XMLHttpRequest.open, monitoring data for this ajax call may be incorrect.\", {\n          ajaxDiagnosticsMessage: AjaxMonitor.getFailedAjaxDiagnosticsMessage(this),\n          exception: Util.dump(e)\n        });\n      }\n\n      return originalOpen.apply(this, arguments);\n    };\n  };\n\n  AjaxMonitor.prototype.openHandler = function (xhr, method, url, async) {\n    var id;\n\n    if (this._context && this._context.telemetryTrace && this._context.telemetryTrace.traceID) {\n      // this format corresponds with activity logic on server-side and is required for the correct correlation\n      id = \"|\" + this._context.telemetryTrace.traceID + \".\" + Util.newId();\n    } else {\n      id = Util.newId();\n    }\n\n    var ajaxData = new ajaxRecord(id, this._core.logger);\n    ajaxData.method = method;\n    ajaxData.requestUrl = url;\n    ajaxData.xhrMonitoringState.openDone = true;\n    xhr.ajaxData = ajaxData;\n    this.attachToOnReadyStateChange(xhr);\n  };\n\n  AjaxMonitor.getFailedAjaxDiagnosticsMessage = function (xhr) {\n    var result = \"\";\n\n    try {\n      if (!CoreUtils.isNullOrUndefined(xhr) && !CoreUtils.isNullOrUndefined(xhr.ajaxData) && !CoreUtils.isNullOrUndefined(xhr.ajaxData.requestUrl)) {\n        result += \"(url: '\" + xhr.ajaxData.requestUrl + \"')\";\n      }\n    } catch (e) {}\n\n    return result;\n  };\n\n  AjaxMonitor.prototype.instrumentSend = function () {\n    var originalSend = XMLHttpRequest.prototype.send;\n    var ajaxMonitorInstance = this;\n\n    XMLHttpRequest.prototype.send = function (content) {\n      try {\n        if (ajaxMonitorInstance.isMonitoredInstance(this) && !this.ajaxData.xhrMonitoringState.sendDone) {\n          ajaxMonitorInstance.sendHandler(this, content);\n        }\n      } catch (e) {\n        this._core.logger.throwInternal(LoggingSeverity.CRITICAL, _InternalMessageId.FailedMonitorAjaxSend, \"Failed to monitor XMLHttpRequest, monitoring data for this ajax call may be incorrect.\", {\n          ajaxDiagnosticsMessage: AjaxMonitor.getFailedAjaxDiagnosticsMessage(this),\n          exception: Util.dump(e)\n        });\n      }\n\n      return originalSend.apply(this, arguments);\n    };\n  };\n\n  AjaxMonitor.prototype.sendHandler = function (xhr, content) {\n    xhr.ajaxData.requestSentTime = DateTimeUtils.Now();\n    xhr = this.includeCorrelationHeaders(xhr.ajaxData, undefined, undefined, xhr);\n    xhr.ajaxData.xhrMonitoringState.sendDone = true;\n  };\n\n  AjaxMonitor.prototype.instrumentAbort = function () {\n    var originalAbort = XMLHttpRequest.prototype.abort;\n    var ajaxMonitorInstance = this;\n\n    XMLHttpRequest.prototype.abort = function () {\n      try {\n        if (ajaxMonitorInstance.isMonitoredInstance(this) && !this.ajaxData.xhrMonitoringState.abortDone) {\n          this.ajaxData.aborted = 1;\n          this.ajaxData.xhrMonitoringState.abortDone = true;\n        }\n      } catch (e) {\n        this._core.logger.throwInternal(LoggingSeverity.CRITICAL, _InternalMessageId.FailedMonitorAjaxAbort, \"Failed to monitor XMLHttpRequest.abort, monitoring data for this ajax call may be incorrect.\", {\n          ajaxDiagnosticsMessage: AjaxMonitor.getFailedAjaxDiagnosticsMessage(this),\n          exception: Util.dump(e)\n        });\n      }\n\n      return originalAbort.apply(this, arguments);\n    };\n  };\n\n  AjaxMonitor.prototype.attachToOnReadyStateChange = function (xhr) {\n    var _this = this;\n\n    var ajaxMonitorInstance = this;\n    xhr.ajaxData.xhrMonitoringState.onreadystatechangeCallbackAttached = EventHelper.AttachEvent(xhr, \"readystatechange\", function () {\n      try {\n        if (ajaxMonitorInstance.isMonitoredInstance(xhr)) {\n          if (xhr.readyState === 4) {\n            ajaxMonitorInstance.onAjaxComplete(xhr);\n          }\n        }\n      } catch (e) {\n        var exceptionText = Util.dump(e); // ignore messages with c00c023f, as this a known IE9 XHR abort issue\n\n        if (!exceptionText || exceptionText.toLowerCase().indexOf(\"c00c023f\") == -1) {\n          _this._core.logger.throwInternal(LoggingSeverity.CRITICAL, _InternalMessageId.FailedMonitorAjaxRSC, \"Failed to monitor XMLHttpRequest 'readystatechange' event handler, monitoring data for this ajax call may be incorrect.\", {\n            ajaxDiagnosticsMessage: AjaxMonitor.getFailedAjaxDiagnosticsMessage(xhr),\n            exception: Util.dump(e)\n          });\n        }\n      }\n    });\n  };\n\n  AjaxMonitor.prototype.onAjaxComplete = function (xhr) {\n    xhr.ajaxData.responseFinishedTime = DateTimeUtils.Now();\n    xhr.ajaxData.status = xhr.status;\n    xhr.ajaxData.CalculateMetrics();\n\n    if (xhr.ajaxData.ajaxTotalDuration < 0) {\n      this._core.logger.throwInternal(LoggingSeverity.WARNING, _InternalMessageId.FailedMonitorAjaxDur, \"Failed to calculate the duration of the ajax call, monitoring data for this ajax call won't be sent.\", {\n        ajaxDiagnosticsMessage: AjaxMonitor.getFailedAjaxDiagnosticsMessage(xhr),\n        requestSentTime: xhr.ajaxData.requestSentTime,\n        responseFinishedTime: xhr.ajaxData.responseFinishedTime\n      });\n    } else {\n      var dependency = {\n        id: xhr.ajaxData.id,\n        target: xhr.ajaxData.getAbsoluteUrl(),\n        name: xhr.ajaxData.getPathName(),\n        type: \"Ajax\",\n        duration: xhr.ajaxData.ajaxTotalDuration,\n        success: +xhr.ajaxData.status >= 200 && +xhr.ajaxData.status < 400,\n        responseCode: +xhr.ajaxData.status,\n        method: xhr.ajaxData.method\n      }; // enrich dependency target with correlation context from the server\n\n      var correlationContext = this.getAjaxCorrelationContext(xhr);\n\n      if (correlationContext) {\n        dependency.correlationContext =\n        /* dependency.target + \" | \" + */\n        correlationContext;\n      }\n\n      this.trackDependencyDataInternal(dependency);\n      xhr.ajaxData = null;\n    }\n  };\n\n  AjaxMonitor.prototype.getAjaxCorrelationContext = function (xhr) {\n    try {\n      var responseHeadersString = xhr.getAllResponseHeaders();\n\n      if (responseHeadersString !== null) {\n        var index = responseHeadersString.toLowerCase().indexOf(RequestHeaders.requestContextHeaderLowerCase);\n\n        if (index !== -1) {\n          var responseHeader = xhr.getResponseHeader(RequestHeaders.requestContextHeader);\n          return CorrelationIdHelper.getCorrelationContext(responseHeader);\n        }\n      }\n    } catch (e) {\n      this._core.logger.throwInternal(LoggingSeverity.WARNING, _InternalMessageId.FailedMonitorAjaxGetCorrelationHeader, \"Failed to get Request-Context correlation header as it may be not included in the response or not accessible.\", {\n        ajaxDiagnosticsMessage: AjaxMonitor.getFailedAjaxDiagnosticsMessage(xhr),\n        exception: Util.dump(e)\n      });\n    }\n  };\n  /**\r\n   * Logs dependency call\r\n   * @param dependencyData dependency data object\r\n   */\n\n\n  AjaxMonitor.prototype.trackDependencyDataInternal = function (dependency, properties, systemProperties) {\n    if (this._config.maxAjaxCallsPerView === -1 || this._trackAjaxAttempts < this._config.maxAjaxCallsPerView) {\n      var item = TelemetryItemCreator.create(dependency, RemoteDependencyData.dataType, RemoteDependencyData.envelopeType, this._core.logger, properties, systemProperties);\n\n      this._core.track(item);\n    } else if (this._trackAjaxAttempts === this._config.maxAjaxCallsPerView) {\n      this._core.logger.throwInternal(LoggingSeverity.CRITICAL, _InternalMessageId.MaxAjaxPerPVExceeded, \"Maximum ajax per page view limit reached, ajax monitoring is paused until the next trackPageView(). In order to increase the limit set the maxAjaxCallsPerView configuration parameter.\", true);\n    }\n\n    ++this._trackAjaxAttempts;\n  };\n\n  AjaxMonitor.prototype.trackDependencyData = function (dependency, properties) {\n    this.trackDependencyDataInternal(dependency, properties);\n  };\n\n  AjaxMonitor.prototype.processTelemetry = function (item) {\n    if (this._nextPlugin && this._nextPlugin.processTelemetry) {\n      this._nextPlugin.processTelemetry(item);\n    }\n  };\n\n  AjaxMonitor.prototype.setNextPlugin = function (next) {\n    if (next) {\n      this._nextPlugin = next;\n    }\n  }; // Fetch Stuff\n\n\n  AjaxMonitor.prototype.instrumentFetch = function () {\n    if (!this.supportsFetch() || this._fetchInitialized) {\n      return;\n    }\n\n    var originalFetch = window.fetch;\n    var fetchMonitorInstance = this;\n\n    window.fetch = function fetch(input, init) {\n      var fetchData;\n\n      if (fetchMonitorInstance.isFetchInstrumented(input) && fetchMonitorInstance.isMonitoredInstance(undefined, undefined, input, init)) {\n        try {\n          fetchData = fetchMonitorInstance.createFetchRecord(input, init);\n          init = fetchMonitorInstance.includeCorrelationHeaders(fetchData, input, init);\n        } catch (e) {\n          fetchMonitorInstance._core.logger.throwInternal(LoggingSeverity.CRITICAL, _InternalMessageId.FailedMonitorAjaxOpen, \"Failed to monitor Window.fetch, monitoring data for this fetch call may be incorrect.\", {\n            ajaxDiagnosticsMessage: this.getFailedFetchDiagnosticsMessage(input),\n            exception: Util.dump(e)\n          });\n        }\n      }\n\n      return originalFetch(input, init).then(function (response) {\n        fetchMonitorInstance.onFetchComplete(response, fetchData);\n        return response;\n      }).catch(function (reason) {\n        fetchMonitorInstance.onFetchFailed(input, fetchData, reason);\n        throw reason;\n      });\n    };\n\n    this._fetchInitialized = true;\n  };\n\n  AjaxMonitor.prototype.isFetchInstrumented = function (input) {\n    return this._fetchInitialized && input[DisabledPropertyName] !== true;\n  };\n\n  AjaxMonitor.prototype.supportsFetch = function () {\n    var result = true;\n\n    if (!window || CoreUtils.isNullOrUndefined(window.Request) || CoreUtils.isNullOrUndefined(window.Request.prototype) || CoreUtils.isNullOrUndefined(window.fetch)) {\n      result = false;\n    }\n\n    return result;\n  };\n\n  AjaxMonitor.prototype.createFetchRecord = function (input, init) {\n    var id;\n\n    if (this._context && this._context.telemetryTrace && this._context.telemetryTrace.traceID) {\n      // this format corresponds with activity logic on server-side and is required for the correct correlation\n      id = \"|\" + this._context.telemetryTrace.traceID + \".\" + Util.newId();\n    } else {\n      id = Util.newId();\n    }\n\n    var ajaxData = new ajaxRecord(id, this._core.logger);\n    ajaxData.requestSentTime = DateTimeUtils.Now();\n\n    if (input instanceof Request) {\n      ajaxData.requestUrl = input ? input.url : \"\";\n    } else {\n      ajaxData.requestUrl = input;\n    }\n\n    if (init && init.method) {\n      ajaxData.method = init.method;\n    } else if (input && input instanceof Request) {\n      ajaxData.method = input.method;\n    } else {\n      ajaxData.method = \"GET\";\n    }\n\n    return ajaxData;\n  };\n\n  AjaxMonitor.prototype.includeCorrelationHeaders = function (ajaxData, input, init, xhr) {\n    if (input) {\n      if (CorrelationIdHelper.canIncludeCorrelationHeader(this._config, ajaxData.getAbsoluteUrl(), this.currentWindowHost)) {\n        if (!init) {\n          init = {};\n        } // init headers override original request headers\n        // so, if they exist use only them, otherwise use request's because they should have been applied in the first place\n        // not using original request headers will result in them being lost\n\n\n        init.headers = new Headers(init.headers || (input instanceof Request ? input.headers || {} : {}));\n        init.headers.set(RequestHeaders.requestIdHeader, ajaxData.id);\n        var appId_1 = this._config.appId;\n\n        if (appId_1) {\n          init.headers.set(RequestHeaders.requestContextHeader, RequestHeaders.requestContextAppIdFormat + appId_1);\n        }\n\n        return init;\n      }\n\n      return init;\n    } else if (xhr) {\n      if (this.currentWindowHost && CorrelationIdHelper.canIncludeCorrelationHeader(this._config, xhr.ajaxData.getAbsoluteUrl(), this.currentWindowHost)) {\n        xhr.setRequestHeader(RequestHeaders.requestIdHeader, xhr.ajaxData.id);\n        var appId = this._config.appId; // Todo: also, get appId from channel as breeze returns it\n\n        if (appId) {\n          xhr.setRequestHeader(RequestHeaders.requestContextHeader, RequestHeaders.requestContextAppIdFormat + appId);\n        }\n      }\n\n      return xhr;\n    }\n\n    return undefined;\n  };\n\n  AjaxMonitor.prototype.getFailedFetchDiagnosticsMessage = function (input) {\n    var result = \"\";\n\n    try {\n      if (!CoreUtils.isNullOrUndefined(input)) {\n        if (typeof input === \"string\") {\n          result += \"(url: '\" + input + \"')\";\n        } else {\n          result += \"(url: '\" + input.url + \"')\";\n        }\n      }\n    } catch (e) {\n      this._core.logger.throwInternal(LoggingSeverity.CRITICAL, _InternalMessageId.FailedMonitorAjaxOpen, \"Failed to grab failed fetch diagnostics message\", {\n        exception: Util.dump(e)\n      });\n    }\n\n    return result;\n  };\n\n  AjaxMonitor.prototype.onFetchComplete = function (response, ajaxData) {\n    if (!ajaxData) {\n      return;\n    }\n\n    try {\n      ajaxData.responseFinishedTime = DateTimeUtils.Now();\n      ajaxData.CalculateMetrics();\n\n      if (ajaxData.ajaxTotalDuration < 0) {\n        this._core.logger.throwInternal(LoggingSeverity.WARNING, _InternalMessageId.FailedMonitorAjaxDur, \"Failed to calculate the duration of the fetch call, monitoring data for this fetch call won't be sent.\", {\n          fetchDiagnosticsMessage: this.getFailedFetchDiagnosticsMessage(response),\n          requestSentTime: ajaxData.requestSentTime,\n          responseFinishedTime: ajaxData.responseFinishedTime\n        });\n      } else {\n        var dependency = {\n          id: ajaxData.id,\n          target: ajaxData.getAbsoluteUrl(),\n          name: ajaxData.getPathName(),\n          type: \"Fetch\",\n          duration: ajaxData.ajaxTotalDuration,\n          success: response.status >= 200 && response.status < 400,\n          responseCode: response.status,\n          properties: {\n            HttpMethod: ajaxData.method\n          }\n        }; // enrich dependency target with correlation context from the server\n\n        var correlationContext = this.getFetchCorrelationContext(response);\n\n        if (correlationContext) {\n          dependency.correlationContext = correlationContext;\n        }\n\n        this.trackDependencyDataInternal(dependency);\n      }\n    } catch (e) {\n      this._core.logger.throwInternal(LoggingSeverity.WARNING, _InternalMessageId.FailedMonitorAjaxGetCorrelationHeader, \"Failed to calculate the duration of the fetch call, monitoring data for this fetch call won't be sent.\", {\n        fetchDiagnosticsMessage: this.getFailedFetchDiagnosticsMessage(response),\n        exception: Util.dump(e)\n      });\n    }\n  };\n\n  AjaxMonitor.prototype.onFetchFailed = function (input, ajaxData, reason) {\n    if (!ajaxData) {\n      return;\n    }\n\n    try {\n      ajaxData.responseFinishedTime = DateTimeUtils.Now();\n      ajaxData.CalculateMetrics();\n\n      if (ajaxData.ajaxTotalDuration < 0) {\n        this._core.logger.throwInternal(LoggingSeverity.WARNING, _InternalMessageId.FailedMonitorAjaxDur, \"Failed to calculate the duration of the failed fetch call, monitoring data for this fetch call won't be sent.\", {\n          fetchDiagnosticsMessage: this.getFailedFetchDiagnosticsMessage(input),\n          requestSentTime: ajaxData.requestSentTime,\n          responseFinishedTime: ajaxData.responseFinishedTime\n        });\n      } else {\n        var dependency = {\n          id: ajaxData.id,\n          target: ajaxData.getAbsoluteUrl(),\n          name: ajaxData.getPathName(),\n          type: \"Fetch\",\n          duration: ajaxData.ajaxTotalDuration,\n          success: false,\n          responseCode: 0,\n          properties: {\n            HttpMethod: ajaxData.method\n          }\n        };\n        this.trackDependencyDataInternal(dependency, {\n          error: reason.message\n        });\n      }\n    } catch (e) {\n      this._core.logger.throwInternal(LoggingSeverity.WARNING, _InternalMessageId.FailedMonitorAjaxGetCorrelationHeader, \"Failed to calculate the duration of the failed fetch call, monitoring data for this fetch call won't be sent.\", {\n        fetchDiagnosticsMessage: this.getFailedFetchDiagnosticsMessage(input),\n        exception: Util.dump(e)\n      });\n    }\n  };\n\n  AjaxMonitor.prototype.getFetchCorrelationContext = function (response) {\n    try {\n      var responseHeader = response.headers.get(RequestHeaders.requestContextHeader);\n      return CorrelationIdHelper.getCorrelationContext(responseHeader);\n    } catch (e) {\n      this._core.logger.throwInternal(LoggingSeverity.WARNING, _InternalMessageId.FailedMonitorAjaxGetCorrelationHeader, \"Failed to get Request-Context correlation header as it may be not included in the response or not accessible.\", {\n        fetchDiagnosticsMessage: this.getFailedFetchDiagnosticsMessage(response),\n        exception: Util.dump(e)\n      });\n    }\n  };\n\n  AjaxMonitor.prototype.instrumentXhr = function () {\n    if (this.supportsAjaxMonitoring() && !this.initialized) {\n      this.instrumentOpen();\n      this.instrumentSend();\n      this.instrumentAbort();\n      this.initialized = true;\n    }\n  };\n\n  AjaxMonitor.getDefaultConfig = function () {\n    var config = {\n      maxAjaxCallsPerView: 500,\n      disableAjaxTracking: false,\n      disableFetchTracking: true,\n      disableCorrelationHeaders: false,\n      correlationHeaderExcludedDomains: [\"*.blob.core.windows.net\", \"*.blob.core.chinacloudapi.cn\", \"*.blob.core.cloudapi.de\", \"*.blob.core.usgovcloudapi.net\"],\n      appId: undefined,\n      enableCorsCorrelation: false\n    };\n    return config;\n  };\n\n  AjaxMonitor.getEmptyConfig = function () {\n    return {\n      maxAjaxCallsPerView: undefined,\n      disableAjaxTracking: undefined,\n      disableFetchTracking: undefined,\n      disableCorrelationHeaders: undefined,\n      correlationHeaderExcludedDomains: undefined,\n      appId: undefined,\n      enableCorsCorrelation: undefined\n    };\n  };\n\n  AjaxMonitor.prototype.initialize = function (config, core, extensions) {\n    if (!this.initialized && !this._fetchInitialized) {\n      this._core = core;\n      var defaultConfig = AjaxMonitor.getDefaultConfig();\n      this._config = AjaxMonitor.getEmptyConfig();\n\n      for (var field in defaultConfig) {\n        this._config[field] = ConfigurationManager.getConfig(config, field, AjaxMonitor.identifier, defaultConfig[field]);\n      }\n\n      if (this._config.disableAjaxTracking === false) {\n        this.instrumentXhr();\n      }\n\n      if (this._config.disableFetchTracking === false) {\n        this.instrumentFetch();\n      }\n\n      if (extensions.length > 0 && extensions) {\n        var propExt = extensions[PropertiesPluginIdentifier];\n\n        if (propExt) {\n          this._context = propExt.context; // we could move IPropertiesPlugin to common as well\n        }\n      }\n    }\n  };\n\n  AjaxMonitor.identifier = \"AjaxDependencyPlugin\";\n  return AjaxMonitor;\n}();\n\nexport { AjaxMonitor };","map":null,"metadata":{},"sourceType":"module"}