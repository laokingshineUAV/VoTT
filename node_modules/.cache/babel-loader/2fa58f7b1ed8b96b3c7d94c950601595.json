{"ast":null,"code":"import * as tslib_1 from \"tslib\";\nimport { BaseRequestPolicy, delay, HttpPipelineLogLevel } from \"@azure/ms-rest-js\";\nimport { URLConstants } from \"../utils/constants\";\nimport { setURLHost, setURLParameter } from \"../utils/utils.common\";\n/**\n * A factory method used to generated a RetryPolicy factory.\n *\n * @export\n * @param {IRetryOptions} retryOptions\n * @returns\n */\n\nexport function NewRetryPolicyFactory(retryOptions) {\n  return {\n    create: function create(nextPolicy, options) {\n      return new RetryPolicy(nextPolicy, options, retryOptions);\n    }\n  };\n}\n/**\n * RetryPolicy types.\n *\n * @export\n * @enum {number}\n */\n\nexport var RetryPolicyType;\n\n(function (RetryPolicyType) {\n  /**\n   * Exponential retry. Retry time delay grows exponentially.\n   */\n  RetryPolicyType[RetryPolicyType[\"EXPONENTIAL\"] = 0] = \"EXPONENTIAL\";\n  /**\n   * Linear retry. Retry time delay grows linearly.\n   */\n\n  RetryPolicyType[RetryPolicyType[\"FIXED\"] = 1] = \"FIXED\";\n})(RetryPolicyType || (RetryPolicyType = {})); // Default values of IRetryOptions\n\n\nvar DEFAULT_RETRY_OPTIONS = {\n  maxRetryDelayInMs: 120 * 1000,\n  maxTries: 4,\n  retryDelayInMs: 4 * 1000,\n  retryPolicyType: RetryPolicyType.EXPONENTIAL,\n  secondaryHost: \"\",\n  tryTimeoutInMs: undefined // Use server side default timeout strategy\n\n};\n/**\n * Retry policy with exponential retry and linear retry implemented.\n *\n * @class RetryPolicy\n * @extends {BaseRequestPolicy}\n */\n\nvar RetryPolicy =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(RetryPolicy, _super);\n  /**\n   * Creates an instance of RetryPolicy.\n   *\n   * @param {RequestPolicy} nextPolicy\n   * @param {RequestPolicyOptions} options\n   * @param {IRetryOptions} [retryOptions=DEFAULT_RETRY_OPTIONS]\n   * @memberof RetryPolicy\n   */\n\n\n  function RetryPolicy(nextPolicy, options, retryOptions) {\n    if (retryOptions === void 0) {\n      retryOptions = DEFAULT_RETRY_OPTIONS;\n    }\n\n    var _this = _super.call(this, nextPolicy, options) || this; // Initialize retry options\n\n\n    _this.retryOptions = {\n      retryPolicyType: retryOptions.retryPolicyType ? retryOptions.retryPolicyType : DEFAULT_RETRY_OPTIONS.retryPolicyType,\n      maxTries: retryOptions.maxTries && retryOptions.maxTries >= 1 ? Math.floor(retryOptions.maxTries) : DEFAULT_RETRY_OPTIONS.maxTries,\n      tryTimeoutInMs: retryOptions.tryTimeoutInMs && retryOptions.tryTimeoutInMs >= 0 ? retryOptions.tryTimeoutInMs : DEFAULT_RETRY_OPTIONS.tryTimeoutInMs,\n      retryDelayInMs: retryOptions.retryDelayInMs && retryOptions.retryDelayInMs >= 0 ? Math.min(retryOptions.retryDelayInMs, retryOptions.maxRetryDelayInMs ? retryOptions.maxRetryDelayInMs : DEFAULT_RETRY_OPTIONS.maxRetryDelayInMs) : DEFAULT_RETRY_OPTIONS.retryDelayInMs,\n      maxRetryDelayInMs: retryOptions.maxRetryDelayInMs && retryOptions.maxRetryDelayInMs >= 0 ? retryOptions.maxRetryDelayInMs : DEFAULT_RETRY_OPTIONS.maxRetryDelayInMs,\n      secondaryHost: retryOptions.secondaryHost ? retryOptions.secondaryHost : DEFAULT_RETRY_OPTIONS.secondaryHost\n    };\n    return _this;\n  }\n  /**\n   * Sends request.\n   *\n   * @param {WebResource} request\n   * @returns {Promise<HttpOperationResponse>}\n   * @memberof RetryPolicy\n   */\n\n\n  RetryPolicy.prototype.sendRequest = function (request) {\n    return tslib_1.__awaiter(this, void 0, void 0, function () {\n      return tslib_1.__generator(this, function (_a) {\n        return [2\n        /*return*/\n        , this.attemptSendRequest(request, false, 1)];\n      });\n    });\n  };\n  /**\n   * Decide and perform next retry. Won't mutate request parameter.\n   *\n   * @protected\n   * @param {WebResource} request\n   * @param {HttpOperationResponse} response\n   * @param {boolean} secondaryHas404  If attempt was against the secondary & it returned a StatusNotFound (404), then\n   *                                   the resource was not found. This may be due to replication delay. So, in this\n   *                                   case, we'll never try the secondary again for this operation.\n   * @param {number} attempt           How many retries has been attempted to performed, starting from 1, which includes\n   *                                   the attempt will be performed by this method call.\n   * @returns {Promise<HttpOperationResponse>}\n   * @memberof RetryPolicy\n   */\n\n\n  RetryPolicy.prototype.attemptSendRequest = function (request, secondaryHas404, attempt) {\n    return tslib_1.__awaiter(this, void 0, void 0, function () {\n      var newRequest, isPrimaryRetry, response, err_1;\n      return tslib_1.__generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            newRequest = request.clone();\n            isPrimaryRetry = secondaryHas404 || !this.retryOptions.secondaryHost || !(request.method === \"GET\" || request.method === \"HEAD\" || request.method === \"OPTIONS\") || attempt % 2 === 1;\n\n            if (!isPrimaryRetry) {\n              newRequest.url = setURLHost(newRequest.url, this.retryOptions.secondaryHost);\n            } // Set the server-side timeout query parameter \"timeout=[seconds]\"\n\n\n            if (this.retryOptions.tryTimeoutInMs) {\n              newRequest.url = setURLParameter(newRequest.url, URLConstants.Parameters.TIMEOUT, Math.floor(this.retryOptions.tryTimeoutInMs / 1000).toString());\n            }\n\n            _a.label = 1;\n\n          case 1:\n            _a.trys.push([1, 3,, 4]);\n\n            this.logf(HttpPipelineLogLevel.INFO, \"RetryPolicy: =====> Try=\" + attempt + \" \" + (isPrimaryRetry ? \"Primary\" : \"Secondary\"));\n            return [4\n            /*yield*/\n            , this._nextPolicy.sendRequest(newRequest)];\n\n          case 2:\n            response = _a.sent();\n\n            if (!this.shouldRetry(isPrimaryRetry, attempt, response)) {\n              return [2\n              /*return*/\n              , response];\n            }\n\n            secondaryHas404 = secondaryHas404 || !isPrimaryRetry && response.status === 404;\n            return [3\n            /*break*/\n            , 4];\n\n          case 3:\n            err_1 = _a.sent();\n            this.logf(HttpPipelineLogLevel.ERROR, \"RetryPolicy: Caught error, message: \" + err_1.message + \", code: \" + err_1.code);\n\n            if (!this.shouldRetry(isPrimaryRetry, attempt, response, err_1)) {\n              throw err_1;\n            }\n\n            return [3\n            /*break*/\n            , 4];\n\n          case 4:\n            return [4\n            /*yield*/\n            , this.delay(isPrimaryRetry, attempt)];\n\n          case 5:\n            _a.sent();\n\n            return [4\n            /*yield*/\n            , this.attemptSendRequest(request, secondaryHas404, ++attempt)];\n\n          case 6:\n            return [2\n            /*return*/\n            , _a.sent()];\n        }\n      });\n    });\n  };\n  /**\n   * Decide whether to retry according to last HTTP response and retry counters.\n   *\n   * @protected\n   * @param {boolean} isPrimaryRetry\n   * @param {number} attempt\n   * @param {HttpOperationResponse} [response]\n   * @param {RestError} [err]\n   * @returns {boolean}\n   * @memberof RetryPolicy\n   */\n\n\n  RetryPolicy.prototype.shouldRetry = function (isPrimaryRetry, attempt, response, err) {\n    if (attempt >= this.retryOptions.maxTries) {\n      this.logf(HttpPipelineLogLevel.INFO, \"RetryPolicy: Attempt(s) \" + attempt + \" >= maxTries \" + this.retryOptions.maxTries + \", no further try.\");\n      return false;\n    } // Handle network failures, you may need to customize the list when you implement\n    // your own http client\n\n\n    var retriableErrors = [\"ETIMEDOUT\", \"ESOCKETTIMEDOUT\", \"ECONNREFUSED\", \"ECONNRESET\", \"ENOENT\", \"ENOTFOUND\", \"TIMEOUT\", \"REQUEST_SEND_ERROR\" // For default xhr based http client provided in ms-rest-js\n    ];\n\n    if (err) {\n      for (var _i = 0, retriableErrors_1 = retriableErrors; _i < retriableErrors_1.length; _i++) {\n        var retriableError = retriableErrors_1[_i];\n\n        if (err.name.toUpperCase().includes(retriableError) || err.message.toUpperCase().includes(retriableError) || err.code && err.code.toUpperCase().includes(retriableError)) {\n          this.logf(HttpPipelineLogLevel.INFO, \"RetryPolicy: Network error \" + retriableError + \" found, will retry.\");\n          return true;\n        }\n      }\n    } // If attempt was against the secondary & it returned a StatusNotFound (404), then\n    // the resource was not found. This may be due to replication delay. So, in this\n    // case, we'll never try the secondary again for this operation.\n\n\n    if (response || err) {\n      var statusCode = response ? response.status : err ? err.statusCode : 0;\n\n      if (!isPrimaryRetry && statusCode === 404) {\n        this.logf(HttpPipelineLogLevel.INFO, \"RetryPolicy: Secondary access with 404, will retry.\");\n        return true;\n      } // Server internal error or server timeout\n\n\n      if (statusCode === 503 || statusCode === 500) {\n        this.logf(HttpPipelineLogLevel.INFO, \"RetryPolicy: Will retry for status code \" + statusCode + \".\");\n        return true;\n      }\n    }\n\n    return false;\n  };\n  /**\n   * This is to log for debugging purposes only.\n   * Comment/uncomment as necessary for releasing/debugging.\n   *\n   * @private\n   * @param {HttpPipelineLogLevel} level\n   * @param {string} message\n   * @memberof RetryPolicy\n   */\n  // tslint:disable-next-line:variable-name\n\n\n  RetryPolicy.prototype.logf = function (_level, _message) {// this.log(_level, _message);\n  };\n  /**\n   * Delay a calculated time between retries.\n   *\n   * @private\n   * @param {boolean} isPrimaryRetry\n   * @param {number} attempt\n   * @returns\n   * @memberof RetryPolicy\n   */\n\n\n  RetryPolicy.prototype.delay = function (isPrimaryRetry, attempt) {\n    return tslib_1.__awaiter(this, void 0, void 0, function () {\n      var delayTimeInMs;\n      return tslib_1.__generator(this, function (_a) {\n        delayTimeInMs = 0;\n\n        if (isPrimaryRetry) {\n          switch (this.retryOptions.retryPolicyType) {\n            case RetryPolicyType.EXPONENTIAL:\n              delayTimeInMs = Math.min((Math.pow(2, attempt - 1) - 1) * this.retryOptions.retryDelayInMs, this.retryOptions.maxRetryDelayInMs);\n              break;\n\n            case RetryPolicyType.FIXED:\n              delayTimeInMs = this.retryOptions.retryDelayInMs;\n              break;\n          }\n        } else {\n          delayTimeInMs = Math.random() * 1000;\n        }\n\n        this.logf(HttpPipelineLogLevel.INFO, \"RetryPolicy: Delay for \" + delayTimeInMs + \"ms\");\n        return [2\n        /*return*/\n        , delay(delayTimeInMs)];\n      });\n    });\n  };\n\n  return RetryPolicy;\n}(BaseRequestPolicy);\n\nexport { RetryPolicy };","map":null,"metadata":{},"sourceType":"module"}