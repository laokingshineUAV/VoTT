{"ast":null,"code":"\"use strict\";\n\nvar _toConsumableArray = require(\"/home/jw/Documents/code/VoTT/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _regeneratorRuntime = require(\"/home/jw/Documents/code/VoTT/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/home/jw/Documents/code/VoTT/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/home/jw/Documents/code/VoTT/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/jw/Documents/code/VoTT/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar __await = this && this.__await || function (v) {\n  return this instanceof __await ? (this.v = v, this) : new __await(v);\n};\n\nvar __asyncGenerator = this && this.__asyncGenerator || function (thisArg, _arguments, generator) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var g = generator.apply(thisArg, _arguments || []),\n      i,\n      q = [];\n  return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () {\n    return this;\n  }, i;\n\n  function verb(n) {\n    if (g[n]) i[n] = function (v) {\n      return new Promise(function (a, b) {\n        q.push([n, v, a, b]) > 1 || resume(n, v);\n      });\n    };\n  }\n\n  function resume(n, v) {\n    try {\n      step(g[n](v));\n    } catch (e) {\n      settle(q[0][3], e);\n    }\n  }\n\n  function step(r) {\n    r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);\n  }\n\n  function fulfill(value) {\n    resume(\"next\", value);\n  }\n\n  function reject(value) {\n    resume(\"throw\", value);\n  }\n\n  function settle(f, v) {\n    if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);\n  }\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar LABColor_1 = require(\"./LABColor\");\n\nvar Color_1 = require(\"./Color\");\n/**\r\n * The `Palette` class to generate a palette with specified settings\r\n * and extract a subset as color swatches.\r\n */\n\n\nvar Palette =\n/*#__PURE__*/\nfunction () {\n  /** Creates a new palette with provided settings */\n  function Palette(settings) {\n    _classCallCheck(this, Palette);\n\n    this.settings = {\n      lightness: settings.lightness === undefined ? 0.65 : Math.max(0, Math.min(1, settings.lightness)),\n      lightnessVariation: settings.lightnessVariation === undefined ? 0 : Math.max(0, Math.min(1, settings.lightnessVariation)),\n      minGrayness: settings.minGrayness === undefined ? 0 : Math.max(0, Math.min(1, settings.minGrayness)),\n      maxGrayness: settings.maxGrayness === undefined ? 2 : Math.max(0, Math.min(2, settings.maxGrayness)),\n      granularity: settings.granularity === undefined ? 50 : Math.max(10, settings.granularity),\n      abRange: settings.abRange === undefined ? 1.3 : Math.max(0, Math.min(2, settings.abRange))\n    };\n    this.generateClusterPromise = this.generateGamutClusterAsync();\n  }\n  /**\r\n   * Returns a promise with Gamut points resolved when all points are calculated.\r\n   */\n\n\n  _createClass(Palette, [{\n    key: \"gamut\",\n    value: function () {\n      var _gamut = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee() {\n        var _this = this;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (!(this.gamutCluster !== undefined && this.gamutCluster !== null)) {\n                  _context.next = 4;\n                  break;\n                }\n\n                return _context.abrupt(\"return\", new Promise(function (resolve) {\n                  return resolve(_this.gamutCluster);\n                }));\n\n              case 4:\n                return _context.abrupt(\"return\", this.generateClusterPromise.then(function (cluster) {\n                  _this.gamutCluster = cluster;\n                  return cluster;\n                }));\n\n              case 5:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function gamut() {\n        return _gamut.apply(this, arguments);\n      }\n\n      return gamut;\n    }()\n    /**\r\n     * Generates a random set of swatches within the palette's gamut.\r\n     * @param colorsCount - The number of colors to be generated.\r\n     */\n\n  }, {\n    key: \"swatches\",\n    value: function () {\n      var _swatches = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee2(colorsCount) {\n        var _this2 = this;\n\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                return _context2.abrupt(\"return\", this.gamut().then(function (cluster) {\n                  var swatches = new Array();\n                  var first = Math.round(Math.random() * cluster.length);\n                  swatches.push(cluster[first]);\n\n                  for (var i = 0; i < colorsCount - 1; i++) {\n                    swatches.push(_this2.findNextColor(swatches, cluster));\n                  }\n\n                  return swatches;\n                }));\n\n              case 1:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function swatches(_x) {\n        return _swatches.apply(this, arguments);\n      }\n\n      return swatches;\n    }()\n    /**\r\n     * Expands provided set of swatches within the palette's gamut.\r\n     * @param swatches - The original set of swatches.\r\n     * @param colorsCount - The number of new colors to be generated.\r\n     */\n\n  }, {\n    key: \"more\",\n    value: function () {\n      var _more = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee3(swatches, colorsCount) {\n        var _this3 = this;\n\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                if (!(swatches.length > 0)) {\n                  _context3.next = 4;\n                  break;\n                }\n\n                return _context3.abrupt(\"return\", this.gamut().then(function (cluster) {\n                  var newSwatches = new Array();\n                  var allSwatches = swatches.map(function (sw) {\n                    return sw;\n                  });\n\n                  for (var i = 0; i < colorsCount; i++) {\n                    var swatch = _this3.findNextColor(allSwatches, cluster);\n\n                    allSwatches.push(swatch);\n                    newSwatches.push(swatch);\n                  }\n\n                  return newSwatches;\n                }));\n\n              case 4:\n                return _context3.abrupt(\"return\", this.swatches(colorsCount));\n\n              case 5:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function more(_x2, _x3) {\n        return _more.apply(this, arguments);\n      }\n\n      return more;\n    }()\n    /**\r\n     * Iteratively generates new swatches within the palette's gamut.\r\n     */\n\n  }, {\n    key: \"swatchIterator\",\n    value: function swatchIterator() {\n      return __asyncGenerator(this, arguments,\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function swatchIterator_1() {\n        var gamut, firstIndex, firstColor, swatches, lastColor, distance, nextColor;\n        return _regeneratorRuntime.wrap(function swatchIterator_1$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                _context4.next = 2;\n                return __await(this.gamut());\n\n              case 2:\n                gamut = _context4.sent;\n                firstIndex = Math.round(Math.random() * gamut.length);\n                firstColor = gamut[firstIndex];\n                _context4.next = 7;\n                return __await(firstColor);\n\n              case 7:\n                _context4.next = 9;\n                return _context4.sent;\n\n              case 9:\n                swatches = [firstColor];\n                lastColor = firstColor;\n                distance = 1.0;\n\n              case 12:\n                if (!(distance > 0)) {\n                  _context4.next = 24;\n                  break;\n                }\n\n                nextColor = this.findNextColor(swatches, gamut);\n                swatches.push(nextColor);\n                distance = nextColor.LAB.distanceTo_00(lastColor.LAB);\n                lastColor = nextColor;\n\n                if (!(distance > 0)) {\n                  _context4.next = 22;\n                  break;\n                }\n\n                _context4.next = 20;\n                return __await(nextColor);\n\n              case 20:\n                _context4.next = 22;\n                return _context4.sent;\n\n              case 22:\n                _context4.next = 12;\n                break;\n\n              case 24:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, swatchIterator_1, this);\n      }));\n    }\n    /**\r\n     * Finds the next color to expand the swatches set within the palette's gamut.\r\n     * Returns the point with maximum distance to all the colors in swatches.\r\n     * @param swatches - The original set of swatches.\r\n     * @param cluster - The cluster to look with-in.\r\n     */\n\n  }, {\n    key: \"findNextColor\",\n    value: function findNextColor(swatches, cluster) {\n      var candidate = cluster[0];\n      var maxDistanceSQ = 0;\n      cluster.forEach(function (colorPoint) {\n        var distances = swatches.map(function (swatchPoint) {\n          return colorPoint.LAB.distanceTo_00(swatchPoint.LAB);\n        });\n        var minDistanceSQ = Math.min.apply(Math, _toConsumableArray(distances));\n\n        if (minDistanceSQ > maxDistanceSQ) {\n          candidate = colorPoint;\n          maxDistanceSQ = minDistanceSQ;\n        }\n      });\n      return candidate;\n    }\n    /**\r\n     * Wraps the `generateGamutCluster` method into a Promise.\r\n     */\n\n  }, {\n    key: \"generateGamutClusterAsync\",\n    value: function generateGamutClusterAsync() {\n      var _this4 = this;\n\n      var promise = new Promise(function (resolve) {\n        _this4.gamutCluster = _this4.generateGamutCluster();\n        resolve(_this4.gamutCluster);\n      });\n      return promise;\n    }\n    /**\r\n     * Generates a gamut cluster of paired colors in CIELAB (LAB) and RGB,\r\n     * filtered by color points valid in RGB space and grayness constrains\r\n     * (withing the range of [`minGrainess`, `maxGrayness`]).\r\n     *\r\n     * This method augments the `generatePointsCluster` method with lightness settings,\r\n     * putting lightness equal to a random value within the range\r\n     * [`lightness` - `lightnessVariation`/2, `lightness` + `lightnessVariation`/2].\r\n     */\n\n  }, {\n    key: \"generateGamutCluster\",\n    value: function generateGamutCluster() {\n      var _this5 = this;\n\n      var cluster = this.generatePointsCluster(this.settings.granularity);\n      cluster = cluster.filter(function (p) {\n        var d = _this5.distanceToGray(p);\n\n        return d >= _this5.settings.minGrayness && d <= _this5.settings.maxGrayness;\n      });\n      var colorSpace = new Array();\n      cluster.forEach(function (p) {\n        var lightness = _this5.settings.lightness;\n\n        if (_this5.settings.lightnessVariation > 0) {\n          lightness += _this5.settings.lightnessVariation * (Math.random() - 0.5);\n          lightness = Math.max(0, Math.min(1, lightness));\n        }\n\n        var labcolor = new LABColor_1.LABColor(lightness, p.a, p.b);\n        var color = new Color_1.Color(labcolor);\n\n        if (color.sRGB.isValidColor()) {\n          colorSpace.push(color);\n        }\n      });\n      return colorSpace;\n    }\n    /**\r\n     * Calculate distance from color point to a zero-point (`a = b = 0`).\r\n     * @param p - Origin point.\r\n     */\n\n  }, {\n    key: \"distanceToGray\",\n    value: function distanceToGray(p) {\n      return Math.sqrt(p.a * p.a + p.b * p.b);\n    }\n    /**\r\n     * Generate a grid of color points in AB-subspace, centered at `a = b = 0` and\r\n     * the grid size [-`abRage`, +`abRange`] in each dimension.\r\n     * @param granularity - Number of grid steps in each dimension.\r\n     */\n\n  }, {\n    key: \"generatePointsCluster\",\n    value: function generatePointsCluster(granularity) {\n      granularity = Math.round(granularity);\n      var cluster = new Array(granularity * granularity);\n      var range = this.settings.abRange;\n\n      for (var i = 0; i < granularity; i++) {\n        for (var j = 0; j < granularity; j++) {\n          cluster[i * granularity + j] = {\n            a: range * 2 * i / (granularity - 1) - range,\n            b: range * 2 * j / (granularity - 1) - range\n          };\n        }\n      }\n\n      return cluster;\n    }\n  }]);\n\n  return Palette;\n}();\n\nexports.Palette = Palette;","map":null,"metadata":{},"sourceType":"script"}