{"ast":null,"code":"import _objectSpread from \"/home/jw/Documents/code/VoTT/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread\";\nimport _regeneratorRuntime from \"/home/jw/Documents/code/VoTT/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/home/jw/Documents/code/VoTT/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"/home/jw/Documents/code/VoTT/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/jw/Documents/code/VoTT/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport MD5 from \"md5.js\";\nimport _ from \"lodash\";\nimport * as shortid from \"shortid\";\nimport Guard from \"../common/guard\";\nimport { AssetType, AssetState, RegionType } from \"../models/applicationState\";\nimport { AssetProviderFactory } from \"../providers/storage/assetProviderFactory\";\nimport { StorageProviderFactory } from \"../providers/storage/storageProviderFactory\";\nimport { constants } from \"../common/constants\";\nimport HtmlFileReader from \"../common/htmlFileReader\";\nimport { TFRecordsReader } from \"../providers/export/tensorFlowRecords/tensorFlowReader\";\nimport { FeatureType } from \"../providers/export/tensorFlowRecords/tensorFlowBuilder\";\nimport { appInfo } from \"../common/appInfo\";\nimport { encodeFileURI } from \"../common/utils\";\n/**\n * @name - Asset Service\n * @description - Functions for dealing with project assets\n */\n\nexport var AssetService =\n/*#__PURE__*/\nfunction () {\n  _createClass(AssetService, null, [{\n    key: \"createAssetFromFilePath\",\n\n    /**\n     * Create IAsset from filePath\n     * @param filePath - filepath of asset\n     * @param fileName - name of asset\n     */\n    value: function createAssetFromFilePath(filePath, fileName) {\n      Guard.empty(filePath);\n      var normalizedPath = filePath.toLowerCase(); // If the path is not already prefixed with a protocol\n      // then assume it comes from the local file system\n\n      if (!normalizedPath.startsWith(\"http://\") && !normalizedPath.startsWith(\"https://\") && !normalizedPath.startsWith(\"file:\")) {\n        // First replace \\ character with / the do the standard url encoding then encode unsupported characters\n        filePath = encodeFileURI(filePath, true);\n      }\n\n      var md5Hash = new MD5().update(filePath).digest(\"hex\");\n      var pathParts = filePath.split(/[\\\\\\/]/); // Example filename: video.mp4#t=5\n      // fileNameParts[0] = \"video\"\n      // fileNameParts[1] = \"mp4\"\n      // fileNameParts[2] = \"t=5\"\n\n      fileName = fileName || pathParts[pathParts.length - 1];\n      var fileNameParts = fileName.split(\".\");\n      var extensionParts = fileNameParts[fileNameParts.length - 1].split(/[\\?#]/);\n      var assetFormat = extensionParts[0];\n      var assetType = this.getAssetType(assetFormat);\n      return {\n        id: md5Hash,\n        format: assetFormat,\n        state: AssetState.NotVisited,\n        type: assetType,\n        name: fileName,\n        path: filePath,\n        size: null\n      };\n    }\n    /**\n     * Get Asset Type from format (file extension)\n     * @param format - File extension of asset\n     */\n\n  }, {\n    key: \"getAssetType\",\n    value: function getAssetType(format) {\n      switch (format.toLowerCase()) {\n        case \"gif\":\n        case \"jpg\":\n        case \"jpeg\":\n        case \"tif\":\n        case \"tiff\":\n        case \"png\":\n        case \"bmp\":\n          return AssetType.Image;\n\n        case \"mp4\":\n        case \"mov\":\n        case \"avi\":\n        case \"m4v\":\n        case \"mpg\":\n        case \"wmv\":\n          return AssetType.Video;\n\n        case \"tfrecord\":\n          return AssetType.TFRecord;\n\n        default:\n          return AssetType.Unknown;\n      }\n    }\n  }]);\n\n  function AssetService(project) {\n    _classCallCheck(this, AssetService);\n\n    this.project = project;\n    Guard.null(project);\n  }\n  /**\n   * Get Asset Provider from project's source connction\n   */\n\n\n  _createClass(AssetService, [{\n    key: \"getAssets\",\n\n    /**\n     * Get assets from provider\n     */\n    value: function () {\n      var _getAssets = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee() {\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return this.assetProvider.getAssets();\n\n              case 2:\n                return _context.abrupt(\"return\", _context.sent);\n\n              case 3:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function getAssets() {\n        return _getAssets.apply(this, arguments);\n      }\n\n      return getAssets;\n    }()\n    /**\n     * Get a list of child assets associated with the current asset\n     * @param rootAsset The parent asset to search\n     */\n\n  }, {\n    key: \"getChildAssets\",\n    value: function getChildAssets(rootAsset) {\n      Guard.null(rootAsset);\n\n      if (rootAsset.type !== AssetType.Video) {\n        return [];\n      }\n\n      return _.values(this.project.assets).filter(function (asset) {\n        return asset.parent && asset.parent.id === rootAsset.id;\n      }).sort(function (a, b) {\n        return a.timestamp - b.timestamp;\n      });\n    }\n    /**\n     * Save metadata for asset\n     * @param metadata - Metadata for asset\n     */\n\n  }, {\n    key: \"save\",\n    value: function () {\n      var _save = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee2(metadata) {\n        var fileName;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                Guard.null(metadata);\n                fileName = \"\".concat(metadata.asset.id).concat(constants.assetMetadataFileExtension); // Only save asset metadata if asset is in a tagged state\n                // Otherwise primary asset information is already persisted in the project file.\n\n                if (!(metadata.asset.state === AssetState.Tagged)) {\n                  _context2.next = 7;\n                  break;\n                }\n\n                _context2.next = 5;\n                return this.storageProvider.writeText(fileName, JSON.stringify(metadata, null, 4));\n\n              case 5:\n                _context2.next = 14;\n                break;\n\n              case 7:\n                _context2.prev = 7;\n                _context2.next = 10;\n                return this.storageProvider.deleteFile(fileName);\n\n              case 10:\n                _context2.next = 14;\n                break;\n\n              case 12:\n                _context2.prev = 12;\n                _context2.t0 = _context2[\"catch\"](7);\n\n              case 14:\n                return _context2.abrupt(\"return\", metadata);\n\n              case 15:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this, [[7, 12]]);\n      }));\n\n      function save(_x) {\n        return _save.apply(this, arguments);\n      }\n\n      return save;\n    }()\n    /**\n     * Get metadata for asset\n     * @param asset - Asset for which to retrieve metadata\n     */\n\n  }, {\n    key: \"getAssetMetadata\",\n    value: function () {\n      var _getAssetMetadata = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee3(asset) {\n        var fileName, json;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                Guard.null(asset);\n                fileName = \"\".concat(asset.id).concat(constants.assetMetadataFileExtension);\n                _context3.prev = 2;\n                _context3.next = 5;\n                return this.storageProvider.readText(fileName);\n\n              case 5:\n                json = _context3.sent;\n                return _context3.abrupt(\"return\", JSON.parse(json));\n\n              case 9:\n                _context3.prev = 9;\n                _context3.t0 = _context3[\"catch\"](2);\n\n                if (!(asset.type === AssetType.TFRecord)) {\n                  _context3.next = 20;\n                  break;\n                }\n\n                _context3.t1 = _objectSpread({}, asset);\n                _context3.next = 15;\n                return this.getRegionsFromTFRecord(asset);\n\n              case 15:\n                _context3.t2 = _context3.sent;\n                _context3.t3 = appInfo.version;\n                return _context3.abrupt(\"return\", {\n                  asset: _context3.t1,\n                  regions: _context3.t2,\n                  version: _context3.t3\n                });\n\n              case 20:\n                return _context3.abrupt(\"return\", {\n                  asset: _objectSpread({}, asset),\n                  regions: [],\n                  version: appInfo.version\n                });\n\n              case 21:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this, [[2, 9]]);\n      }));\n\n      function getAssetMetadata(_x2) {\n        return _getAssetMetadata.apply(this, arguments);\n      }\n\n      return getAssetMetadata;\n    }()\n    /**\n     * Delete a tag from asset metadata files\n     * @param tagName Name of tag to delete\n     */\n\n  }, {\n    key: \"deleteTag\",\n    value: function () {\n      var _deleteTag = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee4(tagName) {\n        var transformer;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                transformer = function transformer(tags) {\n                  return tags.filter(function (t) {\n                    return t !== tagName;\n                  });\n                };\n\n                _context4.next = 3;\n                return this.getUpdatedAssets(tagName, transformer);\n\n              case 3:\n                return _context4.abrupt(\"return\", _context4.sent);\n\n              case 4:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function deleteTag(_x3) {\n        return _deleteTag.apply(this, arguments);\n      }\n\n      return deleteTag;\n    }()\n    /**\n     * Rename a tag within asset metadata files\n     * @param tagName Name of tag to rename\n     */\n\n  }, {\n    key: \"renameTag\",\n    value: function () {\n      var _renameTag = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee5(tagName, newTagName) {\n        var transformer;\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                transformer = function transformer(tags) {\n                  return tags.map(function (t) {\n                    return t === tagName ? newTagName : t;\n                  });\n                };\n\n                _context5.next = 3;\n                return this.getUpdatedAssets(tagName, transformer);\n\n              case 3:\n                return _context5.abrupt(\"return\", _context5.sent);\n\n              case 4:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function renameTag(_x4, _x5) {\n        return _renameTag.apply(this, arguments);\n      }\n\n      return renameTag;\n    }()\n    /**\n     * Update tags within asset metadata files\n     * @param tagName Name of tag to update within project\n     * @param transformer Function that accepts array of tags from a region and returns a modified array of tags\n     */\n\n  }, {\n    key: \"getUpdatedAssets\",\n    value: function () {\n      var _getUpdatedAssets = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee7(tagName, transformer) {\n        var _this = this;\n\n        var updates;\n        return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                _context7.next = 2;\n                return _.values(this.project.assets).mapAsync(\n                /*#__PURE__*/\n                function () {\n                  var _ref = _asyncToGenerator(\n                  /*#__PURE__*/\n                  _regeneratorRuntime.mark(function _callee6(asset) {\n                    var assetMetadata, isUpdated;\n                    return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n                      while (1) {\n                        switch (_context6.prev = _context6.next) {\n                          case 0:\n                            _context6.next = 2;\n                            return _this.getAssetMetadata(asset);\n\n                          case 2:\n                            assetMetadata = _context6.sent;\n                            isUpdated = _this.updateTagInAssetMetadata(assetMetadata, tagName, transformer);\n                            return _context6.abrupt(\"return\", isUpdated ? assetMetadata : null);\n\n                          case 5:\n                          case \"end\":\n                            return _context6.stop();\n                        }\n                      }\n                    }, _callee6, this);\n                  }));\n\n                  return function (_x8) {\n                    return _ref.apply(this, arguments);\n                  };\n                }());\n\n              case 2:\n                updates = _context7.sent;\n                return _context7.abrupt(\"return\", updates.filter(function (assetMetadata) {\n                  return !!assetMetadata;\n                }));\n\n              case 4:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this);\n      }));\n\n      function getUpdatedAssets(_x6, _x7) {\n        return _getUpdatedAssets.apply(this, arguments);\n      }\n\n      return getUpdatedAssets;\n    }()\n    /**\n     * Update tag within asset metadata object\n     * @param assetMetadata Asset metadata to update\n     * @param tagName Name of tag being updated\n     * @param transformer Function that accepts array of tags from a region and returns a modified array of tags\n     * @returns Modified asset metadata object or null if object does not need to be modified\n     */\n\n  }, {\n    key: \"updateTagInAssetMetadata\",\n    value: function updateTagInAssetMetadata(assetMetadata, tagName, transformer) {\n      var foundTag = false;\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = assetMetadata.regions[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var region = _step.value;\n\n          if (region.tags.find(function (t) {\n            return t === tagName;\n          })) {\n            foundTag = true;\n            region.tags = transformer(region.tags);\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      if (foundTag) {\n        assetMetadata.regions = assetMetadata.regions.filter(function (region) {\n          return region.tags.length > 0;\n        });\n        assetMetadata.asset.state = assetMetadata.regions.length ? AssetState.Tagged : AssetState.Visited;\n        return true;\n      }\n\n      return false;\n    }\n  }, {\n    key: \"getRegionsFromTFRecord\",\n    value: function () {\n      var _getRegionsFromTFRecord = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee8(asset) {\n        var objectArray, regions, index;\n        return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                _context8.next = 2;\n                return this.getTFRecordMetadata(asset);\n\n              case 2:\n                objectArray = _context8.sent;\n                regions = []; // Add Regions from TFRecord in Regions\n\n                for (index = 0; index < objectArray.textArray.length; index++) {\n                  regions.push({\n                    id: shortid.generate(),\n                    type: RegionType.Rectangle,\n                    tags: [objectArray.textArray[index]],\n                    boundingBox: {\n                      left: objectArray.xminArray[index] * objectArray.width,\n                      top: objectArray.yminArray[index] * objectArray.height,\n                      width: (objectArray.xmaxArray[index] - objectArray.xminArray[index]) * objectArray.width,\n                      height: (objectArray.ymaxArray[index] - objectArray.yminArray[index]) * objectArray.height\n                    },\n                    points: [{\n                      x: objectArray.xminArray[index] * objectArray.width,\n                      y: objectArray.yminArray[index] * objectArray.height\n                    }, {\n                      x: objectArray.xmaxArray[index] * objectArray.width,\n                      y: objectArray.ymaxArray[index] * objectArray.height\n                    }]\n                  });\n                }\n\n                return _context8.abrupt(\"return\", regions);\n\n              case 6:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this);\n      }));\n\n      function getRegionsFromTFRecord(_x9) {\n        return _getRegionsFromTFRecord.apply(this, arguments);\n      }\n\n      return getRegionsFromTFRecord;\n    }()\n  }, {\n    key: \"getTFRecordMetadata\",\n    value: function () {\n      var _getTFRecordMetadata = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee9(asset) {\n        var tfrecords, reader, width, height, xminArray, yminArray, xmaxArray, ymaxArray, textArray;\n        return _regeneratorRuntime.wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                _context9.t0 = Buffer;\n                _context9.next = 3;\n                return HtmlFileReader.getAssetArray(asset);\n\n              case 3:\n                _context9.t1 = _context9.sent;\n                tfrecords = new _context9.t0(_context9.t1);\n                reader = new TFRecordsReader(tfrecords);\n                width = reader.getFeature(0, \"image/width\", FeatureType.Int64);\n                height = reader.getFeature(0, \"image/height\", FeatureType.Int64);\n                xminArray = reader.getArrayFeature(0, \"image/object/bbox/xmin\", FeatureType.Float);\n                yminArray = reader.getArrayFeature(0, \"image/object/bbox/ymin\", FeatureType.Float);\n                xmaxArray = reader.getArrayFeature(0, \"image/object/bbox/xmax\", FeatureType.Float);\n                ymaxArray = reader.getArrayFeature(0, \"image/object/bbox/ymax\", FeatureType.Float);\n                textArray = reader.getArrayFeature(0, \"image/object/class/text\", FeatureType.String);\n                return _context9.abrupt(\"return\", {\n                  width: width,\n                  height: height,\n                  xminArray: xminArray,\n                  yminArray: yminArray,\n                  xmaxArray: xmaxArray,\n                  ymaxArray: ymaxArray,\n                  textArray: textArray\n                });\n\n              case 14:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9, this);\n      }));\n\n      function getTFRecordMetadata(_x10) {\n        return _getTFRecordMetadata.apply(this, arguments);\n      }\n\n      return getTFRecordMetadata;\n    }()\n  }, {\n    key: \"assetProvider\",\n    get: function get() {\n      if (!this.assetProviderInstance) {\n        this.assetProviderInstance = AssetProviderFactory.create(this.project.sourceConnection.providerType, this.project.sourceConnection.providerOptions);\n        return this.assetProviderInstance;\n      }\n    }\n    /**\n     * Get Storage Provider from project's target connection\n     */\n\n  }, {\n    key: \"storageProvider\",\n    get: function get() {\n      if (!this.storageProviderInstance) {\n        this.storageProviderInstance = StorageProviderFactory.create(this.project.targetConnection.providerType, this.project.targetConnection.providerOptions);\n      }\n\n      return this.storageProviderInstance;\n    }\n  }]);\n\n  return AssetService;\n}();","map":{"version":3,"sources":["/home/jw/Documents/code/VoTT/src/services/assetService.ts"],"names":["MD5","_","shortid","Guard","AssetType","AssetState","RegionType","AssetProviderFactory","StorageProviderFactory","constants","HtmlFileReader","TFRecordsReader","FeatureType","appInfo","encodeFileURI","AssetService","filePath","fileName","empty","normalizedPath","toLowerCase","startsWith","md5Hash","update","digest","pathParts","split","length","fileNameParts","extensionParts","assetFormat","assetType","getAssetType","id","format","state","NotVisited","type","name","path","size","Image","Video","TFRecord","Unknown","project","null","assetProvider","getAssets","rootAsset","values","assets","filter","asset","parent","sort","a","b","timestamp","metadata","assetMetadataFileExtension","Tagged","storageProvider","writeText","JSON","stringify","deleteFile","readText","json","parse","getRegionsFromTFRecord","version","regions","tagName","transformer","tags","t","getUpdatedAssets","newTagName","map","mapAsync","getAssetMetadata","assetMetadata","isUpdated","updateTagInAssetMetadata","updates","foundTag","region","find","Visited","getTFRecordMetadata","objectArray","index","textArray","push","generate","Rectangle","boundingBox","left","xminArray","width","top","yminArray","height","xmaxArray","ymaxArray","points","x","y","Buffer","getAssetArray","tfrecords","reader","getFeature","Int64","getArrayFeature","Float","String","assetProviderInstance","create","sourceConnection","providerType","providerOptions","storageProviderInstance","targetConnection"],"mappings":"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","sourcesContent":["import MD5 from \"md5.js\";\nimport _ from \"lodash\";\nimport * as shortid from \"shortid\";\nimport Guard from \"../common/guard\";\nimport {\n    IAsset, AssetType, IProject, IAssetMetadata, AssetState,\n    IRegion, RegionType, ITFRecordMetadata,\n} from \"../models/applicationState\";\nimport { AssetProviderFactory, IAssetProvider } from \"../providers/storage/assetProviderFactory\";\nimport { StorageProviderFactory, IStorageProvider } from \"../providers/storage/storageProviderFactory\";\nimport { constants } from \"../common/constants\";\nimport HtmlFileReader from \"../common/htmlFileReader\";\nimport { TFRecordsReader } from \"../providers/export/tensorFlowRecords/tensorFlowReader\";\nimport { FeatureType } from \"../providers/export/tensorFlowRecords/tensorFlowBuilder\";\nimport { appInfo } from \"../common/appInfo\";\nimport { encodeFileURI } from \"../common/utils\";\n\n/**\n * @name - Asset Service\n * @description - Functions for dealing with project assets\n */\nexport class AssetService {\n\n    /**\n     * Create IAsset from filePath\n     * @param filePath - filepath of asset\n     * @param fileName - name of asset\n     */\n    public static createAssetFromFilePath(filePath: string, fileName?: string): IAsset {\n        Guard.empty(filePath);\n\n        const normalizedPath = filePath.toLowerCase();\n\n        // If the path is not already prefixed with a protocol\n        // then assume it comes from the local file system\n        if (!normalizedPath.startsWith(\"http://\") &&\n            !normalizedPath.startsWith(\"https://\") &&\n            !normalizedPath.startsWith(\"file:\")) {\n            // First replace \\ character with / the do the standard url encoding then encode unsupported characters\n            filePath = encodeFileURI(filePath, true);\n        }\n\n        const md5Hash = new MD5().update(filePath).digest(\"hex\");\n        const pathParts = filePath.split(/[\\\\\\/]/);\n        // Example filename: video.mp4#t=5\n        // fileNameParts[0] = \"video\"\n        // fileNameParts[1] = \"mp4\"\n        // fileNameParts[2] = \"t=5\"\n        fileName = fileName || pathParts[pathParts.length - 1];\n        const fileNameParts = fileName.split(\".\");\n        const extensionParts = fileNameParts[fileNameParts.length - 1].split(/[\\?#]/);\n        const assetFormat = extensionParts[0];\n\n        const assetType = this.getAssetType(assetFormat);\n\n        return {\n            id: md5Hash,\n            format: assetFormat,\n            state: AssetState.NotVisited,\n            type: assetType,\n            name: fileName,\n            path: filePath,\n            size: null,\n        };\n    }\n\n    /**\n     * Get Asset Type from format (file extension)\n     * @param format - File extension of asset\n     */\n    public static getAssetType(format: string): AssetType {\n        switch (format.toLowerCase()) {\n            case \"gif\":\n            case \"jpg\":\n            case \"jpeg\":\n            case \"tif\":\n            case \"tiff\":\n            case \"png\":\n            case \"bmp\":\n                return AssetType.Image;\n            case \"mp4\":\n            case \"mov\":\n            case \"avi\":\n            case \"m4v\":\n            case \"mpg\":\n            case \"wmv\":\n                return AssetType.Video;\n            case \"tfrecord\":\n                return AssetType.TFRecord;\n            default:\n                return AssetType.Unknown;\n        }\n    }\n\n    private assetProviderInstance: IAssetProvider;\n    private storageProviderInstance: IStorageProvider;\n\n    constructor(private project: IProject) {\n        Guard.null(project);\n    }\n\n    /**\n     * Get Asset Provider from project's source connction\n     */\n    protected get assetProvider(): IAssetProvider {\n        if (!this.assetProviderInstance) {\n            this.assetProviderInstance = AssetProviderFactory.create(\n                this.project.sourceConnection.providerType,\n                this.project.sourceConnection.providerOptions,\n            );\n\n            return this.assetProviderInstance;\n        }\n    }\n\n    /**\n     * Get Storage Provider from project's target connection\n     */\n    protected get storageProvider(): IStorageProvider {\n        if (!this.storageProviderInstance) {\n            this.storageProviderInstance = StorageProviderFactory.create(\n                this.project.targetConnection.providerType,\n                this.project.targetConnection.providerOptions,\n            );\n        }\n\n        return this.storageProviderInstance;\n    }\n\n    /**\n     * Get assets from provider\n     */\n    public async getAssets(): Promise<IAsset[]> {\n        return await this.assetProvider.getAssets();\n    }\n\n    /**\n     * Get a list of child assets associated with the current asset\n     * @param rootAsset The parent asset to search\n     */\n    public getChildAssets(rootAsset: IAsset): IAsset[] {\n        Guard.null(rootAsset);\n\n        if (rootAsset.type !== AssetType.Video) {\n            return [];\n        }\n\n        return _\n            .values(this.project.assets)\n            .filter((asset) => asset.parent && asset.parent.id === rootAsset.id)\n            .sort((a, b) => a.timestamp - b.timestamp);\n    }\n\n    /**\n     * Save metadata for asset\n     * @param metadata - Metadata for asset\n     */\n    public async save(metadata: IAssetMetadata): Promise<IAssetMetadata> {\n        Guard.null(metadata);\n\n        const fileName = `${metadata.asset.id}${constants.assetMetadataFileExtension}`;\n\n        // Only save asset metadata if asset is in a tagged state\n        // Otherwise primary asset information is already persisted in the project file.\n        if (metadata.asset.state === AssetState.Tagged) {\n            await this.storageProvider.writeText(fileName, JSON.stringify(metadata, null, 4));\n        } else {\n            // If the asset is no longer tagged, then it doesn't contain any regions\n            // and the file is not required.\n            try {\n                await this.storageProvider.deleteFile(fileName);\n            } catch (err) {\n                // The file may not exist - that's OK\n            }\n        }\n        return metadata;\n    }\n\n    /**\n     * Get metadata for asset\n     * @param asset - Asset for which to retrieve metadata\n     */\n    public async getAssetMetadata(asset: IAsset): Promise<IAssetMetadata> {\n        Guard.null(asset);\n\n        const fileName = `${asset.id}${constants.assetMetadataFileExtension}`;\n        try {\n            const json = await this.storageProvider.readText(fileName);\n            return JSON.parse(json) as IAssetMetadata;\n        } catch (err) {\n            if (asset.type === AssetType.TFRecord) {\n                return {\n                    asset: { ...asset },\n                    regions: await this.getRegionsFromTFRecord(asset),\n                    version: appInfo.version,\n                };\n            } else {\n                return {\n                    asset: { ...asset },\n                    regions: [],\n                    version: appInfo.version,\n                };\n            }\n        }\n    }\n\n    /**\n     * Delete a tag from asset metadata files\n     * @param tagName Name of tag to delete\n     */\n    public async deleteTag(tagName: string): Promise<IAssetMetadata[]> {\n        const transformer = (tags) => tags.filter((t) => t !== tagName);\n        return await this.getUpdatedAssets(tagName, transformer);\n    }\n\n    /**\n     * Rename a tag within asset metadata files\n     * @param tagName Name of tag to rename\n     */\n    public async renameTag(tagName: string, newTagName: string): Promise<IAssetMetadata[]> {\n        const transformer = (tags) => tags.map((t) => (t === tagName) ? newTagName : t);\n        return await this.getUpdatedAssets(tagName, transformer);\n    }\n\n    /**\n     * Update tags within asset metadata files\n     * @param tagName Name of tag to update within project\n     * @param transformer Function that accepts array of tags from a region and returns a modified array of tags\n     */\n    private async getUpdatedAssets(tagName: string, transformer: (tags: string[]) => string[])\n        : Promise<IAssetMetadata[]> {\n        // Loop over assets and update if necessary\n        const updates = await _.values(this.project.assets).mapAsync(async (asset) => {\n            const assetMetadata = await this.getAssetMetadata(asset);\n            const isUpdated = this.updateTagInAssetMetadata(assetMetadata, tagName, transformer);\n\n            return isUpdated ? assetMetadata : null;\n        });\n\n        return updates.filter((assetMetadata) => !!assetMetadata);\n    }\n\n    /**\n     * Update tag within asset metadata object\n     * @param assetMetadata Asset metadata to update\n     * @param tagName Name of tag being updated\n     * @param transformer Function that accepts array of tags from a region and returns a modified array of tags\n     * @returns Modified asset metadata object or null if object does not need to be modified\n     */\n    private updateTagInAssetMetadata(\n        assetMetadata: IAssetMetadata,\n        tagName: string,\n        transformer: (tags: string[]) => string[]): boolean {\n        let foundTag = false;\n\n        for (const region of assetMetadata.regions) {\n            if (region.tags.find((t) => t === tagName)) {\n                foundTag = true;\n                region.tags = transformer(region.tags);\n            }\n        }\n        if (foundTag) {\n            assetMetadata.regions = assetMetadata.regions.filter((region) => region.tags.length > 0);\n            assetMetadata.asset.state = (assetMetadata.regions.length) ? AssetState.Tagged : AssetState.Visited;\n            return true;\n        }\n\n        return false;\n    }\n\n    private async getRegionsFromTFRecord(asset: IAsset): Promise<IRegion[]> {\n        const objectArray = await this.getTFRecordMetadata(asset);\n        const regions: IRegion[] = [];\n\n        // Add Regions from TFRecord in Regions\n        for (let index = 0; index < objectArray.textArray.length; index++) {\n            regions.push({\n                id: shortid.generate(),\n                type: RegionType.Rectangle,\n                tags: [objectArray.textArray[index]],\n                boundingBox: {\n                    left: objectArray.xminArray[index] * objectArray.width,\n                    top: objectArray.yminArray[index] * objectArray.height,\n                    width: (objectArray.xmaxArray[index] - objectArray.xminArray[index]) * objectArray.width,\n                    height: (objectArray.ymaxArray[index] - objectArray.yminArray[index]) * objectArray.height,\n                },\n                points: [{\n                    x: objectArray.xminArray[index] * objectArray.width,\n                    y: objectArray.yminArray[index] * objectArray.height,\n                },\n                {\n                    x: objectArray.xmaxArray[index] * objectArray.width,\n                    y: objectArray.ymaxArray[index] * objectArray.height,\n                }],\n            });\n        }\n\n        return regions;\n    }\n\n    private async getTFRecordMetadata(asset: IAsset): Promise<ITFRecordMetadata> {\n        const tfrecords = new Buffer(await HtmlFileReader.getAssetArray(asset));\n        const reader = new TFRecordsReader(tfrecords);\n\n        const width = reader.getFeature(0, \"image/width\", FeatureType.Int64) as number;\n        const height = reader.getFeature(0, \"image/height\", FeatureType.Int64) as number;\n\n        const xminArray = reader.getArrayFeature(0, \"image/object/bbox/xmin\", FeatureType.Float) as number[];\n        const yminArray = reader.getArrayFeature(0, \"image/object/bbox/ymin\", FeatureType.Float) as number[];\n        const xmaxArray = reader.getArrayFeature(0, \"image/object/bbox/xmax\", FeatureType.Float) as number[];\n        const ymaxArray = reader.getArrayFeature(0, \"image/object/bbox/ymax\", FeatureType.Float) as number[];\n        const textArray = reader.getArrayFeature(0, \"image/object/class/text\", FeatureType.String) as string[];\n\n        return { width, height, xminArray, yminArray, xmaxArray, ymaxArray, textArray };\n    }\n}\n"]},"metadata":{},"sourceType":"module"}