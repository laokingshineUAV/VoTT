{"ast":null,"code":"\"use strict\";\n\nvar _toConsumableArray = require(\"/home/jw/Documents/code/VoTT/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _classCallCheck = require(\"/home/jw/Documents/code/VoTT/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/jw/Documents/code/VoTT/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"/home/jw/Documents/code/VoTT/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/home/jw/Documents/code/VoTT/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/home/jw/Documents/code/VoTT/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar react_1 = __importDefault(require(\"react\"));\n\nvar react_tag_input_1 = require(\"react-tag-input\");\n\nvar utils_1 = require(\"../../common/utils\");\n\nvar tagColors_1 = require(\"../common/tagColors\");\n\nexports.defaultValues = {\n  tagColors: tagColors_1.tagColors,\n  delimiters: [utils_1.KeyCodes.comma, utils_1.KeyCodes.enter],\n  placeHolder: \"Add new tag\"\n};\n/**\n * Component for creating, modifying and using tags\n */\n\nvar TagsInput =\n/*#__PURE__*/\nfunction (_react_1$default$Comp) {\n  _inherits(TagsInput, _react_1$default$Comp);\n\n  function TagsInput() {\n    var _this;\n\n    _classCallCheck(this, TagsInput);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(TagsInput).apply(this, arguments));\n    _this.state = {\n      tags: _this.props.tags,\n      currentTagColorIndex: 0\n    };\n    /**\n     * Update an existing tag, called after clicking \"OK\" in modal\n     * @param oldTag Tag being edited\n     * @param newTag Newly edited version of tag\n     */\n\n    _this.updateTag = function (oldTag, newTag) {\n      /**\n       * If this was a name change (ids are not equal), don\"t allow\n       * the new tag to be named with a name that currently exists\n       * in other tags. Probably should include an error message.\n       * For now, just doesn\"t allow the action to take place. Modal\n       * won\"t close and user won\"t be able to set the name. This is\n       * similar to how the component handles duplicate naming at the\n       * creation level. If user enters name that already exists in\n       * tags, the component just doesn\"t do anything.\n       */\n      if (newTag.name !== oldTag.name && _this.state.tags.some(function (t) {\n        return t.name === newTag.name;\n      })) {\n        return;\n      }\n\n      var tags = _this.state.tags.map(function (tag) {\n        return tag.name === oldTag.name ? newTag : tag;\n      });\n\n      _this.setState({\n        tags: tags\n      }, function () {\n        return _this.props.onChange(tags);\n      });\n    };\n    /**\n     * Get span element for each tag\n     * Protected so that inheriting components can override if necessary\n     * Defaults to just returning the name of the tag in the span\n     * @param name Name of tag to get\n     */\n\n\n    _this.getTagSpan = function (name) {\n      if (_this.props.getTagSpan) {\n        return _this.props.getTagSpan(name, _this.getTagIndex(name));\n      }\n\n      return react_1.default.createElement(\"span\", null, name);\n    };\n\n    _this.getTagColorKeys = function () {\n      return Object.keys(_this.getTagColors());\n    };\n\n    _this.getTagColors = function () {\n      return _this.props.tagColors || exports.defaultValues.tagColors;\n    };\n\n    _this.getTagIndex = function (name) {\n      return _this.state.tags.findIndex(function (tag) {\n        return tag.name === name;\n      });\n    }; // UI Handlers\n\n    /**\n     * Calls the onTagClick handler if not null with clicked tag\n     * @param event Click event\n     */\n\n\n    _this.handleTagClick = function (event) {\n      var text = _this.getTagIdFromClick(event);\n\n      var tag = _this.getTag(text);\n\n      if (_this.props.onCtrlShiftTagClick && event.ctrlKey && event.shiftKey) {\n        _this.props.onCtrlShiftTagClick(tag);\n      } else if (_this.props.onCtrlTagClick && (event.ctrlKey || event.metaKey)) {\n        _this.props.onCtrlTagClick(tag);\n      } else if (_this.props.onShiftTagClick && event.shiftKey) {\n        _this.props.onShiftTagClick(tag);\n      } else if (_this.props.onTagClick) {\n        _this.props.onTagClick(tag);\n      }\n\n      _this.blurInput();\n    }; // Helpers\n\n    /**\n     * Gets the tag with the given name\n     * @param name string name of tag.\n     */\n\n\n    _this.getTag = function (name) {\n      var match = _this.state.tags.find(function (tag) {\n        return tag.name === name;\n      });\n\n      if (!match) {\n        throw new Error(\"No tag by name: \".concat(name));\n      }\n\n      return match;\n    };\n    /**\n     * Generate necessary HTML to render tag box appropriately\n     * @param name name of tag\n     * @param color color of tag\n     */\n\n\n    _this.ReactTagHtml = function (name, color) {\n      return react_1.default.createElement(\"div\", {\n        className: \"tag inline-block\",\n        \"data-tag-name\": name,\n        onClick: function onClick(event) {\n          return _this.handleTagClick(event);\n        }\n      }, react_1.default.createElement(\"div\", {\n        className: \"tag-contents\"\n      }, react_1.default.createElement(\"div\", {\n        className: \"tag-color-box\",\n        style: {\n          backgroundColor: color\n        }\n      }), _this.getTagSpan(name)));\n    };\n    /**\n     * Allows for click-and-drag re-ordering of tags\n     * @param tag Tag being dragged\n     * @param currPos Current position of tag\n     * @param newPos New position of tag\n     */\n\n\n    _this.handleDrag = function (tag, currPos, newPos) {\n      var tags = _toConsumableArray(_this.state.tags);\n\n      var newTags = tags.slice();\n      newTags.splice(currPos, 1);\n      newTags.splice(newPos, 0, _this.toItag(tag)); // Updating HTML is dependent upon state having most up to date\n      // values. Setting filtered state and then setting state with\n      // updated HTML in tags\n\n      _this.setState({\n        tags: newTags\n      }, function () {\n        return _this.props.onChange(_this.state.tags);\n      });\n\n      _this.blurInput();\n    }; // Tag Operations\n\n    /**\n     * Adds new tag to state with necessary HTML for rendering\n     * Sets the color of the tag to next color, rotates through each\n     * @param reactTag - IReactTag - new tag to add to state\n     */\n\n\n    _this.handleAddition = function (reactTag) {\n      var tag = _this.toItag(reactTag);\n\n      var inputElement = document.querySelector(\".ReactTags__tagInputField\");\n\n      var tagColors = _this.getTagColors();\n\n      var tagColorKeys = Object.keys(tagColors);\n      tag.color = tagColors[tagColorKeys[_this.state.currentTagColorIndex]];\n      var currentTags = _this.state.tags && _this.state.tags.length ? _this.state.tags : [];\n\n      _this.setState(function (prevState) {\n        return {\n          tags: [].concat(_toConsumableArray(currentTags), [tag]),\n          currentTagColorIndex: (prevState.currentTagColorIndex + 1) % tagColorKeys.length\n        };\n      }, function () {\n        return _this.props.onChange(_this.state.tags);\n      });\n\n      if (inputElement) {\n        setImmediate(function () {\n          return inputElement.focus();\n        });\n      }\n    };\n    /**\n     * Deletes tag from state\n     * Explicitly prevents deletion with backspace key\n     * @param i index of tag being deleted\n     * @param event delete event\n     */\n\n\n    _this.handleDelete = function (i, event) {\n      if (event.keyCode === utils_1.KeyCodes.backspace) {\n        return;\n      }\n\n      var deletedTag = _this.state.tags[i];\n\n      if (_this.props.onTagDelete) {\n        _this.props.onTagDelete(deletedTag);\n      }\n\n      var tags = _this.state.tags.filter(function (tag, index) {\n        return index !== i;\n      }); // Updating HTML is dependent upon state having most up to date\n      // values. Setting filtered state and then setting state with\n      // updated HTML in tags\n\n\n      _this.setState({\n        tags: tags\n      }, function () {\n        return _this.props.onChange(_this.state.tags);\n      });\n\n      _this.blurInput();\n    };\n    /**\n     * Converts ITag to IReactTag\n     * @param tag ITag to convert to IReactTag\n     */\n\n\n    _this.toReactTag = function (tag) {\n      if (!tag) {\n        return null;\n      }\n\n      return {\n        id: tag.name,\n        text: _this.ReactTagHtml(tag.name, tag.color),\n        color: tag.color\n      };\n    };\n    /**\n     * Adds necessary HTML for tag to render correctly\n     * @param tag tag needing Html\n     */\n\n\n    _this.addHtml = function (tag) {\n      tag.text = _this.ReactTagHtml(tag.id, tag.color);\n    };\n    /**\n     * Convert array of ITags to IReactTags\n     * @param props properties for component, contains tags in ITag format\n     */\n\n\n    _this.toReactTags = function (tags) {\n      return tags ? tags.map(function (element) {\n        return _this.toReactTag(element);\n      }) : [];\n    };\n    /**\n     * Convert array of IReactTags to ITags\n     * @param tags array of IReactTags to convert to ITags\n     */\n\n\n    _this.toITags = function (tags) {\n      return tags.map(function (element) {\n        return _this.toItag(element);\n      });\n    };\n    /**\n     * Converts IReactTag to ITag\n     * @param tag IReactTag to convert to ITag\n     */\n\n\n    _this.toItag = function (tag) {\n      if (!tag) {\n        return null;\n      }\n\n      return {\n        name: tag.id,\n        color: tag.color\n      };\n    };\n\n    _this.blurInput = function () {\n      var inputElement = document.querySelector(\".ReactTags__tagInputField\");\n\n      if (inputElement) {\n        setImmediate(function () {\n          return inputElement.blur();\n        });\n      }\n    };\n\n    return _this;\n  }\n\n  _createClass(TagsInput, [{\n    key: \"render\",\n    value: function render() {\n      var tags = this.state.tags;\n      return react_1.default.createElement(\"div\", null, react_1.default.createElement(react_tag_input_1.WithContext, {\n        ref: \"reactTagsInput\",\n        tags: this.toReactTags(this.state.tags),\n        placeholder: this.props.placeHolder || exports.defaultValues.placeHolder,\n        autofocus: false,\n        allowAdditionFromPaste: false,\n        handleDelete: this.handleDelete,\n        handleAddition: this.handleAddition,\n        handleDrag: this.handleDrag,\n        id: \"tagInputField\",\n        delimiters: this.props.delimiters || exports.defaultValues.delimiters\n      }));\n    }\n  }, {\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      this.setState({\n        currentTagColorIndex: utils_1.randomIntInRange(0, this.getTagColorKeys().length)\n      });\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps) {\n      if (prevProps.tags !== this.props.tags) {\n        this.setState({\n          tags: this.props.tags\n        });\n      }\n    }\n    /**\n     * Gets tag ID (name) from a click event\n     * @param event Click event\n     */\n\n  }, {\n    key: \"getTagIdFromClick\",\n    value: function getTagIdFromClick(event) {\n      var attrValue = event.currentTarget.getAttribute(\"data-tag-name\");\n      return attrValue ? attrValue.trim() : null;\n    }\n  }]);\n\n  return TagsInput;\n}(react_1.default.Component);\n\nexports.TagsInput = TagsInput;","map":null,"metadata":{},"sourceType":"script"}