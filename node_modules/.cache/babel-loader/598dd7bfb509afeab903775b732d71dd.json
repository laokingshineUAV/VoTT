{"ast":null,"code":"import _slicedToArray from \"/home/jw/Documents/code/VoTT/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _regeneratorRuntime from \"/home/jw/Documents/code/VoTT/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/home/jw/Documents/code/VoTT/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"/home/jw/Documents/code/VoTT/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/jw/Documents/code/VoTT/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport axios from \"axios\";\nimport * as shortid from \"shortid\";\nimport * as tf from \"@tensorflow/tfjs\";\nimport { ElectronProxyHandler } from \"./electronProxyHandler\";\nimport { RegionType } from \"../../models/applicationState\";\nimport { strings } from \"../../common/strings\"; // tslint:disable-next-line:interface-over-type-literal\n\n/**\n * Object Dectection loads active learning models and predicts regions\n */\nexport var ObjectDetection =\n/*#__PURE__*/\nfunction () {\n  function ObjectDetection() {\n    _classCallCheck(this, ObjectDetection);\n\n    this.modelLoaded = false;\n  }\n\n  _createClass(ObjectDetection, [{\n    key: \"dispose\",\n\n    /**\n     * Dispose the tensors allocated by the model. You should call this when you\n     * are done with the model.\n     */\n    value: function dispose() {\n      if (this.model) {\n        this.model.dispose();\n      }\n    }\n    /**\n     * Load a TensorFlow.js Object Detection model from file: or http URL.\n     * @param modelFolderPath file: or http URL to the model\n     */\n\n  }, {\n    key: \"load\",\n    value: function () {\n      var _load = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee3(modelFolderPath) {\n        var response, handler, result;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.prev = 0;\n\n                if (!(modelFolderPath.toLowerCase().startsWith(\"http://\") || modelFolderPath.toLowerCase().startsWith(\"https://\"))) {\n                  _context3.next = 11;\n                  break;\n                }\n\n                _context3.next = 4;\n                return tf.loadGraphModel(modelFolderPath + \"/model.json\");\n\n              case 4:\n                this.model = _context3.sent;\n                _context3.next = 7;\n                return axios.get(modelFolderPath + \"/classes.json\");\n\n              case 7:\n                response = _context3.sent;\n                this.jsonClasses = JSON.parse(JSON.stringify(response.data));\n                _context3.next = 18;\n                break;\n\n              case 11:\n                handler = new ElectronProxyHandler(modelFolderPath);\n                _context3.next = 14;\n                return tf.loadGraphModel(handler);\n\n              case 14:\n                this.model = _context3.sent;\n                _context3.next = 17;\n                return handler.loadClasses();\n\n              case 17:\n                this.jsonClasses = _context3.sent;\n\n              case 18:\n                _context3.next = 20;\n                return this.model.executeAsync(tf.zeros([1, 300, 300, 3]));\n\n              case 20:\n                result = _context3.sent;\n                result.forEach(\n                /*#__PURE__*/\n                function () {\n                  var _ref = _asyncToGenerator(\n                  /*#__PURE__*/\n                  _regeneratorRuntime.mark(function _callee(t) {\n                    return _regeneratorRuntime.wrap(function _callee$(_context) {\n                      while (1) {\n                        switch (_context.prev = _context.next) {\n                          case 0:\n                            _context.next = 2;\n                            return t.data();\n\n                          case 2:\n                            return _context.abrupt(\"return\", _context.sent);\n\n                          case 3:\n                          case \"end\":\n                            return _context.stop();\n                        }\n                      }\n                    }, _callee, this);\n                  }));\n\n                  return function (_x2) {\n                    return _ref.apply(this, arguments);\n                  };\n                }());\n                result.forEach(\n                /*#__PURE__*/\n                function () {\n                  var _ref2 = _asyncToGenerator(\n                  /*#__PURE__*/\n                  _regeneratorRuntime.mark(function _callee2(t) {\n                    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n                      while (1) {\n                        switch (_context2.prev = _context2.next) {\n                          case 0:\n                            return _context2.abrupt(\"return\", t.dispose());\n\n                          case 1:\n                          case \"end\":\n                            return _context2.stop();\n                        }\n                      }\n                    }, _callee2, this);\n                  }));\n\n                  return function (_x3) {\n                    return _ref2.apply(this, arguments);\n                  };\n                }());\n                this.modelLoaded = true;\n                _context3.next = 30;\n                break;\n\n              case 26:\n                _context3.prev = 26;\n                _context3.t0 = _context3[\"catch\"](0);\n                this.modelLoaded = false;\n                throw _context3.t0;\n\n              case 30:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this, [[0, 26]]);\n      }));\n\n      function load(_x) {\n        return _load.apply(this, arguments);\n      }\n\n      return load;\n    }()\n    /**\n     * Predict Regions from an HTMLImageElement returning list of IRegion.\n     * @param image ImageObject to be used for prediction\n     * @param predictTag Flag indicates if predict only region bounding box of tag too.\n     * @param xRatio Width compression ratio between the HTMLImageElement and the original image.\n     * @param yRatio Height compression ratio between the HTMLImageElement and the original image.\n     */\n\n  }, {\n    key: \"predictImage\",\n    value: function () {\n      var _predictImage = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee4(image, predictTag, xRatio, yRatio) {\n        var regions, predictions;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                regions = [];\n                _context4.next = 3;\n                return this.detect(image);\n\n              case 3:\n                predictions = _context4.sent;\n                predictions.forEach(function (prediction) {\n                  var left = Math.max(0, prediction.bbox[0] * xRatio);\n                  var top = Math.max(0, prediction.bbox[1] * yRatio);\n                  var width = Math.max(0, prediction.bbox[2] * xRatio);\n                  var height = Math.max(0, prediction.bbox[3] * yRatio);\n                  regions.push({\n                    id: shortid.generate(),\n                    type: RegionType.Rectangle,\n                    tags: predictTag ? [prediction.class] : [],\n                    boundingBox: {\n                      left: left,\n                      top: top,\n                      width: width,\n                      height: height\n                    },\n                    points: [{\n                      x: left,\n                      y: top\n                    }, {\n                      x: left + width,\n                      y: top\n                    }, {\n                      x: left + width,\n                      y: top + height\n                    }, {\n                      x: left,\n                      y: top + height\n                    }]\n                  });\n                });\n                return _context4.abrupt(\"return\", regions);\n\n              case 6:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function predictImage(_x4, _x5, _x6, _x7) {\n        return _predictImage.apply(this, arguments);\n      }\n\n      return predictImage;\n    }()\n    /**\n     * Detect objects for an image returning a list of bounding boxes with\n     * associated class and score.\n     *\n     * @param img The image to detect objects from. Can be a tensor or a DOM\n     *     element image, video, or canvas.\n     * @param maxNumBoxes The maximum number of bounding boxes of detected\n     * objects. There can be multiple objects of the same class, but at different\n     * locations. Defaults to 20.\n     *\n     */\n\n  }, {\n    key: \"detect\",\n    value: function () {\n      var _detect = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee5(img) {\n        var maxNumBoxes,\n            _args5 = arguments;\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                maxNumBoxes = _args5.length > 1 && _args5[1] !== undefined ? _args5[1] : 20;\n\n                if (!this.model) {\n                  _context5.next = 3;\n                  break;\n                }\n\n                return _context5.abrupt(\"return\", this.infer(img, maxNumBoxes));\n\n              case 3:\n                return _context5.abrupt(\"return\", []);\n\n              case 4:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function detect(_x8) {\n        return _detect.apply(this, arguments);\n      }\n\n      return detect;\n    }()\n    /**\n     * Infers through the model.\n     *\n     * @param img The image to classify. Can be a tensor or a DOM element image,\n     * video, or canvas.\n     * @param maxNumBoxes The maximum number of bounding boxes of detected\n     * objects. There can be multiple objects of the same class, but at different\n     * locations. Defaults to 20.\n     */\n\n  }, {\n    key: \"infer\",\n    value: function () {\n      var _infer = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee6(img) {\n        var maxNumBoxes,\n            batched,\n            height,\n            width,\n            result,\n            scores,\n            boxes,\n            _this$calculateMaxSco,\n            _this$calculateMaxSco2,\n            maxScores,\n            classes,\n            prevBackend,\n            indexTensor,\n            indexes,\n            _args6 = arguments;\n\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                maxNumBoxes = _args6.length > 1 && _args6[1] !== undefined ? _args6[1] : 20;\n                batched = tf.tidy(function () {\n                  if (!(img instanceof tf.Tensor)) {\n                    img = tf.browser.fromPixels(img);\n                  } // Reshape to a single-element batch so we can pass it to executeAsync.\n\n\n                  return img.expandDims(0);\n                });\n                height = batched.shape[1];\n                width = batched.shape[2]; // model returns two tensors:\n                // 1. box classification score with shape of [1, 1917, 90]\n                // 2. box location with shape of [1, 1917, 1, 4]\n                // where 1917 is the number of box detectors, 90 is the number of classes.\n                // and 4 is the four coordinates of the box.\n\n                _context6.next = 6;\n                return this.model.executeAsync(batched);\n\n              case 6:\n                result = _context6.sent;\n                scores = result[0].dataSync();\n                boxes = result[1].dataSync(); // clean the webgl tensors\n\n                batched.dispose();\n                tf.dispose(result);\n                _this$calculateMaxSco = this.calculateMaxScores(scores, result[0].shape[1], result[0].shape[2]), _this$calculateMaxSco2 = _slicedToArray(_this$calculateMaxSco, 2), maxScores = _this$calculateMaxSco2[0], classes = _this$calculateMaxSco2[1];\n                prevBackend = tf.getBackend(); // run post process in cpu\n\n                tf.setBackend(\"cpu\");\n                indexTensor = tf.tidy(function () {\n                  var boxes2 = tf.tensor2d(boxes, [result[1].shape[1], result[1].shape[3]]);\n                  return tf.image.nonMaxSuppression(boxes2, maxScores, maxNumBoxes, 0.5, 0.5);\n                });\n                indexes = indexTensor.dataSync();\n                indexTensor.dispose(); // restore previous backend\n\n                tf.setBackend(prevBackend);\n                return _context6.abrupt(\"return\", this.buildDetectedObjects(width, height, boxes, maxScores, indexes, classes));\n\n              case 19:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      function infer(_x9) {\n        return _infer.apply(this, arguments);\n      }\n\n      return infer;\n    }()\n  }, {\n    key: \"buildDetectedObjects\",\n    value: function buildDetectedObjects(width, height, boxes, scores, indexes, classes) {\n      var count = indexes.length;\n      var objects = [];\n\n      for (var i = 0; i < count; i++) {\n        var _bbox = [];\n\n        for (var j = 0; j < 4; j++) {\n          _bbox[j] = boxes[indexes[i] * 4 + j];\n        }\n\n        var minY = _bbox[0] * height;\n        var minX = _bbox[1] * width;\n        var maxY = _bbox[2] * height;\n        var maxX = _bbox[3] * width;\n        _bbox[0] = minX;\n        _bbox[1] = minY;\n        _bbox[2] = maxX - minX;\n        _bbox[3] = maxY - minY;\n        objects.push({\n          bbox: _bbox,\n          class: this.getClass(i, indexes, classes),\n          score: scores[indexes[i]]\n        });\n      }\n\n      return objects;\n    }\n  }, {\n    key: \"getClass\",\n    value: function getClass(index, indexes, classes) {\n      if (this.jsonClasses && index < indexes.length && indexes[index] < classes.length) {\n        var classId = classes[indexes[index]] - 1;\n        var classObject = this.jsonClasses[classId];\n        return classObject ? classObject.displayName : strings.tags.warnings.unknownTagName;\n      }\n\n      return \"\";\n    }\n  }, {\n    key: \"calculateMaxScores\",\n    value: function calculateMaxScores(scores, numBoxes, numClasses) {\n      var maxes = [];\n      var classes = [];\n\n      for (var i = 0; i < numBoxes; i++) {\n        var max = Number.MIN_VALUE;\n        var index = -1;\n\n        for (var j = 0; j < numClasses; j++) {\n          if (scores[i * numClasses + j] > max) {\n            max = scores[i * numClasses + j];\n            index = j;\n          }\n        }\n\n        maxes[i] = max;\n        classes[i] = index;\n      }\n\n      return [maxes, classes];\n    }\n  }, {\n    key: \"loaded\",\n    get: function get() {\n      return this.modelLoaded;\n    }\n  }]);\n\n  return ObjectDetection;\n}();","map":{"version":3,"sources":["/home/jw/Documents/code/VoTT/src/providers/activeLearning/objectDetection.ts"],"names":["axios","shortid","tf","ElectronProxyHandler","RegionType","strings","ObjectDetection","modelLoaded","model","dispose","modelFolderPath","toLowerCase","startsWith","loadGraphModel","get","response","jsonClasses","JSON","parse","stringify","data","handler","loadClasses","executeAsync","zeros","result","forEach","t","image","predictTag","xRatio","yRatio","regions","detect","predictions","prediction","left","Math","max","bbox","top","width","height","push","id","generate","type","Rectangle","tags","class","boundingBox","points","x","y","img","maxNumBoxes","infer","batched","tidy","Tensor","browser","fromPixels","expandDims","shape","scores","dataSync","boxes","calculateMaxScores","maxScores","classes","prevBackend","getBackend","setBackend","indexTensor","boxes2","tensor2d","nonMaxSuppression","indexes","buildDetectedObjects","count","length","objects","i","j","minY","minX","maxY","maxX","getClass","score","index","classId","classObject","displayName","warnings","unknownTagName","numBoxes","numClasses","maxes","Number","MIN_VALUE"],"mappings":"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","sourcesContent":["import axios from \"axios\";\nimport * as shortid from \"shortid\";\nimport * as tf from \"@tensorflow/tfjs\";\nimport { ElectronProxyHandler } from \"./electronProxyHandler\";\nimport { IRegion, RegionType } from \"../../models/applicationState\";\nimport { strings } from \"../../common/strings\";\n\n// tslint:disable-next-line:interface-over-type-literal\nexport type DetectedObject = {\n    bbox: [number, number, number, number];  // [x, y, width, height]\n    class: string;\n    score: number;\n};\n\n/**\n * Defines supported data types supported by Tensorflow JS\n */\nexport type ImageObject = tf.Tensor3D | ImageData | HTMLImageElement | HTMLCanvasElement | HTMLVideoElement;\n\n/**\n * Object Dectection loads active learning models and predicts regions\n */\nexport class ObjectDetection {\n    private modelLoaded: boolean = false;\n\n    get loaded(): boolean {\n        return this.modelLoaded;\n    }\n\n    private model: tf.GraphModel;\n    private jsonClasses: JSON;\n\n    /**\n     * Dispose the tensors allocated by the model. You should call this when you\n     * are done with the model.\n     */\n    public dispose() {\n        if (this.model) {\n            this.model.dispose();\n        }\n    }\n\n    /**\n     * Load a TensorFlow.js Object Detection model from file: or http URL.\n     * @param modelFolderPath file: or http URL to the model\n     */\n    public async load(modelFolderPath: string) {\n        try {\n            if (modelFolderPath.toLowerCase().startsWith(\"http://\") ||\n                modelFolderPath.toLowerCase().startsWith(\"https://\")) {\n                this.model = await tf.loadGraphModel(modelFolderPath + \"/model.json\");\n\n                const response = await axios.get(modelFolderPath + \"/classes.json\");\n                this.jsonClasses = JSON.parse(JSON.stringify(response.data));\n            } else {\n                const handler = new ElectronProxyHandler(modelFolderPath);\n                this.model = await tf.loadGraphModel(handler);\n                this.jsonClasses = await handler.loadClasses();\n            }\n\n            // Warmup the model.\n            const result = await this.model.executeAsync(tf.zeros([1, 300, 300, 3])) as tf.Tensor[];\n            result.forEach(async (t) => await t.data());\n            result.forEach(async (t) => t.dispose());\n            this.modelLoaded = true;\n        } catch (err) {\n            this.modelLoaded = false;\n            throw err;\n        }\n    }\n\n    /**\n     * Predict Regions from an HTMLImageElement returning list of IRegion.\n     * @param image ImageObject to be used for prediction\n     * @param predictTag Flag indicates if predict only region bounding box of tag too.\n     * @param xRatio Width compression ratio between the HTMLImageElement and the original image.\n     * @param yRatio Height compression ratio between the HTMLImageElement and the original image.\n     */\n    public async predictImage(image: ImageObject, predictTag: boolean, xRatio: number, yRatio: number)\n        : Promise<IRegion[]> {\n        const regions: IRegion[] = [];\n\n        const predictions = await this.detect(image);\n        predictions.forEach((prediction) => {\n            const left = Math.max(0, prediction.bbox[0] * xRatio);\n            const top = Math.max(0, prediction.bbox[1] * yRatio);\n            const width = Math.max(0, prediction.bbox[2] * xRatio);\n            const height = Math.max(0, prediction.bbox[3] * yRatio);\n\n            regions.push({\n                id: shortid.generate(),\n                type: RegionType.Rectangle,\n                tags: predictTag ? [prediction.class] : [],\n                boundingBox: {\n                    left,\n                    top,\n                    width,\n                    height,\n                },\n                points: [{\n                    x: left,\n                    y: top,\n                },\n                {\n                    x: left + width,\n                    y: top,\n                },\n                {\n                    x: left + width,\n                    y: top + height,\n                },\n                {\n                    x: left,\n                    y: top + height,\n                }],\n            });\n        });\n\n        return regions;\n    }\n\n    /**\n     * Detect objects for an image returning a list of bounding boxes with\n     * associated class and score.\n     *\n     * @param img The image to detect objects from. Can be a tensor or a DOM\n     *     element image, video, or canvas.\n     * @param maxNumBoxes The maximum number of bounding boxes of detected\n     * objects. There can be multiple objects of the same class, but at different\n     * locations. Defaults to 20.\n     *\n     */\n    public async detect(img: ImageObject, maxNumBoxes: number = 20): Promise<DetectedObject[]> {\n        if (this.model) {\n            return this.infer(img, maxNumBoxes);\n        }\n\n        return [];\n    }\n\n    /**\n     * Infers through the model.\n     *\n     * @param img The image to classify. Can be a tensor or a DOM element image,\n     * video, or canvas.\n     * @param maxNumBoxes The maximum number of bounding boxes of detected\n     * objects. There can be multiple objects of the same class, but at different\n     * locations. Defaults to 20.\n     */\n    private async infer(img: ImageObject, maxNumBoxes: number = 20): Promise<DetectedObject[]> {\n        const batched = tf.tidy(() => {\n            if (!(img instanceof tf.Tensor)) {\n                img = tf.browser.fromPixels(img);\n            }\n            // Reshape to a single-element batch so we can pass it to executeAsync.\n            return img.expandDims(0);\n        });\n        const height = batched.shape[1];\n        const width = batched.shape[2];\n\n        // model returns two tensors:\n        // 1. box classification score with shape of [1, 1917, 90]\n        // 2. box location with shape of [1, 1917, 1, 4]\n        // where 1917 is the number of box detectors, 90 is the number of classes.\n        // and 4 is the four coordinates of the box.\n        const result = await this.model.executeAsync(batched) as tf.Tensor[];\n\n        const scores = result[0].dataSync() as Float32Array;\n        const boxes = result[1].dataSync() as Float32Array;\n\n        // clean the webgl tensors\n        batched.dispose();\n        tf.dispose(result);\n\n        const [maxScores, classes] = this.calculateMaxScores(scores, result[0].shape[1], result[0].shape[2]);\n\n        const prevBackend = tf.getBackend();\n        // run post process in cpu\n        tf.setBackend(\"cpu\");\n        const indexTensor = tf.tidy(() => {\n            const boxes2 = tf.tensor2d(boxes, [result[1].shape[1], result[1].shape[3]]);\n            return tf.image.nonMaxSuppression(boxes2, maxScores, maxNumBoxes, 0.5, 0.5);\n        });\n\n        const indexes = indexTensor.dataSync() as Float32Array;\n        indexTensor.dispose();\n\n        // restore previous backend\n        tf.setBackend(prevBackend);\n\n        return this.buildDetectedObjects(width, height, boxes, maxScores, indexes, classes);\n    }\n\n    private buildDetectedObjects(\n        width: number, height: number, boxes: Float32Array, scores: number[],\n        indexes: Float32Array, classes: number[]): DetectedObject[] {\n        const count = indexes.length;\n        const objects: DetectedObject[] = [];\n\n        for (let i = 0; i < count; i++) {\n            const bbox = [];\n            for (let j = 0; j < 4; j++) {\n                bbox[j] = boxes[indexes[i] * 4 + j];\n            }\n            const minY = bbox[0] * height;\n            const minX = bbox[1] * width;\n            const maxY = bbox[2] * height;\n            const maxX = bbox[3] * width;\n            bbox[0] = minX;\n            bbox[1] = minY;\n            bbox[2] = maxX - minX;\n            bbox[3] = maxY - minY;\n            objects.push({\n                bbox: bbox as [number, number, number, number],\n                class: this.getClass(i, indexes, classes),\n                score: scores[indexes[i]],\n            });\n        }\n\n        return objects;\n    }\n\n    private getClass(index: number, indexes: Float32Array, classes: number[]): string {\n        if (this.jsonClasses && index < indexes.length && indexes[index] < classes.length) {\n            const classId = classes[indexes[index]] - 1;\n            const classObject = this.jsonClasses[classId];\n\n            return classObject ? classObject.displayName : strings.tags.warnings.unknownTagName;\n        }\n\n        return \"\";\n    }\n\n    private calculateMaxScores(\n        scores: Float32Array, numBoxes: number,\n        numClasses: number): [number[], number[]] {\n        const maxes = [];\n        const classes = [];\n        for (let i = 0; i < numBoxes; i++) {\n            let max = Number.MIN_VALUE;\n            let index = -1;\n            for (let j = 0; j < numClasses; j++) {\n                if (scores[i * numClasses + j] > max) {\n                    max = scores[i * numClasses + j];\n                    index = j;\n                }\n            }\n            maxes[i] = max;\n            classes[i] = index;\n        }\n        return [maxes, classes];\n    }\n}\n"]},"metadata":{},"sourceType":"module"}