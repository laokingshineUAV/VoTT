{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/home/jw/Documents/code/VoTT/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/jw/Documents/code/VoTT/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar Point2D_1 = require(\"./Point2D\");\n\nvar Rect_1 = require(\"./Rect\");\n/**\r\n * Defines supported region types.\r\n */\n\n\nvar RegionDataType;\n\n(function (RegionDataType) {\n  RegionDataType[\"Point\"] = \"point\";\n  RegionDataType[\"Rect\"] = \"rect\";\n  RegionDataType[\"Polyline\"] = \"polyline\";\n  RegionDataType[\"Polygon\"] = \"polygon\";\n})(RegionDataType = exports.RegionDataType || (exports.RegionDataType = {}));\n/**\r\n * Represents region meta-data, including position, size, points and type\r\n */\n\n\nvar RegionData =\n/*#__PURE__*/\nfunction () {\n  _createClass(RegionData, [{\n    key: \"x\",\n\n    /**\r\n     * Gets the `x`-coordinate of the region\r\n     */\n    get: function get() {\n      return this.corner.x;\n    }\n    /**\r\n     * Sets the `x`-coordinate of the region. *Region points position will be recalculated*\r\n     */\n    ,\n    set: function set(x) {\n      this.move(x, this.y);\n    }\n    /**\r\n     * Gets the `y`-coordinate of the region\r\n     */\n\n  }, {\n    key: \"y\",\n    get: function get() {\n      return this.corner.y;\n    }\n    /**\r\n     * Sets the `y`-coordinate of the region. *Region points position will be recalculated*\r\n     */\n    ,\n    set: function set(y) {\n      this.move(this.x, y);\n    }\n    /**\r\n     * Gets the `width` of the region\r\n     */\n\n  }, {\n    key: \"width\",\n    get: function get() {\n      return this.regionRect.width;\n    }\n    /**\r\n     * Sets the `width` of the region. *Region points position will be recalculated*\r\n     */\n    ,\n    set: function set(width) {\n      this.resize(width, this.height);\n    }\n    /**\r\n     * Gets the `height` of the region\r\n     */\n\n  }, {\n    key: \"height\",\n    get: function get() {\n      return this.regionRect.height;\n    }\n    /**\r\n     * Sets the `height` of the region. *Region points position will be recalculated*\r\n     */\n    ,\n    set: function set(height) {\n      this.resize(this.width, height);\n    }\n    /**\r\n     * Returns the area of the region. *Point has area = 1.0, for other types it is `width * height`*\r\n     */\n\n  }, {\n    key: \"area\",\n    get: function get() {\n      var area;\n\n      if (this.regionType === RegionDataType.Point) {\n        area = 1.0;\n      } else {\n        area = this.regionRect.width * this.regionRect.height;\n      }\n\n      return area;\n    }\n    /**\r\n     * Gets the bounding box size of the region\r\n     */\n\n  }, {\n    key: \"boundRect\",\n    get: function get() {\n      return this.regionRect.copy();\n    }\n    /**\r\n     * Sets the bounding box size of the region. *Region will be resized automatically*\r\n     */\n    ,\n    set: function set(rect) {\n      this.resize(rect.width, rect.height);\n    }\n    /**\r\n     * Gets the array of region points.\r\n     */\n\n  }, {\n    key: \"points\",\n    get: function get() {\n      return this.regionPoints.map(function (p) {\n        return p.copy();\n      });\n    }\n    /**\r\n     * Sets the array of region points. *Region will be resized and repositioned automatically*\r\n     */\n    ,\n    set: function set(points) {\n      this.setPoints(points);\n    }\n    /**\r\n     * Gets the type of the region\r\n     */\n\n  }, {\n    key: \"type\",\n    get: function get() {\n      return this.regionType;\n    }\n    /**\r\n     * Creates a new `RegionData` object\r\n     * @param x - `x`-coordinate of the region\r\n     * @param y - `y`-coordinate of the region\r\n     * @param width - `width` of the region\r\n     * @param height - `height` of the region\r\n     * @param points - Collection of internal region points\r\n     * @param type - `type` of the region from enum `RegionDataType`\r\n     */\n\n  }], [{\n    key: \"BuildPointRegionData\",\n\n    /**\r\n     * Creates a new `RegionData` object with `point`-type at provided `x`, `y` coordinates\r\n     * @param x - `x`-coordinate\r\n     * @param y - `y`-coordinate\r\n     * @returns A new `RegionData` object\r\n     */\n    value: function BuildPointRegionData(x, y) {\n      return new RegionData(x, y, 0, 0, [new Point2D_1.Point2D(x, y)], RegionDataType.Point);\n    }\n    /**\r\n     * Creates a new `RegionData` object with `rect`-type at provided `x`, `y`\r\n     * coordinates and of provided `width` and `height`\r\n     * @param x - `x`-coordinate\r\n     * @param y - `y`-coordinate\r\n     * @param width - `width` of the rect\r\n     * @param height - `height` of the rect\r\n     * @returns A new `RegionData` object\r\n     */\n\n  }, {\n    key: \"BuildRectRegionData\",\n    value: function BuildRectRegionData(x, y, width, height) {\n      return new RegionData(x, y, width, height, [new Point2D_1.Point2D(x, y), new Point2D_1.Point2D(x + width, y), new Point2D_1.Point2D(x + width, y + height), new Point2D_1.Point2D(x, y + height)], RegionDataType.Rect);\n    }\n    /**\r\n     * Creates a new `RegionData` object based on extracting specific properties from any provided object\r\n     * @param data - An `IRegionData` object with `x`, `y`, `width`, `height`, `points` and `type` properties\r\n     * @returns A new `RegionData` object\r\n     */\n\n  }, {\n    key: \"BuildFromJson\",\n    value: function BuildFromJson(data) {\n      return new RegionData(data.x, data.y, data.width, data.height, data.points.map(function (p) {\n        return new Point2D_1.Point2D(p.x, p.y);\n      }), data.type);\n    }\n  }]);\n\n  function RegionData(x, y, width, height, points, type) {\n    _classCallCheck(this, RegionData);\n\n    this.corner = new Point2D_1.Point2D(x, y);\n    this.regionRect = new Rect_1.Rect(width, height);\n    this.regionPoints = points !== undefined && points !== null ? points : new Array();\n    this.regionType = type !== undefined ? type : RegionDataType.Point;\n  }\n\n  _createClass(RegionData, [{\n    key: \"move\",\n    value: function move(arg1, arg2) {\n      var oldx = this.x;\n      var oldy = this.y;\n      this.corner.move(arg1, arg2);\n      var dx = this.x - oldx;\n      var dy = this.y - oldy;\n      this.regionPoints.forEach(function (p) {\n        p.shift(dx, dy);\n      });\n    }\n    /**\r\n     * Resizes regions to specified dimensions\r\n     * @param width - New `width` of the region\r\n     * @param height - New `height` of the region\r\n     */\n\n  }, {\n    key: \"resize\",\n    value: function resize(width, height) {\n      var _this = this;\n\n      var sx = width / this.width;\n      var sy = height / this.height;\n      this.regionRect.resize(width, height);\n      this.regionPoints.forEach(function (p) {\n        var px = (p.x - _this.x) * sx + _this.x;\n        var py = (p.y - _this.y) * sy + _this.y;\n        p.move(px, py);\n      });\n    }\n    /**\r\n     * Changes the `point` at specified `index`\r\n     * @param point - New `point` value\r\n     * @param index - `index` of the point in internal collection\r\n     */\n\n  }, {\n    key: \"setPoint\",\n    value: function setPoint(point, index) {\n      if (index >= 0 && index < this.regionPoints.length) {\n        this.regionPoints[index] = new Point2D_1.Point2D(point);\n      } // Update region position and size\n\n\n      var xmin = Number.MAX_VALUE;\n      var xmax = 0;\n      var ymin = Number.MAX_VALUE;\n      var ymax = 0;\n      this.regionPoints.forEach(function (point) {\n        if (point.x > xmax) {\n          xmax = point.x;\n        }\n\n        if (point.x < xmin) {\n          xmin = point.x;\n        }\n\n        if (point.y > ymax) {\n          ymax = point.y;\n        }\n\n        if (point.y < ymin) {\n          ymin = point.y;\n        }\n      });\n      this.corner.move(xmin, ymin);\n      this.regionRect.resize(xmax - xmin, ymax - ymin);\n    }\n    /**\r\n     * Updates the collection of internal points\r\n     * @param points - `IPoint2D[]` collection for the region to serve as the source for the\r\n     * internal *copy* in the `points` collection\r\n     */\n\n  }, {\n    key: \"setPoints\",\n    value: function setPoints(points) {\n      var xmin = Number.MAX_VALUE;\n      var xmax = 0;\n      var ymin = Number.MAX_VALUE;\n      var ymax = 0; // Update region position and size\n\n      points.forEach(function (point) {\n        if (point.x > xmax) {\n          xmax = point.x;\n        }\n\n        if (point.x < xmin) {\n          xmin = point.x;\n        }\n\n        if (point.y > ymax) {\n          ymax = point.y;\n        }\n\n        if (point.y < ymin) {\n          ymin = point.y;\n        }\n      });\n      this.regionPoints = points.map(function (p) {\n        return new Point2D_1.Point2D(p);\n      });\n      this.corner.move(xmin, ymin);\n      this.regionRect.resize(xmax - xmin, ymax - ymin);\n    }\n    /**\r\n     * Inits this region properties from another `IRegionData` object\r\n     * @param regionData - An `IRegionData` object to serve as the source for the property values\r\n     */\n\n  }, {\n    key: \"initFrom\",\n    value: function initFrom(regionData) {\n      this.corner = new Point2D_1.Point2D(regionData.x, regionData.y);\n      this.regionRect = new Rect_1.Rect(regionData.width, regionData.height);\n      this.regionPoints = regionData.points.map(function (p) {\n        return new Point2D_1.Point2D(p.x, p.y);\n      });\n    }\n    /**\r\n     * Returns a new `RegionData` object with all coordinates and dimensions bounded to specified box\r\n     * @param rect - The `IRect` box, which `width` and `height` will be used for bounding\r\n     * @returns A new `RegionData` object\r\n     */\n\n  }, {\n    key: \"boundToRect\",\n    value: function boundToRect(rect) {\n      var brCorner = new Point2D_1.Point2D(this.x + this.width, this.y + this.height).boundToRect(rect);\n      var tlCorner = this.corner.boundToRect(rect);\n      var width = brCorner.x - tlCorner.x;\n      var height = brCorner.y - tlCorner.y;\n      return new RegionData(tlCorner.x, tlCorner.y, width, height, this.regionPoints.map(function (p) {\n        return p.boundToRect(rect);\n      }), this.regionType);\n    }\n  }, {\n    key: \"scale\",\n    value: function scale(f1, f2) {\n      var xf = f1;\n      var yf = f2 !== undefined ? f2 : f1;\n      this.corner = new Point2D_1.Point2D(this.x * xf, this.y * yf);\n      this.regionRect = new Rect_1.Rect(this.width * xf, this.height * yf);\n      this.regionPoints = this.regionPoints.map(function (p) {\n        return new Point2D_1.Point2D(p.x * xf, p.y * yf);\n      });\n    }\n    /**\r\n     * Creates a copy of this region data\r\n     * @returns A new `RegionData` object with copied properties\r\n     */\n\n  }, {\n    key: \"copy\",\n    value: function copy() {\n      return new RegionData(this.x, this.y, this.width, this.height, this.regionPoints.map(function (p) {\n        return p.copy();\n      }), this.regionType);\n    }\n    /**\r\n     * Returns a string representation of the region in the format\r\n     * `\"{x, y} x [width, height]: {{x1, y1}, ..., {xn, yn}}\"`.\r\n     * @returns A string representation of the rect\r\n     */\n\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return \"\".concat(this.corner.toString(), \" x \").concat(this.boundRect.toString(), \": {\").concat(this.regionPoints.toString(), \"}\");\n    }\n    /**\r\n     * Returns a JSON representation of the region\r\n     * @returns An `IRegionData` object with properties only.\r\n     */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return {\n        x: this.x,\n        y: this.y,\n        width: this.width,\n        height: this.height,\n        points: this.regionPoints.map(function (point) {\n          return {\n            x: point.x,\n            y: point.y\n          };\n        }),\n        type: this.regionType\n      };\n    }\n  }]);\n\n  return RegionData;\n}();\n\nexports.RegionData = RegionData;","map":null,"metadata":{},"sourceType":"script"}