{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"/home/jw/Documents/code/VoTT/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _classCallCheck = require(\"/home/jw/Documents/code/VoTT/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/jw/Documents/code/VoTT/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"/home/jw/Documents/code/VoTT/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/home/jw/Documents/code/VoTT/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _get = require(\"/home/jw/Documents/code/VoTT/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/get\");\n\nvar _inherits = require(\"/home/jw/Documents/code/VoTT/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar Point2D_1 = require(\"../../Core/Point2D\");\n\nvar IRegionCallbacks_1 = require(\"../../Interface/IRegionCallbacks\");\n\nvar AnchorsComponent_1 = require(\"../Component/AnchorsComponent\");\n/**\r\n * `AnchorsComponent` for the `RectRegion` class.\r\n * @todo Current implementations of bones reuses existing aprroach with anchor index\r\n * by using negative indexes and manually correcting them to actual indexes.\r\n * It seems like it should be refactored some how.\r\n */\n\n\nvar AnchorsElement =\n/*#__PURE__*/\nfunction (_AnchorsComponent_1$A) {\n  _inherits(AnchorsElement, _AnchorsComponent_1$A);\n\n  /**\r\n   * Creates a new `AnchorsElement` object.\r\n   * @param paper - The `Snap.Paper` object to draw on.\r\n   * @param paperRect - The parent bounding box for created component.\r\n   * @param regionData - The `RegionData` object shared across components. Used also for initial setup.\r\n   * @param callbacks - The external callbacks collection.\r\n   */\n  function AnchorsElement(paper) {\n    var paperRect = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    var regionData = arguments.length > 2 ? arguments[2] : undefined;\n    var callbacks = arguments.length > 3 ? arguments[3] : undefined;\n\n    _classCallCheck(this, AnchorsElement);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(AnchorsElement).call(this, paper, paperRect, regionData, callbacks));\n  }\n  /**\r\n   * Redraws the visual on the component.\r\n   */\n\n\n  _createClass(AnchorsElement, [{\n    key: \"redraw\",\n    value: function redraw() {\n      var _this = this;\n\n      _get(_getPrototypeOf(AnchorsElement.prototype), \"redraw\", this).call(this);\n\n      var _ref = [this.regionData.x, this.regionData.y, this.regionData.width, this.regionData.height],\n          x = _ref[0],\n          y = _ref[1],\n          width = _ref[2],\n          height = _ref[3];\n\n      var _this$anchorBones = _slicedToArray(this.anchorBones, 4),\n          tBone = _this$anchorBones[0],\n          rBone = _this$anchorBones[1],\n          bBone = _this$anchorBones[2],\n          lBone = _this$anchorBones[3];\n\n      window.requestAnimationFrame(function () {\n        tBone.attr({\n          x: x,\n          y: y - _this.boneThickness / 2,\n          width: width,\n          height: _this.boneThickness\n        });\n        rBone.attr({\n          x: x + width - _this.boneThickness / 2,\n          y: y,\n          width: _this.boneThickness,\n          height: height\n        });\n        bBone.attr({\n          x: x,\n          y: y + height - _this.boneThickness / 2,\n          width: width,\n          height: _this.boneThickness\n        });\n        lBone.attr({\n          x: x - _this.boneThickness / 2,\n          y: y,\n          width: _this.boneThickness,\n          height: height\n        });\n      });\n    }\n    /**\r\n     * Creates a collection on anchors.\r\n     */\n\n  }, {\n    key: \"buildAnchors\",\n    value: function buildAnchors() {\n      this.buildBoneAnchors();\n      this.buildPointAnchors();\n    }\n    /**\r\n     * Creates collection of anchor points.\r\n     */\n\n  }, {\n    key: \"buildPointAnchors\",\n    value: function buildPointAnchors() {\n      var _this2 = this;\n\n      this.anchorPointStyles = [\"TL\", \"TR\", \"BR\", \"BL\"];\n      this.regionData.points.forEach(function (point, index) {\n        var anchor = _this2.createAnchor(_this2.paper, point.x, point.y, _this2.anchorPointStyles[index]);\n\n        _this2.anchors.push(anchor);\n\n        _this2.anchorsNode.add(anchor);\n\n        _this2.subscribeAnchorToEvents(anchor, index);\n      });\n    }\n    /**\r\n     * Creates collection of anchor bones.\r\n     */\n\n  }, {\n    key: \"buildBoneAnchors\",\n    value: function buildBoneAnchors() {\n      var _this$anchorBones2,\n          _this3 = this;\n\n      this.anchorBoneStyles = [\"T\", \"R\", \"B\", \"L\"];\n      this.anchorBones = [];\n      this.boneThickness = AnchorsComponent_1.AnchorsComponent.DEFAULT_GHOST_ANCHOR_RADIUS;\n      var _ref2 = [this.regionData.x, this.regionData.y, this.regionData.width, this.regionData.height],\n          x = _ref2[0],\n          y = _ref2[1],\n          w = _ref2[2],\n          h = _ref2[3];\n      var tBone = this.createAnchorBone(this.paper, x, y, w, 0, \"T\", this.boneThickness);\n      var rBone = this.createAnchorBone(this.paper, x + w, y, 0, h, \"R\", this.boneThickness);\n      var bBone = this.createAnchorBone(this.paper, x, y + h, w, 0, \"B\", this.boneThickness);\n      var lBone = this.createAnchorBone(this.paper, x, y, 0, h, \"L\", this.boneThickness);\n      var bones = [tBone, rBone, bBone, lBone];\n\n      (_this$anchorBones2 = this.anchorBones).push.apply(_this$anchorBones2, bones);\n\n      bones.forEach(function (bone, index) {\n        _this3.anchorsNode.add(bone); // Using already existing infrastructure for indexes\n\n\n        _this3.subscribeAnchorBoneToEvents(bone, -(index + 1));\n      });\n    }\n    /**\r\n     * Helper function to create a new anchor bone.\r\n     * @param paper - The `Snap.Paper` object to draw on.\r\n     * @param x - The `x`-coordinate of the acnhor bone.\r\n     * @param y - The `y`-coordinate of the anchor bone.\r\n     * @param width - The `width` of the anchor bone.\r\n     * @param height - The `height` of the anchor bone.\r\n     * @param style - Additional css style class to be applied.\r\n     * @param thickness - The `thickness` of the bone (activation area).\r\n     */\n\n  }, {\n    key: \"createAnchorBone\",\n    value: function createAnchorBone(paper, x, y, width, height, style) {\n      var thickness = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : AnchorsComponent_1.AnchorsComponent.DEFAULT_GHOST_ANCHOR_RADIUS;\n      var bone;\n\n      if (width === 0) {\n        bone = paper.rect(x - thickness / 2, y, thickness, height);\n      } else if (height === 0) {\n        bone = paper.rect(x, y - thickness / 2, width, thickness);\n      } else {\n        throw Error(\"Rect bones that are neither vertical or horizontal are not supported.\");\n        return null;\n      }\n\n      bone.addClass(\"anchorBoneStyle\");\n\n      if (style !== undefined && style !== \"\") {\n        bone.addClass(style);\n      }\n\n      return bone;\n    }\n    /**\r\n     * Updates the `regionData` based on the new ghost anchor location. Should be redefined in child classes.\r\n     * @param p - The new ghost anchor location.\r\n     */\n\n  }, {\n    key: \"updateRegion\",\n    value: function updateRegion(p) {\n      var x1 = p.x;\n      var y1 = p.y;\n      var x2;\n      var y2;\n      var flipX = false;\n      var flipY = false;\n      var activeAnchor = this.getActiveAnchor();\n\n      switch (activeAnchor) {\n        case \"TL\":\n          {\n            x2 = this.x + this.width;\n            y2 = this.y + this.height;\n            flipX = x2 < x1;\n            flipY = y2 < y1;\n            break;\n          }\n\n        case \"TR\":\n          {\n            x2 = this.x;\n            y2 = this.y + this.height;\n            flipX = x1 < x2;\n            flipY = y2 < y1;\n            break;\n          }\n\n        case \"BL\":\n          {\n            y2 = this.y;\n            x2 = this.x + this.width;\n            flipX = x2 < x1;\n            flipY = y1 < y2;\n            break;\n          }\n\n        case \"BR\":\n          {\n            x2 = this.x;\n            y2 = this.y;\n            flipX = x1 < x2;\n            flipY = y1 < y2;\n            break;\n          }\n\n        case \"T\":\n          {\n            x1 = this.x;\n            x2 = this.x + this.width;\n            y2 = this.y + this.height;\n            flipY = y1 > y2;\n            break;\n          }\n\n        case \"R\":\n          {\n            x2 = this.x;\n            y1 = this.y;\n            y2 = this.y + this.height;\n            flipX = x2 > x1;\n            break;\n          }\n\n        case \"B\":\n          {\n            x1 = this.x;\n            x2 = this.x + this.width;\n            y2 = this.y;\n            flipY = y1 < y2;\n            break;\n          }\n\n        case \"L\":\n          {\n            x2 = this.x + this.width;\n            y1 = this.y;\n            y2 = this.y + this.height;\n            flipX = x1 > x2;\n            break;\n          }\n      }\n\n      var newAA = \"\";\n\n      if (activeAnchor !== \"\" && activeAnchor.length === 2) {\n        newAA += activeAnchor[0] === \"T\" ? flipY ? \"B\" : \"T\" : flipY ? \"T\" : \"B\";\n        newAA += activeAnchor[1] === \"L\" ? flipX ? \"R\" : \"L\" : flipX ? \"L\" : \"R\";\n      }\n\n      if (activeAnchor !== \"\" && activeAnchor.length === 1) {\n        if (flipX) {\n          newAA = activeAnchor === \"R\" ? \"L\" : \"R\";\n        } else if (flipY) {\n          newAA = activeAnchor === \"T\" ? \"B\" : \"T\";\n        } else {\n          newAA = activeAnchor;\n        }\n      }\n\n      if (activeAnchor !== newAA) {\n        this.ghostAnchor.removeClass(activeAnchor);\n\n        if (newAA.length === 2) {\n          this.activeAnchorIndex = this.anchorPointStyles.indexOf(newAA);\n        } else {\n          this.activeAnchorIndex = -(this.anchorBoneStyles.indexOf(newAA) + 1);\n        }\n\n        activeAnchor = newAA;\n        this.ghostAnchor.addClass(newAA);\n      }\n\n      var p1 = new Point2D_1.Point2D(Math.min(x1, x2), Math.min(y1, y2)).boundToRect(this.paperRect);\n      var p2 = new Point2D_1.Point2D(Math.max(x1, x2), Math.max(y1, y2)).boundToRect(this.paperRect);\n      var rd = this.regionData.copy();\n      rd.setPoints([p1, new Point2D_1.Point2D(p2.x, p1.y), p2, new Point2D_1.Point2D(p1.x, p2.y)]);\n      this.onChange(this, rd, IRegionCallbacks_1.ChangeEventType.MOVING);\n    }\n    /**\r\n     * Callback for the pointerenter event for the ghost anchor.\r\n     * @param e - PointerEvent object.\r\n     */\n\n  }, {\n    key: \"onGhostPointerEnter\",\n    value: function onGhostPointerEnter(e) {\n      this.ghostAnchor.addClass(this.getActiveAnchor());\n\n      _get(_getPrototypeOf(AnchorsElement.prototype), \"onGhostPointerEnter\", this).call(this, e);\n    }\n    /**\r\n     * Callback for the pointerleave event for the ghost anchor.\r\n     * @param e - PointerEvent object.\r\n     */\n\n  }, {\n    key: \"onGhostPointerLeave\",\n    value: function onGhostPointerLeave(e) {\n      this.ghostAnchor.removeClass(this.getActiveAnchor());\n\n      _get(_getPrototypeOf(AnchorsElement.prototype), \"onGhostPointerLeave\", this).call(this, e);\n    }\n    /**\r\n     * Helper function to subscribe anchor to activation event.\r\n     * @param bone - The anchor bone for wire up.\r\n     * @param index - The index of the anchor used to define which one is active.\r\n     */\n\n  }, {\n    key: \"subscribeAnchorBoneToEvents\",\n    value: function subscribeAnchorBoneToEvents(bone, index) {\n      var _this4 = this;\n\n      bone.node.addEventListener(\"pointerenter\", function (e) {\n        if (!_this4.isFrozen) {\n          // Set drag origin point to current anchor\n          _this4.dragOrigin = new Point2D_1.Point2D(e.offsetX, e.offsetY);\n          _this4.activeAnchorIndex = index; // Move ghost anchor to current anchor position\n\n          window.requestAnimationFrame(function () {\n            _this4.ghostAnchor.attr({\n              cx: _this4.dragOrigin.x,\n              cy: _this4.dragOrigin.y,\n              display: \"block\"\n            });\n          });\n\n          _this4.onManipulationBegin();\n        }\n      });\n    }\n    /**\r\n     * Internal helper function to get active anchor.\r\n     */\n\n  }, {\n    key: \"getActiveAnchor\",\n    value: function getActiveAnchor() {\n      if (this.activeAnchorIndex >= 0) {\n        // anchor point is activeted\n        return this.anchorPointStyles[this.activeAnchorIndex];\n      } else {\n        // anchor bone is activeted, indexes are negative starting -1\n        return this.anchorBoneStyles[-this.activeAnchorIndex - 1];\n      }\n    }\n  }]);\n\n  return AnchorsElement;\n}(AnchorsComponent_1.AnchorsComponent);\n\nexports.AnchorsElement = AnchorsElement;","map":null,"metadata":{},"sourceType":"script"}