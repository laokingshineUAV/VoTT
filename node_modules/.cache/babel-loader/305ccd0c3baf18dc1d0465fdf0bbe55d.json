{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/home/jw/Documents/code/VoTT/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/jw/Documents/code/VoTT/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"/home/jw/Documents/code/VoTT/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/home/jw/Documents/code/VoTT/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/home/jw/Documents/code/VoTT/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar Point2D_1 = require(\"../../Core/Point2D\");\n\nvar IRegionCallbacks_1 = require(\"../../Interface/IRegionCallbacks\");\n\nvar AnchorsComponent_1 = require(\"../Component/AnchorsComponent\");\n/**\r\n * `AnchorsComponent` for the `PolygonRegion` class.\r\n */\n\n\nvar AnchorsElement =\n/*#__PURE__*/\nfunction (_AnchorsComponent_1$A) {\n  _inherits(AnchorsElement, _AnchorsComponent_1$A);\n\n  /**\r\n   * Creates a new `AnchorsElement` object.\r\n   * @param paper - The `Snap.Paper` object to draw on.\r\n   * @param paperRect - The parent bounding box for created component.\r\n   * @param regionData - The `RegionData` object shared across components. Used also for initial setup.\r\n   * @param callbacks - The external callbacks collection.\r\n   */\n  function AnchorsElement(paper) {\n    var _this;\n\n    var paperRect = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    var regionData = arguments.length > 2 ? arguments[2] : undefined;\n    var callbacks = arguments.length > 3 ? arguments[3] : undefined;\n\n    _classCallCheck(this, AnchorsElement);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(AnchorsElement).call(this, paper, paperRect, regionData, callbacks));\n    /**\r\n     * Internal flag to delete a point on pointer up event.\r\n     */\n\n    _this.deleteOnPointerUp = false;\n    /**\r\n     * Internal flat to add a point on pointer up event.\r\n     */\n\n    _this.addOnPointerUp = false;\n    _this.anchorsLength = regionData.points.length;\n    return _this;\n  }\n  /**\r\n   * Redraws the componnent.\r\n   */\n\n\n  _createClass(AnchorsElement, [{\n    key: \"redraw\",\n    value: function redraw() {\n      var _this2 = this;\n\n      if (this.regionData.points !== null && this.regionData.points.length > 0) {\n        var points = this.regionData.points; // rebuild anchors\n\n        if (this.anchorsLength !== points.length) {\n          window.requestAnimationFrame(function () {\n            _this2.anchors.forEach(function (anchor) {\n              anchor.remove();\n            });\n\n            _this2.anchors = [];\n\n            _this2.buildPointAnchors();\n          });\n          this.anchorsLength = points.length;\n        } else {\n          window.requestAnimationFrame(function () {\n            _this2.regionData.points.forEach(function (p, index) {\n              _this2.anchors[index].attr({\n                cx: p.x,\n                cy: p.y\n              });\n            });\n          });\n        }\n\n        var pointsData = [];\n        this.regionData.points.forEach(function (p) {\n          pointsData.push(p.x, p.y);\n        });\n        this.anchorsPolyline.attr({\n          points: pointsData.toString()\n        });\n      }\n    }\n    /**\r\n     * Creates a collection on anchors.\r\n     */\n\n  }, {\n    key: \"buildAnchors\",\n    value: function buildAnchors() {\n      this.buildPolylineAnchors();\n      this.buildPointAnchors();\n    }\n    /**\r\n     * Creates a collection of anchor points.\r\n     */\n\n  }, {\n    key: \"buildPolylineAnchors\",\n    value: function buildPolylineAnchors() {\n      var pointsData = [];\n      this.regionData.points.forEach(function (p) {\n        pointsData.push(p.x, p.y);\n      });\n      this.anchorsPolyline = this.paper.polyline(pointsData);\n      this.anchorsPolyline.addClass(\"anchorLineStyle\");\n      this.subscribeLineToEvents(this.anchorsPolyline);\n      this.anchorsNode.add(this.anchorsPolyline);\n    }\n    /**\r\n     * Subscribe an anchor to events.\r\n     * @param anchor - The anchor to wire up with events.\r\n     */\n\n  }, {\n    key: \"subscribeLineToEvents\",\n    value: function subscribeLineToEvents(anchor) {\n      var _this3 = this;\n\n      anchor.node.addEventListener(\"pointermove\", function (e) {\n        if (!_this3.isFrozen) {\n          if (e.ctrlKey) {\n            _this3.dragOrigin = new Point2D_1.Point2D(e.offsetX, e.offsetY);\n            _this3.activeAnchorIndex = -1;\n            _this3.addOnPointerUp = true;\n            window.requestAnimationFrame(function () {\n              _this3.ghostAnchor.attr({\n                cx: _this3.dragOrigin.x,\n                cy: _this3.dragOrigin.y,\n                display: \"block\"\n              });\n            });\n          } else {\n            _this3.addOnPointerUp = false;\n          }\n\n          _this3.onManipulationBegin();\n        }\n      }, false);\n    }\n    /**\r\n     * Updated the `regionData` based on the new ghost anchor location. Should be redefined in child classes.\r\n     * @param p - The new ghost anchor location.\r\n     */\n\n  }, {\n    key: \"updateRegion\",\n    value: function updateRegion(p) {\n      var rd = this.regionData.copy();\n\n      if (this.activeAnchorIndex >= 0 && this.activeAnchorIndex < this.regionData.points.length) {\n        rd.setPoint(p, this.activeAnchorIndex);\n      }\n\n      this.onChange(this, rd, IRegionCallbacks_1.ChangeEventType.MOVING);\n    }\n    /**\r\n     * Callback for the pointerenter event for the ghost anchor.\r\n     * @param e - PointerEvent object.\r\n     */\n\n  }, {\n    key: \"onGhostPointerEnter\",\n    value: function onGhostPointerEnter(e) {\n      if (e.ctrlKey) {\n        if (this.addOnPointerUp && this.activeAnchorIndex < 0) {\n          this.ghostAnchor.addClass(\"add\");\n        } else if (this.regionData.points.length > 2) {\n          this.ghostAnchor.addClass(\"delete\");\n          this.deleteOnPointerUp = true;\n          this.addOnPointerUp = false;\n        }\n      } else {\n        this.ghostAnchor.removeClass(\"delete\");\n        this.ghostAnchor.removeClass(\"add\");\n        this.deleteOnPointerUp = false;\n      }\n\n      this.ghostAnchor.drag(this.anchorDragMove.bind(this), this.anchorDragBegin.bind(this), this.anchorDragEnd.bind(this));\n      this.onManipulationBegin();\n    }\n    /**\r\n     * Callback for the pointermove event for the ghost anchor.\r\n     * @param e - PointerEvent object.\r\n     */\n\n  }, {\n    key: \"onGhostPointerMove\",\n    value: function onGhostPointerMove(e) {\n      var _this4 = this;\n\n      if (e.ctrlKey) {\n        var p = new Point2D_1.Point2D(e.offsetX, e.offsetY);\n        var dist = Number.MAX_VALUE;\n        var nearestPoint = null;\n        var index = -1;\n        this.regionData.points.forEach(function (point, i) {\n          var d = p.squareDistanceToPoint(point);\n\n          if (d < dist) {\n            dist = d;\n            nearestPoint = point;\n            index = i;\n          }\n        });\n        var swapToDelete = dist < AnchorsElement.ANCHOR_POINT_LINE_SWITCH_THRESHOLD;\n\n        if (this.addOnPointerUp && this.activeAnchorIndex < 0 && !swapToDelete) {\n          this.ghostAnchor.addClass(\"add\");\n          window.requestAnimationFrame(function () {\n            _this4.ghostAnchor.attr({\n              cx: p.x,\n              cy: p.y\n            });\n          });\n        } else if (this.regionData.points.length > 2 || swapToDelete) {\n          this.ghostAnchor.removeClass(\"add\");\n          this.ghostAnchor.addClass(\"delete\");\n          this.activeAnchorIndex = index;\n          window.requestAnimationFrame(function () {\n            _this4.ghostAnchor.attr({\n              cx: nearestPoint.x,\n              cy: nearestPoint.y\n            });\n          });\n          this.deleteOnPointerUp = true;\n          this.addOnPointerUp = false;\n        }\n      } else {\n        this.ghostAnchor.removeClass(\"delete\");\n        this.ghostAnchor.removeClass(\"add\");\n        this.deleteOnPointerUp = false;\n        this.addOnPointerUp = false;\n      }\n    }\n    /**\r\n     * Callback for the pointerup event for the ghost anchor.\r\n     * @param e - PointerEvent object.\r\n     */\n\n  }, {\n    key: \"onGhostPointerUp\",\n    value: function onGhostPointerUp(e) {\n      this.ghostAnchor.node.releasePointerCapture(e.pointerId);\n      var rd = this.regionData.copy();\n\n      if (this.deleteOnPointerUp) {\n        if (this.activeAnchorIndex >= 0 && this.activeAnchorIndex < this.regionData.points.length) {\n          var points = rd.points;\n          points.splice(this.activeAnchorIndex, 1);\n          rd.setPoints(points);\n        }\n\n        this.deleteOnPointerUp = false;\n        this.addOnPointerUp = false;\n        this.ghostAnchor.removeClass(\"delete\");\n        this.ghostAnchor.removeClass(\"add\");\n      } else if (this.addOnPointerUp) {\n        var point = new Point2D_1.Point2D(e.offsetX, e.offsetY);\n        var _points = rd.points; // Find the nearest segment of polyline\n\n        var index = 0;\n        var distance = Number.MAX_VALUE;\n\n        for (var i = 0; i < _points.length - 1; i++) {\n          var d = this.dragOrigin.squareDistanceToLine(_points[i], _points[i + 1]);\n\n          if (d < distance) {\n            index = i;\n            distance = d;\n          }\n        }\n\n        _points.splice(index + 1, 0, point);\n\n        rd.setPoints(_points);\n        this.deleteOnPointerUp = false;\n        this.addOnPointerUp = false;\n        this.ghostAnchor.addClass(\"delete\");\n      }\n\n      this.onChange(this, rd, IRegionCallbacks_1.ChangeEventType.MOVEEND);\n    }\n  }]);\n\n  return AnchorsElement;\n}(AnchorsComponent_1.AnchorsComponent);\n/**\r\n * Default threshold distance to define whether ctrl-pointer click is on point or line.\r\n */\n\n\nAnchorsElement.ANCHOR_POINT_LINE_SWITCH_THRESHOLD = 5;\nexports.AnchorsElement = AnchorsElement;","map":null,"metadata":{},"sourceType":"script"}