{"ast":null,"code":"import * as tslib_1 from \"tslib\";\nimport { BlobURL } from \"./BlobURL\";\nimport { BlockBlob } from \"./generated/lib/operations\";\nimport { rangeToString } from \"./IRange\";\nimport { URLConstants } from \"./utils/constants\";\nimport { appendToURLPath, setURLParameter } from \"./utils/utils.common\";\n/**\n * BlockBlobURL defines a set of operations applicable to block blobs.\n *\n * @export\n * @class BlockBlobURL\n * @extends {StorageURL}\n */\n\nvar BlockBlobURL =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(BlockBlobURL, _super);\n  /**\n   * Creates an instance of BlockBlobURL.\n   * This method accepts an encoded URL or non-encoded URL pointing to a block blob.\n   * Encoded URL string will NOT be escaped twice, only special characters in URL path will be escaped.\n   * If a blob name includes ? or %, blob name must be encoded in the URL.\n   *\n   * @param {string} url A URL string pointing to Azure Storage block blob, such as\n   *                     \"https://myaccount.blob.core.windows.net/mycontainer/blockblob\". You can\n   *                     append a SAS if using AnonymousCredential, such as\n   *                     \"https://myaccount.blob.core.windows.net/mycontainer/blockblob?sasString\".\n   *                     This method accepts an encoded URL or non-encoded URL pointing to a blob.\n   *                     Encoded URL string will NOT be escaped twice, only special characters in URL path will be escaped.\n   *                     However, if a blob name includes ? or %, blob name must be encoded in the URL.\n   *                     Such as a blob named \"my?blob%\", the URL should be \"https://myaccount.blob.core.windows.net/mycontainer/my%3Fblob%25\".\n   * @param {Pipeline} pipeline Call StorageURL.newPipeline() to create a default\n   *                            pipeline, or provide a customized pipeline.\n   * @memberof BlockBlobURL\n   */\n\n\n  function BlockBlobURL(url, pipeline) {\n    var _this = _super.call(this, url, pipeline) || this;\n\n    _this.blockBlobContext = new BlockBlob(_this.storageClientContext);\n    return _this;\n  }\n  /**\n   * Creates a BlockBlobURL object from ContainerURL instance.\n   *\n   * @static\n   * @param {ContainerURL} containerURL A ContainerURL object\n   * @param {string} blobName A block blob name\n   * @returns {BlockBlobURL}\n   * @memberof BlockBlobURL\n   */\n\n\n  BlockBlobURL.fromContainerURL = function (containerURL, blobName) {\n    return new BlockBlobURL(appendToURLPath(containerURL.url, encodeURIComponent(blobName)), containerURL.pipeline);\n  };\n  /**\n   * Creates a BlockBlobURL object from BlobURL instance.\n   *\n   * @static\n   * @param {BlobURL} blobURL\n   * @returns {BlockBlobURL}\n   * @memberof BlockBlobURL\n   */\n\n\n  BlockBlobURL.fromBlobURL = function (blobURL) {\n    return new BlockBlobURL(blobURL.url, blobURL.pipeline);\n  };\n  /**\n   * Creates a new BlockBlobURL object identical to the source but with the\n   * specified request policy pipeline.\n   *\n   * @param {Pipeline} pipeline\n   * @returns {BlockBlobURL}\n   * @memberof BlockBlobURL\n   */\n\n\n  BlockBlobURL.prototype.withPipeline = function (pipeline) {\n    return new BlockBlobURL(this.url, pipeline);\n  };\n  /**\n   * Creates a new BlockBlobURL object identical to the source but with the\n   * specified snapshot timestamp.\n   * Provide \"\" will remove the snapshot and return a URL to the base blob.\n   *\n   * @param {string} snapshot\n   * @returns {BlockBlobURL}\n   * @memberof BlockBlobURL\n   */\n\n\n  BlockBlobURL.prototype.withSnapshot = function (snapshot) {\n    return new BlockBlobURL(setURLParameter(this.url, URLConstants.Parameters.SNAPSHOT, snapshot.length === 0 ? undefined : snapshot), this.pipeline);\n  };\n  /**\n   * Creates a new block blob, or updates the content of an existing block blob.\n   * Updating an existing block blob overwrites any existing metadata on the blob.\n   * Partial updates are not supported; the content of the existing blob is\n   * overwritten with the new content. To perform a partial update of a block blob's,\n   * use stageBlock and commitBlockList.\n   *\n   * This is a non-parallel uploading method, please use uploadFileToBlockBlob(),\n   * uploadStreamToBlockBlob() or uploadBrowserDataToBlockBlob() for better performance\n   * with concurrency uploading.\n   *\n   * @see https://docs.microsoft.com/rest/api/storageservices/put-blob\n   *\n   * @param {Aborter} aborter Create a new Aborter instance with Aborter.none or Aborter.timeout(),\n   *                          goto documents of Aborter for more examples about request cancellation\n   * @param {HttpRequestBody} body\n   * @param {number} contentLength\n   * @param {IBlockBlobUploadOptions} [options]\n   * @returns {Promise<Models.BlockBlobUploadResponse>}\n   * @memberof BlockBlobURL\n   */\n\n\n  BlockBlobURL.prototype.upload = function (aborter, body, contentLength, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    return tslib_1.__awaiter(this, void 0, void 0, function () {\n      return tslib_1.__generator(this, function (_a) {\n        options.accessConditions = options.accessConditions || {};\n        return [2\n        /*return*/\n        , this.blockBlobContext.upload(body, contentLength, {\n          abortSignal: aborter,\n          blobHTTPHeaders: options.blobHTTPHeaders,\n          leaseAccessConditions: options.accessConditions.leaseAccessConditions,\n          metadata: options.metadata,\n          modifiedAccessConditions: options.accessConditions.modifiedAccessConditions,\n          onUploadProgress: options.progress\n        })];\n      });\n    });\n  };\n  /**\n   * Uploads the specified block to the block blob's \"staging area\" to be later\n   * committed by a call to commitBlockList.\n   * @see https://docs.microsoft.com/rest/api/storageservices/put-block\n   *\n   * @param {Aborter} aborter Create a new Aborter instance with Aborter.none or Aborter.timeout(),\n   *                          goto documents of Aborter for more examples about request cancellation\n   * @param {string} blockId A 64-byte value that is base64-encoded\n   * @param {HttpRequestBody} body\n   * @param {number} contentLength\n   * @param {IBlockBlobStageBlockOptions} [options]\n   * @returns {Promise<Models.BlockBlobStageBlockResponse>}\n   * @memberof BlockBlobURL\n   */\n\n\n  BlockBlobURL.prototype.stageBlock = function (aborter, blockId, body, contentLength, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    return tslib_1.__awaiter(this, void 0, void 0, function () {\n      return tslib_1.__generator(this, function (_a) {\n        return [2\n        /*return*/\n        , this.blockBlobContext.stageBlock(blockId, contentLength, body, {\n          abortSignal: aborter,\n          leaseAccessConditions: options.leaseAccessConditions,\n          onUploadProgress: options.progress,\n          transactionalContentMD5: options.transactionalContentMD5\n        })];\n      });\n    });\n  };\n  /**\n   * The Stage Block From URL operation creates a new block to be committed as part\n   * of a blob where the contents are read from a URL.\n   * This API is available starting in version 2018-03-28.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/put-block-from-url\n   *\n   * @param {Aborter} aborter Create a new Aborter instance with Aborter.none or Aborter.timeout(),\n   *                          goto documents of Aborter for more examples about request cancellation\n   * @param {string} blockId A 64-byte value that is base64-encoded\n   * @param {string} sourceURL Specifies the URL of the blob. The value\n   *                           may be a URL of up to 2 KB in length that specifies a blob.\n   *                           The value should be URL-encoded as it would appear\n   *                           in a request URI. The source blob must either be public\n   *                           or must be authenticated via a shared access signature.\n   *                           If the source blob is public, no authentication is required\n   *                           to perform the operation. Here are some examples of source object URLs:\n   *                           - https://myaccount.blob.core.windows.net/mycontainer/myblob\n   *                           - https://myaccount.blob.core.windows.net/mycontainer/myblob?snapshot=<DateTime>\n   * @param {number} offset From which position of the blob to download, >= 0\n   * @param {number} [count] How much data to be downloaded, > 0. Will download to the end when undefined\n   * @param {IBlockBlobStageBlockFromURLOptions} [options={}]\n   * @returns {Promise<Models.BlockBlobStageBlockFromURLResponse>}\n   * @memberof BlockBlobURL\n   */\n\n\n  BlockBlobURL.prototype.stageBlockFromURL = function (aborter, blockId, sourceURL, offset, count, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    return tslib_1.__awaiter(this, void 0, void 0, function () {\n      return tslib_1.__generator(this, function (_a) {\n        return [2\n        /*return*/\n        , this.blockBlobContext.stageBlockFromURL(blockId, 0, sourceURL, {\n          abortSignal: aborter,\n          leaseAccessConditions: options.leaseAccessConditions,\n          sourceContentMD5: options.sourceContentMD5,\n          sourceRange: offset === 0 && !count ? undefined : rangeToString({\n            offset: offset,\n            count: count\n          })\n        })];\n      });\n    });\n  };\n  /**\n   * Writes a blob by specifying the list of block IDs that make up the blob.\n   * In order to be written as part of a blob, a block must have been successfully written\n   * to the server in a prior stageBlock operation. You can call commitBlockList to update a blob\n   * by uploading only those blocks that have changed, then committing the new and existing\n   * blocks together. Any blocks not specified in the block list and permanently deleted.\n   * @see https://docs.microsoft.com/rest/api/storageservices/put-block-list\n   *\n   * @param {Aborter} aborter Create a new Aborter instance with Aborter.none or Aborter.timeout(),\n   *                          goto documents of Aborter for more examples about request cancellation\n   * @param {string[]} blocks  Array of 64-byte value that is base64-encoded\n   * @param {IBlockBlobCommitBlockListOptions} [options]\n   * @returns {Promise<Models.BlockBlobCommitBlockListResponse>}\n   * @memberof BlockBlobURL\n   */\n\n\n  BlockBlobURL.prototype.commitBlockList = function (aborter, blocks, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    return tslib_1.__awaiter(this, void 0, void 0, function () {\n      return tslib_1.__generator(this, function (_a) {\n        options.accessConditions = options.accessConditions || {};\n        return [2\n        /*return*/\n        , this.blockBlobContext.commitBlockList({\n          latest: blocks\n        }, {\n          abortSignal: aborter,\n          blobHTTPHeaders: options.blobHTTPHeaders,\n          leaseAccessConditions: options.accessConditions.leaseAccessConditions,\n          metadata: options.metadata,\n          modifiedAccessConditions: options.accessConditions.modifiedAccessConditions\n        })];\n      });\n    });\n  };\n  /**\n   * Returns the list of blocks that have been uploaded as part of a block blob\n   * using the specified block list filter.\n   * @see https://docs.microsoft.com/rest/api/storageservices/get-block-list\n   *\n   * @param {Aborter} aborter Create a new Aborter instance with Aborter.none or Aborter.timeout(),\n   *                          goto documents of Aborter for more examples about request cancellation\n   * @param {Models.BlockListType} listType\n   * @param {IBlockBlobGetBlockListOptions} [options]\n   * @returns {Promise<Models.BlockBlobGetBlockListResponse>}\n   * @memberof BlockBlobURL\n   */\n\n\n  BlockBlobURL.prototype.getBlockList = function (aborter, listType, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    return tslib_1.__awaiter(this, void 0, void 0, function () {\n      var res;\n      return tslib_1.__generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.blockBlobContext.getBlockList(listType, {\n              abortSignal: aborter,\n              leaseAccessConditions: options.leaseAccessConditions\n            })];\n\n          case 1:\n            res = _a.sent();\n\n            if (!res.committedBlocks) {\n              res.committedBlocks = [];\n            }\n\n            if (!res.uncommittedBlocks) {\n              res.uncommittedBlocks = [];\n            }\n\n            return [2\n            /*return*/\n            , res];\n        }\n      });\n    });\n  };\n\n  return BlockBlobURL;\n}(BlobURL);\n\nexport { BlockBlobURL };","map":null,"metadata":{},"sourceType":"module"}