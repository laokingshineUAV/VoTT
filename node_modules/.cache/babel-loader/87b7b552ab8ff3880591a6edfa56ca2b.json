{"ast":null,"code":"import { isNode, URLBuilder } from \"@azure/ms-rest-js\";\n/**\n * Reserved URL characters must be properly escaped for Storage services like Blob or File.\n *\n * ## URL encode and escape strategy for JSv10 SDKs\n *\n * When customers pass a URL string into XXXURL classes constrcutor, the URL string may already be URL encoded or not.\n * But before sending to Azure Storage server, the URL must be encoded. However, it's hard for a SDK to guess whether the URL\n * string has been encoded or not. We have 2 potential strategies, and chose strategy two for the XXXURL constructors.\n *\n * ### Strategy One: Assume the customer URL string is not encoded, and always encode URL string in SDK.\n *\n * This is what legacy V2 SDK does, simple and works for most of the cases.\n * - When customer URL string is \"http://account.blob.core.windows.net/con/b:\",\n *   SDK will encode it to \"http://account.blob.core.windows.net/con/b%3A\" and send to server. A blob named \"b:\" will be created.\n * - When customer URL string is \"http://account.blob.core.windows.net/con/b%3A\",\n *   SDK will encode it to \"http://account.blob.core.windows.net/con/b%253A\" and send to server. A blob named \"b%3A\" will be created.\n *\n * But this strategy will make it not possible to create a blob with \"?\" in it's name. Because when customer URL string is\n * \"http://account.blob.core.windows.net/con/blob?name\", the \"?name\" will be treated as URL paramter instead of blob name.\n * If customer URL string is \"http://account.blob.core.windows.net/con/blob%3Fname\", a blob named \"blob%3Fname\" will be created.\n * V2 SDK doesn't have this issue because it doesn't allow customer pass in a full URL, it accepts a separate blob name and encodeURIComponent for it.\n * We cannot accept a SDK cannot create a blob name with \"?\". So we implement strategy two:\n *\n * ### Strategy Two: SDK doesn't assume the URL has been encoded or not. It will just escape the special characters.\n *\n * This is what V10 Blob Go SDK does. It accepts a URL type in Go, and call url.EscapedPath() to escape the special chars unescaped.\n * - When customer URL string is \"http://account.blob.core.windows.net/con/b:\",\n *   SDK will escape \":\" like \"http://account.blob.core.windows.net/con/b%3A\" and send to server. A blob named \"b:\" will be created.\n * - When customer URL string is \"http://account.blob.core.windows.net/con/b%3A\",\n *   There is no special characters, so send \"http://account.blob.core.windows.net/con/b%3A\" to server. A blob named \"b:\" will be created.\n * - When customer URL string is \"http://account.blob.core.windows.net/con/b%253A\",\n *   There is no special characters, so send \"http://account.blob.core.windows.net/con/b%253A\" to server. A blob named \"b%3A\" will be created.\n *\n * This strategy gives us flexibility to create with any special characters. But \"%\" will be treated as a special characters, if the URL string\n * is not encoded, there shouldn't a \"%\" in the URL string, otherwise the URL is not a valid URL.\n * If customer needs to create a blob with \"%\" in it's blob name, use \"%25\" insead of \"%\". Just like above 3rd sample.\n * And following URL strings are invalid:\n * - \"http://account.blob.core.windows.net/con/b%\"\n * - \"http://account.blob.core.windows.net/con/b%2\"\n * - \"http://account.blob.core.windows.net/con/b%G\"\n *\n * Another special character is \"?\", use \"%2F\" to represent a blob name with \"?\" in a URL string.\n *\n * ### Strategy for containerName, blobName or other specific XXXName parameters in methods such as `BlobURL.fromContainerURL(containerURL, blobName)`\n *\n * We will apply strategy one, and call encodeURIComponent for these parameters like blobName. Because what customers passes in is a plain name instead of a URL.\n *\n * @see https://docs.microsoft.com/en-us/rest/api/storageservices/naming-and-referencing-containers--blobs--and-metadata\n * @see https://docs.microsoft.com/en-us/rest/api/storageservices/naming-and-referencing-shares--directories--files--and-metadata\n *\n * @export\n * @param {string} url\n * @returns {string}\n */\n\nexport function escapeURLPath(url) {\n  var urlParsed = URLBuilder.parse(url);\n  var path = urlParsed.getPath();\n  path = path || \"/\";\n  path = escape(path);\n  urlParsed.setPath(path);\n  return urlParsed.toString();\n}\n/**\n * Internal escape method implmented Strategy Two mentioned in escapeURL() description.\n *\n * @param {string} text\n * @returns {string}\n */\n\nfunction escape(text) {\n  return encodeURIComponent(text).replace(/%2F/g, \"/\") // Don't escape for \"/\"\n  .replace(/'/g, \"%27\") // Escape for \"'\"\n  .replace(/\\+/g, \"%20\").replace(/%25/g, \"%\"); // Revert encoded \"%\"\n}\n/**\n * Append a string to URL path. Will remove duplicated \"/\" in front of the string\n * when URL path ends with a \"/\".\n *\n * @export\n * @param {string} url Source URL string\n * @param {string} name String to be appended to URL\n * @returns {string} An updated URL string\n */\n\n\nexport function appendToURLPath(url, name) {\n  var urlParsed = URLBuilder.parse(url);\n  var path = urlParsed.getPath();\n  path = path ? path.endsWith(\"/\") ? \"\" + path + name : path + \"/\" + name : name;\n  urlParsed.setPath(path);\n  return urlParsed.toString();\n}\n/**\n * Set URL parameter name and value. If name exists in URL parameters, old value\n * will be replaced by name key. If not provide value, the parameter will be deleted.\n *\n * @export\n * @param {string} url Source URL string\n * @param {string} name Parameter name\n * @param {string} [value] Parameter value\n * @returns {string} An updated URL string\n */\n\nexport function setURLParameter(url, name, value) {\n  var urlParsed = URLBuilder.parse(url);\n  urlParsed.setQueryParameter(name, value);\n  return urlParsed.toString();\n}\n/**\n * Get URL parameter by name.\n *\n * @export\n * @param {string} url\n * @param {string} name\n * @returns {(string | string[] | undefined)}\n */\n\nexport function getURLParameter(url, name) {\n  var urlParsed = URLBuilder.parse(url);\n  return urlParsed.getQueryParameterValue(name);\n}\n/**\n * Set URL host.\n *\n * @export\n * @param {string} url Source URL string\n * @param {string} host New host string\n * @returns An updated URL string\n */\n\nexport function setURLHost(url, host) {\n  var urlParsed = URLBuilder.parse(url);\n  urlParsed.setHost(host);\n  return urlParsed.toString();\n}\n/**\n * Get URL path from an URL string.\n *\n * @export\n * @param {string} url Source URL string\n * @returns {(string | undefined)}\n */\n\nexport function getURLPath(url) {\n  var urlParsed = URLBuilder.parse(url);\n  return urlParsed.getPath();\n}\n/**\n * Get URL query key value pairs from an URL string.\n *\n * @export\n * @param {string} url\n * @returns {{[key: string]: string}}\n */\n\nexport function getURLQueries(url) {\n  var queryString = URLBuilder.parse(url).getQuery();\n\n  if (!queryString) {\n    return {};\n  }\n\n  queryString = queryString.trim();\n  queryString = queryString.startsWith(\"?\") ? queryString.substr(1) : queryString;\n  var querySubStrings = queryString.split(\"&\");\n  querySubStrings = querySubStrings.filter(function (value) {\n    var indexOfEqual = value.indexOf(\"=\");\n    var lastIndexOfEqual = value.lastIndexOf(\"=\");\n    return indexOfEqual > 0 && indexOfEqual === lastIndexOfEqual && lastIndexOfEqual < value.length - 1;\n  });\n  var queries = {};\n\n  for (var _i = 0, querySubStrings_1 = querySubStrings; _i < querySubStrings_1.length; _i++) {\n    var querySubString = querySubStrings_1[_i];\n    var splitResults = querySubString.split(\"=\");\n    var key = splitResults[0];\n    var value = splitResults[1];\n    queries[key] = value;\n  }\n\n  return queries;\n}\n/**\n * Rounds a date off to seconds.\n *\n * @export\n * @param {Date} date\n * @param {boolean} [withMilliseconds=true] If true, YYYY-MM-DDThh:mm:ss.fffffffZ will be returned;\n *                                          If false, YYYY-MM-DDThh:mm:ssZ will be returned.\n * @returns {string} Date string in ISO8061 format, with or without 7 milliseconds component\n */\n\nexport function truncatedISO8061Date(date, withMilliseconds) {\n  if (withMilliseconds === void 0) {\n    withMilliseconds = true;\n  } // Date.toISOString() will return like \"2018-10-29T06:34:36.139Z\"\n\n\n  var dateString = date.toISOString();\n  return withMilliseconds ? dateString.substring(0, dateString.length - 1) + \"0000\" + \"Z\" : dateString.substring(0, dateString.length - 5) + \"Z\";\n}\n/**\n * Base64 encode.\n *\n * @export\n * @param {string} content\n * @returns {string}\n */\n\nexport function base64encode(content) {\n  return !isNode ? btoa(content) : Buffer.from(content).toString(\"base64\");\n}\n/**\n * Base64 decode.\n *\n * @export\n * @param {string} encodedString\n * @returns {string}\n */\n\nexport function base64decode(encodedString) {\n  return !isNode ? atob(encodedString) : Buffer.from(encodedString, \"base64\").toString();\n}\n/**\n * Generate a 64 bytes base64 block ID string.\n *\n * @export\n * @param {number} blockIndex\n * @returns {string}\n */\n\nexport function generateBlockID(blockIDPrefix, blockIndex) {\n  // To generate a 64 bytes base64 string, source string should be 48\n  var maxSourceStringLength = 48; // A blob can have a maximum of 100,000 uncommitted blocks at any given time\n\n  var maxBlockIndexLength = 6;\n  var maxAllowedBlockIDPrefixLength = maxSourceStringLength - maxBlockIndexLength;\n\n  if (blockIDPrefix.length > maxAllowedBlockIDPrefixLength) {\n    blockIDPrefix = blockIDPrefix.slice(0, maxAllowedBlockIDPrefixLength);\n  }\n\n  var res = blockIDPrefix + padStart(blockIndex.toString(), maxSourceStringLength - blockIDPrefix.length, \"0\");\n  return base64encode(res);\n}\n/**\n * String.prototype.padStart()\n *\n * @export\n * @param {string} currentString\n * @param {number} targetLength\n * @param {string} [padString=\" \"]\n * @returns {string}\n */\n\nexport function padStart(currentString, targetLength, padString) {\n  if (padString === void 0) {\n    padString = \" \";\n  }\n\n  if (String.prototype.padStart) {\n    return currentString.padStart(targetLength, padString);\n  }\n\n  padString = padString || \" \";\n\n  if (currentString.length > targetLength) {\n    return currentString;\n  } else {\n    targetLength = targetLength - currentString.length;\n\n    if (targetLength > padString.length) {\n      padString += padString.repeat(targetLength / padString.length);\n    }\n\n    return padString.slice(0, targetLength) + currentString;\n  }\n}","map":null,"metadata":{},"sourceType":"module"}