{"ast":null,"code":"import { isNode } from \"@azure/ms-rest-js\";\n/**\n * An aborter instance implements AbortSignal interface, can abort HTTP requests.\n *\n * - Call Aborter.none to create a new Aborter instance without timeout.\n * - Call Aborter.timeout() to create a new Aborter instance with timeout.\n *\n * For an existing instance aborter:\n * - Call aborter.withTimeout() to create and return a child Aborter instance with timeout.\n * - Call aborter.withValue(key, value) to create and return a child Aborter instance with key/value pair.\n * - Call aborter.abort() to abort current instance and all children instances.\n * - Call aborter.getValue(key) to search and get value with corresponding key from current aborter to all parents.\n *\n * @example\n * // Abort without timeout\n * await blockBlobURL.upload(Aborter.none, buf, buf.length);\n *\n * @example\n * // Abort container create in 1000ms\n * await blockBlobURL.upload(Aborter.timeout(1000), buf, buf.length);\n *\n * @example\n * // Share aborter cross multiple operations in 30s\n * // Upload the same data to 2 different data centers at the same time, abort another when any of them is finished\n * const aborter = Aborter.timeout(30 * 1000);\n * blockBlobURL1.upload(aborter, buf, buf.length).then(aborter.abort);\n * blockBlobURL2.upload(aborter, buf, buf.length).then(aborter.abort);\n *\n * @example\n * // Cascaded aborting\n * // All operations can't take more than 30 seconds\n * const aborter = Aborter.timeout(30 * 1000);\n *\n * // Following 2 operations can't take more than 25 seconds\n * await blockBlobURL.upload(aborter.withTimeout(25 * 1000), buf, buf.length);\n * await blockBlobURL.upload(aborter.withTimeout(25 * 1000), buf, buf.length);\n *\n * @export\n * @class Aborter\n * @implements {AbortSignalLike}\n */\n\nvar Aborter =\n/** @class */\nfunction () {\n  // private disposed: boolean = false;\n\n  /**\n   * Private constructor for internal usage, creates an instance of Aborter.\n   *\n   * @param {Aborter} [parent] Optional. Parent aborter.\n   * @param {number} [timeout=0] Optional. Timeout before abort in millisecond, 0 means no timeout.\n   * @param {string} [key] Optional. Immutable key in string.\n   * @param {(string | number | boolean | null)} [value] Optional. Immutable value.\n   * @memberof Aborter\n   */\n  function Aborter(parent, timeout, key, value) {\n    if (timeout === void 0) {\n      timeout = 0;\n    }\n\n    var _this = this; // tslint:disable-next-line:variable-name\n\n\n    this._aborted = false;\n    this.children = []; // When child object calls dispose(), remove child from here\n\n    this.abortEventListeners = [];\n    this.parent = parent;\n    this.key = key;\n    this.value = value;\n\n    if (timeout > 0) {\n      this.timer = setTimeout(function () {\n        _this.abort.call(_this);\n      }, timeout); // When called, the active Timeout object will not require the Node.js event loop\n      // to remain active. If there is no other activity keeping the event loop running,\n      // the process may exit before the Timeout object's callback is invoked.\n\n      if (this.timer && isNode) {\n        this.timer.unref();\n      }\n    }\n  }\n\n  Object.defineProperty(Aborter.prototype, \"aborted\", {\n    /**\n     * Status of whether aborted or not.\n     *\n     * @readonly\n     * @type {boolean}\n     * @memberof Aborter\n     */\n    get: function get() {\n      return this._aborted;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Aborter, \"none\", {\n    /**\n     * Creates a new Aborter instance without timeout.\n     *\n     * @readonly\n     * @static\n     * @type {Aborter}\n     * @memberof Aborter\n     */\n    get: function get() {\n      return new Aborter(undefined, 0);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Creates a new Aborter instance with timeout in milliseconds.\n   * Set parameter timeout to 0 will not create a timer.\n   *\n   * @static\n   * @param {number} {timeout} in milliseconds\n   * @returns {Aborter}\n   * @memberof Aborter\n   */\n\n  Aborter.timeout = function (timeout) {\n    return new Aborter(undefined, timeout);\n  };\n  /**\n   * Create and return a new Aborter instance, which will be appended as a child node of current Aborter.\n   * Current Aborter instance becomes father node of the new instance. When current or father Aborter node\n   * triggers timeout event, all children nodes abort event will be triggered too.\n   *\n   * When timeout parameter (in millisecond) is larger than 0, the abort event will be triggered when timeout.\n   * Otherwise, call abort() method to manually abort.\n   *\n   * @param {number} {timeout} Timeout in millisecond.\n   * @returns {Aborter} The new Aborter instance created.\n   * @memberof Aborter\n   */\n\n\n  Aborter.prototype.withTimeout = function (timeout) {\n    var childCancelContext = new Aborter(this, timeout);\n    this.children.push(childCancelContext);\n    return childCancelContext;\n  };\n  /**\n   * Create and return a new Aborter instance, which will be appended as a child node of current Aborter.\n   * Current Aborter instance becomes father node of the new instance. When current or father Aborter node\n   * triggers timeout event, all children nodes abort event will be triggered too.\n   *\n   * Immutable key value pair will be set into the new created Aborter instance.\n   * Call getValue() to find out latest value with corresponding key in the chain of\n   * [current node] -> [parent node] and [grand parent node]....\n   *\n   * @param {string} key\n   * @param {(string | number | boolean | null)} [value]\n   * @returns {Aborter}\n   * @memberof Aborter\n   */\n\n\n  Aborter.prototype.withValue = function (key, value) {\n    var childCancelContext = new Aborter(this, 0, key, value);\n    this.children.push(childCancelContext);\n    return childCancelContext;\n  };\n  /**\n   * Find out latest value with corresponding key in the chain of\n   * [current node] -> [parent node] -> [grand parent node] -> ... -> [root node].\n   *\n   * If key is not found, undefined will be returned.\n   *\n   * @param {string} key\n   * @returns {(string | number | boolean | null | undefined)}\n   * @memberof Aborter\n   */\n\n\n  Aborter.prototype.getValue = function (key) {\n    for (var parent_1 = this; parent_1; parent_1 = parent_1.parent) {\n      if (parent_1.key === key) {\n        return parent_1.value;\n      }\n    }\n\n    return undefined;\n  };\n  /**\n   * Trigger abort event immediately, the onabort and all abort event listeners will be triggered.\n   * Will try to trigger abort event for all children Aborter nodes.\n   *\n   * - If there is a timeout, the timer will be cancelled.\n   * - If aborted is true, nothing will happen.\n   *\n   * @returns\n   * @memberof Aborter\n   */\n\n\n  Aborter.prototype.abort = function () {\n    var _this = this;\n\n    if (this.aborted) {\n      return;\n    }\n\n    this.cancelTimer();\n\n    if (this.onabort) {\n      this.onabort.call(this);\n    }\n\n    this.abortEventListeners.forEach(function (listener) {\n      listener.call(_this);\n    });\n    this.children.forEach(function (child) {\n      return child.cancelByParent();\n    });\n    this._aborted = true;\n  }; // public dispose() {\n  //   if (this.disposed || this.aborted) {\n  //     return;\n  //   }\n  //   this.cancelTimer();\n  //   // (parent)A <- B <- C(child), if B disposes, when A abort, C will not abort\n  //   if (this.parent) {\n  //     const index = this.parent.children.indexOf(this);\n  //     if (index > -1) {\n  //       this.parent.children.splice(index, 1);\n  //     }\n  //   }\n  //   this.disposed = true;\n  // }\n\n  /**\n   * Added new \"abort\" event listener, only support \"abort\" event.\n   *\n   * @param {\"abort\"} _type Only support \"abort\" event\n   * @param {(this: AbortSignalLike, ev: any) => any} listener\n   * @memberof Aborter\n   */\n\n\n  Aborter.prototype.addEventListener = function ( // tslint:disable-next-line:variable-name\n  _type, listener) {\n    this.abortEventListeners.push(listener);\n  };\n  /**\n   * Remove \"abort\" event listener, only support \"abort\" event.\n   *\n   * @param {\"abort\"} _type Only support \"abort\" event\n   * @param {(this: AbortSignalLike, ev: any) => any} listener\n   * @memberof Aborter\n   */\n\n\n  Aborter.prototype.removeEventListener = function ( // tslint:disable-next-line:variable-name\n  _type, listener) {\n    var index = this.abortEventListeners.indexOf(listener);\n\n    if (index > -1) {\n      this.abortEventListeners.splice(index, 1);\n    }\n  };\n\n  Aborter.prototype.cancelByParent = function () {\n    // if (!this.disposed) {\n    this.abort(); // }\n  };\n\n  Aborter.prototype.cancelTimer = function () {\n    if (this.timer) {\n      clearTimeout(this.timer);\n    }\n  };\n\n  return Aborter;\n}();\n\nexport { Aborter };","map":null,"metadata":{},"sourceType":"module"}