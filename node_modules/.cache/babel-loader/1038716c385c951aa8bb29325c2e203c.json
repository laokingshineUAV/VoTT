{"ast":null,"code":"import * as tslib_1 from \"tslib\"; // In browser, during webpack or browserify bundling, this module will be replaced by 'events'\n// https://github.com/Gozala/events\n\nimport { EventEmitter } from \"events\";\n/**\n * States for Batch.\n *\n * @enum {number}\n */\n\nvar BatchStates;\n\n(function (BatchStates) {\n  BatchStates[BatchStates[\"Good\"] = 0] = \"Good\";\n  BatchStates[BatchStates[\"Error\"] = 1] = \"Error\";\n})(BatchStates || (BatchStates = {}));\n/**\n * Batch provides basic parallel execution with concurrency limits.\n * Will stop execute left operations when one of the executed operation throws an error.\n * But Batch cannot cancel ongoing operations, you need to cancel them by yourself.\n *\n * @export\n * @class Batch\n */\n\n\nvar Batch =\n/** @class */\nfunction () {\n  /**\n   * Creates an instance of Batch.\n   * @param {number} [concurrency=5]\n   * @memberof Batch\n   */\n  function Batch(concurrency) {\n    if (concurrency === void 0) {\n      concurrency = 5;\n    }\n    /**\n     * Number of active operations under execution.\n     *\n     * @private\n     * @type {number}\n     * @memberof Batch\n     */\n\n\n    this.actives = 0;\n    /**\n     * Number of completed operations under execution.\n     *\n     * @private\n     * @type {number}\n     * @memberof Batch\n     */\n\n    this.completed = 0;\n    /**\n     * Offset of next operation to be executed.\n     *\n     * @private\n     * @type {number}\n     * @memberof Batch\n     */\n\n    this.offset = 0;\n    /**\n     * Operation array to be executed.\n     *\n     * @private\n     * @type {Operation[]}\n     * @memberof Batch\n     */\n\n    this.operations = [];\n    /**\n     * States of Batch. When an error happens, state will turn into error.\n     * Batch will stop execute left operations.\n     *\n     * @private\n     * @type {BatchStates}\n     * @memberof Batch\n     */\n\n    this.state = BatchStates.Good;\n\n    if (concurrency < 1) {\n      throw new RangeError(\"concurrency must be larger than 0\");\n    }\n\n    this.concurrency = concurrency;\n    this.emitter = new EventEmitter();\n  }\n  /**\n   * Add a operation into queue.\n   *\n   * @param {Operation} operation\n   * @memberof Batch\n   */\n\n\n  Batch.prototype.addOperation = function (operation) {\n    var _this = this;\n\n    this.operations.push(function () {\n      return tslib_1.__awaiter(_this, void 0, void 0, function () {\n        var error_1;\n        return tslib_1.__generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              _a.trys.push([0, 2,, 3]);\n\n              this.actives++;\n              return [4\n              /*yield*/\n              , operation()];\n\n            case 1:\n              _a.sent();\n\n              this.actives--;\n              this.completed++;\n              this.parallelExecute();\n              return [3\n              /*break*/\n              , 3];\n\n            case 2:\n              error_1 = _a.sent();\n              this.emitter.emit(\"error\", error_1);\n              return [3\n              /*break*/\n              , 3];\n\n            case 3:\n              return [2\n              /*return*/\n              ];\n          }\n        });\n      });\n    });\n  };\n  /**\n   * Start execute operations in the queue.\n   *\n   * @returns {Promise<void>}\n   * @memberof Batch\n   */\n\n\n  Batch.prototype.do = function () {\n    return tslib_1.__awaiter(this, void 0, void 0, function () {\n      var _this = this;\n\n      return tslib_1.__generator(this, function (_a) {\n        this.parallelExecute();\n        return [2\n        /*return*/\n        , new Promise(function (resolve, reject) {\n          _this.emitter.on(\"finish\", resolve);\n\n          _this.emitter.on(\"error\", function (error) {\n            _this.state = BatchStates.Error;\n            reject(error);\n          });\n        })];\n      });\n    });\n  };\n  /**\n   * Get next operation to be executed. Return null when reaching ends.\n   *\n   * @private\n   * @returns {(Operation | null)}\n   * @memberof Batch\n   */\n\n\n  Batch.prototype.nextOperation = function () {\n    if (this.offset < this.operations.length) {\n      return this.operations[this.offset++];\n    }\n\n    return null;\n  };\n  /**\n   * Start execute operations. One one the most important difference between\n   * this method with do() is that do() wraps as an sync method.\n   *\n   * @private\n   * @returns {void}\n   * @memberof Batch\n   */\n\n\n  Batch.prototype.parallelExecute = function () {\n    if (this.state === BatchStates.Error) {\n      return;\n    }\n\n    if (this.completed >= this.operations.length) {\n      this.emitter.emit(\"finish\");\n      return;\n    }\n\n    while (this.actives < this.concurrency) {\n      var operation = this.nextOperation();\n\n      if (operation) {\n        operation();\n      } else {\n        return;\n      }\n    }\n  };\n\n  return Batch;\n}();\n\nexport { Batch };","map":null,"metadata":{},"sourceType":"module"}