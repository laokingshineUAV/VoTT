{"ast":null,"code":"// A TFRecords file contains a sequence of strings with CRC\n// hashes. Each record has the format\n//\n//     uint64 length\n//     uint32 masked_crc32_of_length\n//     byte   data[length]\n//     uint32 masked_crc32_of_data\n//\n// and the records are concatenated together to produce the file. The\n// CRC32s are described here, and the mask of a CRC is\n//\n//     masked_crc = ((crc >> 15) | (crc << 17)) + 0xa282ead8ul\n//\n// For more information, please refer to\n// https://www.tensorflow.org/versions/master/api_docs/python/python_io.html#tfrecords-format-details.\n// maskDelta is a magic number taken from\n// https://github.com/tensorflow/tensorflow/blob/754048a0453a04a761e112ae5d99c149eb9910dd/\n//    tensorflow/core/lib/hash/crc32c.h#L33.\n// const maskDelta uint32 = 0xa282ead8\n// mask returns a masked representation of crc.\nimport Guard from \"../../../common/guard\";\nimport Int64 from \"node-int64\";\nimport reverse from \"buffer-reverse\";\n/**\n * @buffer - Buffer input\n * @description - Calculate 32-bit CRC using the Castagnoli polynomial (0x1EDC6F41)\n */\n\nexport function crc32c(buffer) {\n  Guard.null(buffer);\n  var polynomial = 0x1EDC6F41; // 0x04C11DB7 for crc32\n\n  var initialValue = 0xFFFFFFFF;\n  var finalXORValue = 0xFFFFFFFF;\n  var table = [];\n  var crc = initialValue;\n  var i = 0;\n  var j = 0;\n  var c = 0;\n\n  function reverse(x, n) {\n    var b = 0;\n\n    while (n) {\n      b = b * 2 + x % 2;\n      x /= 2;\n      x -= x % 1;\n      n--;\n    }\n\n    return b;\n  }\n\n  for (i = 255; i >= 0; i--) {\n    c = reverse(i, 32);\n\n    for (j = 0; j < 8; j++) {\n      c = (c * 2 ^ (c >>> 31) % 2 * polynomial) >>> 0;\n    }\n\n    table[i] = reverse(c, 32);\n  }\n\n  for (i = 0; i < buffer.length; i++) {\n    c = buffer[i];\n\n    if (c > 255) {\n      throw new RangeError();\n    }\n\n    j = crc % 256 ^ c;\n    crc = (crc / 256 ^ table[j]) >>> 0;\n  }\n\n  return (crc ^ finalXORValue) >>> 0;\n}\n/**\n * @value - Input CRC32 value\n * @description - Mask an input CRC32 value according to the TensorFlow TFRecords specs\n */\n\nexport function maskCrc(value) {\n  Guard.null(value);\n  var kCrc32MaskDelta = 0xa282ead8;\n  var fourGb = Math.pow(2, 32);\n  return ((value >>> 15 | value << 17) + kCrc32MaskDelta) % fourGb;\n}\n/**\n * @value - Input number value\n * @description - Get a Buffer representation of a Int64 bit value\n */\n\nexport function getInt64Buffer(value) {\n  Guard.null(value);\n  var metadataBuffer = new ArrayBuffer(8);\n  var intArray = new Uint8Array(metadataBuffer, 0, 8);\n  var dataView = new DataView(metadataBuffer, 0, 8);\n  dataView.setUint32(4, 0, true);\n  dataView.setUint32(0, value, true);\n  return new Buffer(intArray);\n}\n/**\n * @value - Input number value\n * @description - Get a Buffer representation of a Int32 bit value\n */\n\nexport function getInt32Buffer(value) {\n  Guard.null(value);\n  var fourGb = Math.pow(2, 32);\n  var value32 = value % fourGb;\n  var metadataBuffer = new ArrayBuffer(4);\n  var intArray = new Uint8Array(metadataBuffer, 0, 4);\n  var dataView = new DataView(metadataBuffer, 0, 4);\n  dataView.setUint32(0, value32, true);\n  return new Buffer(intArray);\n}\n/**\n * @str - Input string\n * @description - Get a Uint8Array representation of an input string value\n */\n\nexport function textEncode(str) {\n  Guard.null(str);\n  var utf8 = unescape(encodeURIComponent(str));\n  var result = new Uint8Array(utf8.length);\n\n  for (var i = 0; i < utf8.length; i++) {\n    result[i] = utf8.charCodeAt(i);\n  }\n\n  return result;\n}\n/**\n * @arr - Input Uint8Array byte array\n * @description - Get a UTF8 string value\n */\n\nexport function textDecode(arr) {\n  Guard.null(arr);\n  var utf8 = Array.from(arr).map(function (item) {\n    return String.fromCharCode(item);\n  }).join(\"\");\n  return decodeURIComponent(escape(utf8));\n}\n/**\n * @buffer - Input buffer\n * @description - Read an Int64 value from buffer\n */\n\nexport function readInt64(buffer) {\n  Guard.null(buffer);\n  Guard.expression(buffer.length, function (num) {\n    return num >= 8;\n  });\n  buffer = reverse(buffer.slice(0, 8));\n  var int64 = new Int64(buffer, 0);\n  return int64.toNumber(true);\n}","map":{"version":3,"sources":["/home/jw/Documents/code/VoTT/src/providers/export/tensorFlowRecords/tensorFlowHelpers.ts"],"names":["Guard","Int64","reverse","crc32c","buffer","null","polynomial","initialValue","finalXORValue","table","crc","i","j","c","x","n","b","length","RangeError","maskCrc","value","kCrc32MaskDelta","fourGb","Math","pow","getInt64Buffer","metadataBuffer","ArrayBuffer","intArray","Uint8Array","dataView","DataView","setUint32","Buffer","getInt32Buffer","value32","textEncode","str","utf8","unescape","encodeURIComponent","result","charCodeAt","textDecode","arr","Array","from","map","item","String","fromCharCode","join","decodeURIComponent","escape","readInt64","expression","num","slice","int64","toNumber"],"mappings":"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","sourcesContent":["// A TFRecords file contains a sequence of strings with CRC\n// hashes. Each record has the format\n//\n//     uint64 length\n//     uint32 masked_crc32_of_length\n//     byte   data[length]\n//     uint32 masked_crc32_of_data\n//\n// and the records are concatenated together to produce the file. The\n// CRC32s are described here, and the mask of a CRC is\n//\n//     masked_crc = ((crc >> 15) | (crc << 17)) + 0xa282ead8ul\n//\n// For more information, please refer to\n// https://www.tensorflow.org/versions/master/api_docs/python/python_io.html#tfrecords-format-details.\n\n// maskDelta is a magic number taken from\n// https://github.com/tensorflow/tensorflow/blob/754048a0453a04a761e112ae5d99c149eb9910dd/\n//    tensorflow/core/lib/hash/crc32c.h#L33.\n// const maskDelta uint32 = 0xa282ead8\n// mask returns a masked representation of crc.\n\nimport Guard from \"../../../common/guard\";\nimport Int64 from \"node-int64\";\nimport reverse from \"buffer-reverse\";\n\n/**\n * @buffer - Buffer input\n * @description - Calculate 32-bit CRC using the Castagnoli polynomial (0x1EDC6F41)\n */\nexport function crc32c(buffer: Buffer): number {\n    Guard.null(buffer);\n    const polynomial = 0x1EDC6F41;  // 0x04C11DB7 for crc32\n    const initialValue = 0xFFFFFFFF;\n    const finalXORValue = 0xFFFFFFFF;\n    const table = [];\n    let crc = initialValue;\n    let i = 0;\n    let j = 0;\n    let c = 0;\n\n    function reverse(x, n) {\n        let b = 0;\n        while (n) {\n        b = b * 2 + x % 2;\n        x /= 2;\n        x -= x % 1;\n        n--;\n        }\n        return b;\n    }\n\n    for (i = 255; i >= 0; i--) {\n        c = reverse(i, 32);\n\n        for (j = 0; j < 8; j++) {\n        c = ((c * 2) ^ (((c >>> 31) % 2) * polynomial)) >>> 0;\n        }\n\n        table[i] = reverse(c, 32);\n    }\n\n    for (i = 0; i < buffer.length; i++) {\n        c = buffer[i];\n        if (c > 255) {\n        throw new RangeError();\n        }\n        j = (crc % 256) ^ c;\n        crc = ((crc / 256) ^ table[j]) >>> 0;\n    }\n\n    return (crc ^ finalXORValue) >>> 0;\n}\n\n/**\n * @value - Input CRC32 value\n * @description - Mask an input CRC32 value according to the TensorFlow TFRecords specs\n */\nexport function maskCrc(value: number): number {\n    Guard.null(value);\n    const kCrc32MaskDelta = 0xa282ead8;\n    const fourGb = Math.pow(2, 32);\n\n    return (((value >>> 15) | (value << 17)) + kCrc32MaskDelta) % fourGb;\n}\n\n/**\n * @value - Input number value\n * @description - Get a Buffer representation of a Int64 bit value\n */\nexport function getInt64Buffer(value: number): Buffer {\n    Guard.null(value);\n    const metadataBuffer = new ArrayBuffer(8);\n    const intArray = new Uint8Array(metadataBuffer, 0, 8);\n    const dataView = new DataView(metadataBuffer, 0, 8);\n\n    dataView.setUint32(4, 0, true);\n    dataView.setUint32(0, value, true);\n\n    return new Buffer(intArray);\n}\n\n/**\n * @value - Input number value\n * @description - Get a Buffer representation of a Int32 bit value\n */\nexport function getInt32Buffer(value: number): Buffer {\n    Guard.null(value);\n    const fourGb = Math.pow(2, 32);\n    const value32 = value % fourGb;\n\n    const metadataBuffer = new ArrayBuffer(4);\n    const intArray = new Uint8Array(metadataBuffer, 0, 4);\n    const dataView = new DataView(metadataBuffer, 0, 4);\n\n    dataView.setUint32(0, value32, true);\n\n    return new Buffer(intArray);\n}\n\n/**\n * @str - Input string\n * @description - Get a Uint8Array representation of an input string value\n */\nexport function textEncode(str: string): Uint8Array {\n    Guard.null(str);\n    const utf8 = unescape(encodeURIComponent(str));\n    const result = new Uint8Array(utf8.length);\n    for (let i = 0; i < utf8.length; i++) {\n        result[i] = utf8.charCodeAt(i);\n    }\n    return result;\n}\n\n/**\n * @arr - Input Uint8Array byte array\n * @description - Get a UTF8 string value\n */\nexport function textDecode(arr: Uint8Array): string {\n    Guard.null(arr);\n\n    const utf8 = Array.from(arr).map((item) => String.fromCharCode(item)).join(\"\");\n    return decodeURIComponent(escape(utf8));\n}\n\n/**\n * @buffer - Input buffer\n * @description - Read an Int64 value from buffer\n */\nexport function readInt64(buffer: Buffer): number {\n    Guard.null(buffer);\n    Guard.expression(buffer.length, (num) => num >= 8);\n\n    buffer = reverse(buffer.slice(0, 8));\n    const int64 = new Int64(buffer, 0);\n    return int64.toNumber(true);\n}\n"]},"metadata":{},"sourceType":"module"}