{"ast":null,"code":"import _objectSpread from \"/home/jw/Documents/code/VoTT/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread\";\nimport _toConsumableArray from \"/home/jw/Documents/code/VoTT/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"/home/jw/Documents/code/VoTT/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/jw/Documents/code/VoTT/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport shortid from \"shortid\";\nimport { Point2D } from \"vott-ct/lib/js/CanvasTools/Core/Point2D\";\nimport { RegionData, RegionDataType } from \"vott-ct/lib/js/CanvasTools/Core/RegionData\";\nimport { Tag } from \"vott-ct/lib/js/CanvasTools/Core/Tag\";\nimport { TagsDescriptor } from \"vott-ct/lib/js/CanvasTools/Core/TagsDescriptor\";\nimport Guard from \"../../../../common/guard\";\nimport { RegionType, AppError, ErrorCode } from \"../../../../models/applicationState\";\nimport { strings } from \"../../../../common/strings\";\n/**\n * Static functions to assist in operations within Canvas component\n */\n\nvar CanvasHelpers =\n/*#__PURE__*/\nfunction () {\n  function CanvasHelpers() {\n    _classCallCheck(this, CanvasHelpers);\n  }\n\n  _createClass(CanvasHelpers, null, [{\n    key: \"toggleTag\",\n\n    /**\n     * Adds tag to array if it does not contain the tag,\n     * removes tag if already contained. Performs operations in place\n     * @param tags Array of tags\n     * @param tag Tag to toggle\n     */\n    value: function toggleTag(tags, tag) {\n      var tagIndex = tags.findIndex(function (existingTag) {\n        return existingTag === tag;\n      });\n\n      if (tagIndex === -1) {\n        // Tag isn't found within region tags, add it\n        return [].concat(_toConsumableArray(tags), [tag]);\n      } else {\n        // Tag is within region tags, remove it\n        return tags.filter(function (t) {\n          return t !== tag;\n        });\n      }\n    }\n    /**\n     * Adds tag to tags if not contained\n     * @param tags Existing tags array\n     * @param tag Tag to be added if missing\n     */\n\n  }, {\n    key: \"addIfMissing\",\n    value: function addIfMissing(tags, tag) {\n      if (!tags.find(function (t) {\n        return t === tag;\n      })) {\n        return [].concat(_toConsumableArray(tags), [tag]);\n      }\n\n      return tags;\n    }\n    /**\n     * Adds all target tags if missing from tags\n     * @param tags Existing tags array\n     * @param newTags Tags to be added if not contained\n     */\n\n  }, {\n    key: \"addAllIfMissing\",\n    value: function addAllIfMissing(tags, newTags) {\n      var result = _toConsumableArray(tags);\n\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = newTags[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var newTag = _step.value;\n          result = CanvasHelpers.addIfMissing(result, newTag);\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      return result;\n    }\n    /**\n     * Removes tag from tags if contained\n     * @param tags Existing tags array\n     * @param tag Tag to be removed if contained in `tags`\n     */\n\n  }, {\n    key: \"removeIfContained\",\n    value: function removeIfContained(tags, tag) {\n      return tags.filter(function (t) {\n        return t !== tag;\n      });\n    }\n    /**\n     * Updates any IRegion in `regions` that has the same id as IRegion in `updates`\n     * @param regions Original regions\n     * @param updates Regions that are to be updated in `regions`\n     */\n\n  }, {\n    key: \"updateRegions\",\n    value: function updateRegions(regions, updates) {\n      if (!regions || !updates || !updates.length) {\n        return regions;\n      }\n\n      var result = [];\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        var _loop = function _loop() {\n          var region = _step2.value;\n          var update = updates.find(function (r) {\n            return r.id === region.id;\n          });\n\n          if (update) {\n            result.push(update);\n          } else {\n            result.push(region);\n          }\n        };\n\n        for (var _iterator2 = regions[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          _loop();\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n\n      return result;\n    }\n    /**\n     * Get RegionData (CanvasTools) from IRegion\n     * @param region IRegion from Canvas component\n     */\n\n  }, {\n    key: \"getRegionData\",\n    value: function getRegionData(region) {\n      return new RegionData(region.boundingBox.left, region.boundingBox.top, region.boundingBox.width, region.boundingBox.height, region.points.map(function (point) {\n        return new Point2D(point.x, point.y);\n      }), this.regionTypeToType(region.type));\n    }\n    /**\n     * Converts a canvas tools RegionData to VoTT IRegion\n     * @param regionData The region data to convert\n     * @param regionType The region type\n     */\n\n  }, {\n    key: \"fromRegionData\",\n    value: function fromRegionData(regionData, regionType) {\n      Guard.null(regionData);\n      return {\n        id: shortid.generate(),\n        type: regionType,\n        boundingBox: {\n          left: regionData.x,\n          top: regionData.y,\n          width: regionData.width,\n          height: regionData.height\n        },\n        points: regionData.points.map(function (point) {\n          return new Point2D(point.x, point.y);\n        }),\n        tags: []\n      };\n    }\n  }, {\n    key: \"isEmpty\",\n    value: function isEmpty(regionData) {\n      return regionData.area === 0 && regionData.x === 0 && regionData.y === 0;\n    }\n    /**\n     * Create TagsDescriptor (CanvasTools) from IRegion\n     * @param region IRegion from Canvas\n     */\n\n  }, {\n    key: \"getTagsDescriptor\",\n    value: function getTagsDescriptor(projectTags, region) {\n      if (!projectTags || !projectTags.length) {\n        return null;\n      }\n\n      Guard.null(region);\n      var tags = region.tags.map(function (tagName) {\n        var projectTag = projectTags.find(function (projectTag) {\n          return projectTag.name === tagName;\n        });\n        return projectTag ? new Tag(projectTag.name, projectTag.color) : null;\n      }).filter(function (tag) {\n        return tag !== null;\n      });\n      return new TagsDescriptor(tags);\n    }\n    /**\n     * Gets RegionDataType (CanvasTools) from RegionType\n     */\n\n  }]);\n\n  return CanvasHelpers;\n}();\n\nCanvasHelpers.pasteMargin = 10;\n\nCanvasHelpers.regionTypeToType = function (regionType) {\n  var type;\n\n  switch (regionType) {\n    case RegionType.Rectangle:\n      type = RegionDataType.Rect;\n      break;\n\n    case RegionType.Polygon:\n      type = RegionDataType.Polygon;\n      break;\n\n    case RegionType.Point:\n      type = RegionDataType.Point;\n      break;\n\n    case RegionType.Polyline:\n      type = RegionDataType.Polyline;\n      break;\n\n    default:\n      break;\n  }\n\n  return type;\n};\n\nCanvasHelpers.duplicateRegionsAndMove = function (regions, others, width, height) {\n  var result = [];\n  var _iteratorNormalCompletion3 = true;\n  var _didIteratorError3 = false;\n  var _iteratorError3 = undefined;\n\n  try {\n    for (var _iterator3 = regions[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n      var region = _step3.value;\n      var shiftCoordinates = CanvasHelpers.getShiftCoordinates(region.boundingBox, others, width, height);\n\n      var newRegion = _objectSpread({}, region, {\n        id: shortid.generate(),\n        boundingBox: CanvasHelpers.shiftBoundingBox(region.boundingBox, shiftCoordinates),\n        points: CanvasHelpers.shiftPoints(region.points, shiftCoordinates)\n      });\n\n      result.push(newRegion);\n    }\n  } catch (err) {\n    _didIteratorError3 = true;\n    _iteratorError3 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n        _iterator3.return();\n      }\n    } finally {\n      if (_didIteratorError3) {\n        throw _iteratorError3;\n      }\n    }\n  }\n\n  return result;\n};\n\nCanvasHelpers.boundingBoxWithin = function (boundingBox, width, height) {\n  return boundingBox.left + boundingBox.width < width && boundingBox.top + boundingBox.height < height;\n};\n\nCanvasHelpers.fromBoundingBox = function (boundingBox) {\n  return [{\n    x: boundingBox.left,\n    y: boundingBox.top\n  }, {\n    x: boundingBox.left + boundingBox.width,\n    y: boundingBox.top\n  }, {\n    x: boundingBox.left + boundingBox.width,\n    y: boundingBox.top + boundingBox.height\n  }, {\n    x: boundingBox.left,\n    y: boundingBox.top + boundingBox.height\n  }];\n};\n\nCanvasHelpers.shiftBoundingBox = function (boundingBox, shiftCoordinates) {\n  return _objectSpread({}, boundingBox, {\n    left: boundingBox.left + shiftCoordinates.x,\n    top: boundingBox.top + shiftCoordinates.y\n  });\n};\n\nCanvasHelpers.shiftPoints = function (points, shiftCoordinates) {\n  return points.map(function (p) {\n    return {\n      x: p.x + shiftCoordinates.x,\n      y: p.y + shiftCoordinates.y\n    };\n  });\n};\n\nCanvasHelpers.existsRegionAt = function (regions, x, y) {\n  var _iteratorNormalCompletion4 = true;\n  var _didIteratorError4 = false;\n  var _iteratorError4 = undefined;\n\n  try {\n    for (var _iterator4 = regions[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n      var region = _step4.value;\n\n      if (region.boundingBox.left === x && region.boundingBox.top === y) {\n        return true;\n      }\n    }\n  } catch (err) {\n    _didIteratorError4 = true;\n    _iteratorError4 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion4 && _iterator4.return != null) {\n        _iterator4.return();\n      }\n    } finally {\n      if (_didIteratorError4) {\n        throw _iteratorError4;\n      }\n    }\n  }\n\n  return false;\n};\n\nCanvasHelpers.getShiftCoordinates = function (boundingBox, otherRegions, width, height) {\n  var x = boundingBox.left;\n  var y = boundingBox.top;\n  var defaultTargetX = 0;\n  var defaultTargetY = 0;\n\n  if (boundingBox.height > height || boundingBox.width > width) {\n    throw new AppError(ErrorCode.PasteRegionTooBig, strings.errors.pasteRegionTooBigError.message);\n  }\n\n  if (!CanvasHelpers.boundingBoxWithin(boundingBox, width, height)) {\n    x = defaultTargetX;\n    y = defaultTargetY;\n  }\n\n  var foundRegionAtTarget = false;\n\n  while (!foundRegionAtTarget) {\n    if (CanvasHelpers.existsRegionAt(otherRegions, x, y)) {\n      x += CanvasHelpers.pasteMargin;\n      y += CanvasHelpers.pasteMargin;\n      foundRegionAtTarget = false;\n    } else {\n      var result = {\n        x: x - boundingBox.left,\n        y: y - boundingBox.top\n      };\n\n      var tempBoundingBox = _objectSpread({}, boundingBox, {\n        left: boundingBox.left + result.x,\n        top: boundingBox.top + result.y\n      });\n\n      if (CanvasHelpers.boundingBoxWithin(tempBoundingBox, width, height)) {\n        return result;\n      } else {\n        x = defaultTargetX;\n        y = defaultTargetY;\n\n        if (CanvasHelpers.existsRegionAt(otherRegions, defaultTargetX, defaultTargetY)) {\n          defaultTargetX += CanvasHelpers.pasteMargin;\n        }\n      }\n    }\n  }\n};\n\nexport { CanvasHelpers as default };","map":{"version":3,"sources":["/home/jw/Documents/code/VoTT/src/react/components/pages/editorPage/canvasHelpers.ts"],"names":["shortid","Point2D","RegionData","RegionDataType","Tag","TagsDescriptor","Guard","RegionType","AppError","ErrorCode","strings","CanvasHelpers","tags","tag","tagIndex","findIndex","existingTag","filter","t","find","newTags","result","newTag","addIfMissing","regions","updates","length","region","update","r","id","push","boundingBox","left","top","width","height","points","map","point","x","y","regionTypeToType","type","regionData","regionType","null","generate","area","projectTags","tagName","projectTag","name","color","pasteMargin","Rectangle","Rect","Polygon","Point","Polyline","duplicateRegionsAndMove","others","shiftCoordinates","getShiftCoordinates","newRegion","shiftBoundingBox","shiftPoints","boundingBoxWithin","fromBoundingBox","p","existsRegionAt","otherRegions","defaultTargetX","defaultTargetY","PasteRegionTooBig","errors","pasteRegionTooBigError","message","foundRegionAtTarget","tempBoundingBox"],"mappings":";;;;AAAA,OAAOA,OAAP,MAAoB,SAApB;AACA,SAASC,OAAT,QAAwB,yCAAxB;AACA,SAASC,UAAT,EAAqBC,cAArB,QAA2C,4CAA3C;AACA,SAASC,GAAT,QAAoB,qCAApB;AACA,SAASC,cAAT,QAA+B,gDAA/B;AACA,OAAOC,KAAP,MAAkB,0BAAlB;AACA,SAAsCC,UAAtC,EACYC,QADZ,EACsBC,SADtB,QACuC,qCADvC;AAEA,SAASC,OAAT,QAAwB,4BAAxB;AAEA;;;;IAGqBC,a;;;;;;;;;;AAIjB;;;;;;8BAMwBC,I,EAAgBC,G,EAAuB;AAC3D,UAAMC,QAAQ,GAAGF,IAAI,CAACG,SAAL,CAAe,UAACC,WAAD;AAAA,eAAiBA,WAAW,KAAKH,GAAjC;AAAA,OAAf,CAAjB;;AACA,UAAIC,QAAQ,KAAK,CAAC,CAAlB,EAAqB;AACjB;AACA,4CAAWF,IAAX,IAAiBC,GAAjB;AACH,OAHD,MAGO;AACH;AACA,eAAOD,IAAI,CAACK,MAAL,CAAY,UAACC,CAAD;AAAA,iBAAOA,CAAC,KAAKL,GAAb;AAAA,SAAZ,CAAP;AACH;AACJ;AAED;;;;;;;;iCAK2BD,I,EAAgBC,G,EAAuB;AAC9D,UAAI,CAACD,IAAI,CAACO,IAAL,CAAU,UAACD,CAAD;AAAA,eAAOA,CAAC,KAAKL,GAAb;AAAA,OAAV,CAAL,EAAkC;AAC9B,4CAAWD,IAAX,IAAiBC,GAAjB;AACH;;AACD,aAAOD,IAAP;AACH;AAED;;;;;;;;oCAK8BA,I,EAAgBQ,O,EAA6B;AACvE,UAAIC,MAAM,sBAAOT,IAAP,CAAV;;AADuE;AAAA;AAAA;;AAAA;AAEvE,6BAAqBQ,OAArB,8HAA8B;AAAA,cAAnBE,MAAmB;AAC1BD,UAAAA,MAAM,GAAGV,aAAa,CAACY,YAAd,CAA2BF,MAA3B,EAAmCC,MAAnC,CAAT;AACH;AAJsE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAKvE,aAAOD,MAAP;AACH;AAED;;;;;;;;sCAKgCT,I,EAAgBC,G,EAAuB;AACnE,aAAOD,IAAI,CAACK,MAAL,CAAY,UAACC,CAAD;AAAA,eAAOA,CAAC,KAAKL,GAAb;AAAA,OAAZ,CAAP;AACH;AAED;;;;;;;;kCAK4BW,O,EAAoBC,O,EAA+B;AAC3E,UAAI,CAACD,OAAD,IAAY,CAACC,OAAb,IAAwB,CAACA,OAAO,CAACC,MAArC,EAA6C;AACzC,eAAOF,OAAP;AACH;;AACD,UAAMH,MAAiB,GAAG,EAA1B;AAJ2E;AAAA;AAAA;;AAAA;AAAA;AAAA,cAKhEM,MALgE;AAMvE,cAAMC,MAAM,GAAGH,OAAO,CAACN,IAAR,CAAa,UAACU,CAAD;AAAA,mBAAOA,CAAC,CAACC,EAAF,KAASH,MAAM,CAACG,EAAvB;AAAA,WAAb,CAAf;;AACA,cAAIF,MAAJ,EAAY;AACRP,YAAAA,MAAM,CAACU,IAAP,CAAYH,MAAZ;AACH,WAFD,MAEO;AACHP,YAAAA,MAAM,CAACU,IAAP,CAAYJ,MAAZ;AACH;AAXsE;;AAK3E,8BAAqBH,OAArB,mIAA8B;AAAA;AAO7B;AAZ0E;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAa3E,aAAOH,MAAP;AACH;AAED;;;;;;;kCAI4BM,M,EAA6B;AACrD,aAAO,IAAIzB,UAAJ,CAAeyB,MAAM,CAACK,WAAP,CAAmBC,IAAlC,EACHN,MAAM,CAACK,WAAP,CAAmBE,GADhB,EAEHP,MAAM,CAACK,WAAP,CAAmBG,KAFhB,EAGHR,MAAM,CAACK,WAAP,CAAmBI,MAHhB,EAIHT,MAAM,CAACU,MAAP,CAAcC,GAAd,CAAkB,UAACC,KAAD;AAAA,eACd,IAAItC,OAAJ,CAAYsC,KAAK,CAACC,CAAlB,EAAqBD,KAAK,CAACE,CAA3B,CADc;AAAA,OAAlB,CAJG,EAMH,KAAKC,gBAAL,CAAsBf,MAAM,CAACgB,IAA7B,CANG,CAAP;AAOH;AAED;;;;;;;;mCAK6BC,U,EAAwBC,U,EAAiC;AAClFvC,MAAAA,KAAK,CAACwC,IAAN,CAAWF,UAAX;AAEA,aAAO;AACHd,QAAAA,EAAE,EAAE9B,OAAO,CAAC+C,QAAR,EADD;AAEHJ,QAAAA,IAAI,EAAEE,UAFH;AAGHb,QAAAA,WAAW,EAAE;AACTC,UAAAA,IAAI,EAAEW,UAAU,CAACJ,CADR;AAETN,UAAAA,GAAG,EAAEU,UAAU,CAACH,CAFP;AAGTN,UAAAA,KAAK,EAAES,UAAU,CAACT,KAHT;AAITC,UAAAA,MAAM,EAAEQ,UAAU,CAACR;AAJV,SAHV;AASHC,QAAAA,MAAM,EAAEO,UAAU,CAACP,MAAX,CAAkBC,GAAlB,CAAsB,UAACC,KAAD;AAAA,iBAAW,IAAItC,OAAJ,CAAYsC,KAAK,CAACC,CAAlB,EAAqBD,KAAK,CAACE,CAA3B,CAAX;AAAA,SAAtB,CATL;AAUH7B,QAAAA,IAAI,EAAE;AAVH,OAAP;AAYH;;;4BAEqBgC,U,EAAiC;AACnD,aAAOA,UAAU,CAACI,IAAX,KAAoB,CAApB,IAAyBJ,UAAU,CAACJ,CAAX,KAAiB,CAA1C,IAA+CI,UAAU,CAACH,CAAX,KAAiB,CAAvE;AACH;AAED;;;;;;;sCAIgCQ,W,EAAqBtB,M,EAAiC;AAClF,UAAI,CAACsB,WAAD,IAAgB,CAACA,WAAW,CAACvB,MAAjC,EAAyC;AACrC,eAAO,IAAP;AACH;;AACDpB,MAAAA,KAAK,CAACwC,IAAN,CAAWnB,MAAX;AAEA,UAAMf,IAAI,GAAGe,MAAM,CAACf,IAAP,CACR0B,GADQ,CACJ,UAACY,OAAD,EAAa;AACd,YAAMC,UAAU,GAAGF,WAAW,CAAC9B,IAAZ,CAAiB,UAACgC,UAAD;AAAA,iBAAgBA,UAAU,CAACC,IAAX,KAAoBF,OAApC;AAAA,SAAjB,CAAnB;AACA,eAAOC,UAAU,GAAG,IAAI/C,GAAJ,CAAQ+C,UAAU,CAACC,IAAnB,EAAyBD,UAAU,CAACE,KAApC,CAAH,GAAgD,IAAjE;AACH,OAJQ,EAKRpC,MALQ,CAKD,UAACJ,GAAD;AAAA,eAASA,GAAG,KAAK,IAAjB;AAAA,OALC,CAAb;AAOA,aAAO,IAAIR,cAAJ,CAAmBO,IAAnB,CAAP;AACH;AAED;;;;;;;;;AAxIiBD,a,CAEH2C,W,GAAc,E;;AAFX3C,a,CA2IH+B,gB,GAAmB,UAACG,UAAD,EAA4B;AACzD,MAAIF,IAAJ;;AACA,UAAQE,UAAR;AACI,SAAKtC,UAAU,CAACgD,SAAhB;AACIZ,MAAAA,IAAI,GAAGxC,cAAc,CAACqD,IAAtB;AACA;;AACJ,SAAKjD,UAAU,CAACkD,OAAhB;AACId,MAAAA,IAAI,GAAGxC,cAAc,CAACsD,OAAtB;AACA;;AACJ,SAAKlD,UAAU,CAACmD,KAAhB;AACIf,MAAAA,IAAI,GAAGxC,cAAc,CAACuD,KAAtB;AACA;;AACJ,SAAKnD,UAAU,CAACoD,QAAhB;AACIhB,MAAAA,IAAI,GAAGxC,cAAc,CAACwD,QAAtB;AACA;;AACJ;AACI;AAdR;;AAgBA,SAAOhB,IAAP;AACH,C;;AA9JgBhC,a,CAsKHiD,uB,GACN,UAACpC,OAAD,EAAqBqC,MAArB,EAAwC1B,KAAxC,EAAuDC,MAAvD,EAAqF;AACzF,MAAMf,MAAiB,GAAG,EAA1B;AADyF;AAAA;AAAA;;AAAA;AAEzF,0BAAqBG,OAArB,mIAA8B;AAAA,UAAnBG,MAAmB;AAC1B,UAAMmC,gBAAgB,GAAGnD,aAAa,CAACoD,mBAAd,CAAkCpC,MAAM,CAACK,WAAzC,EAAsD6B,MAAtD,EAA8D1B,KAA9D,EAAqEC,MAArE,CAAzB;;AAEA,UAAM4B,SAAkB,qBACjBrC,MADiB;AAEpBG,QAAAA,EAAE,EAAE9B,OAAO,CAAC+C,QAAR,EAFgB;AAGpBf,QAAAA,WAAW,EAAErB,aAAa,CAACsD,gBAAd,CAA+BtC,MAAM,CAACK,WAAtC,EAAmD8B,gBAAnD,CAHO;AAIpBzB,QAAAA,MAAM,EAAE1B,aAAa,CAACuD,WAAd,CAA0BvC,MAAM,CAACU,MAAjC,EAAyCyB,gBAAzC;AAJY,QAAxB;;AAMAzC,MAAAA,MAAM,CAACU,IAAP,CAAYiC,SAAZ;AACH;AAZwF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAazF,SAAO3C,MAAP;AACH,C;;AArLgBV,a,CAuLHwD,iB,GAAoB,UAACnC,WAAD,EAA4BG,KAA5B,EAA2CC,MAA3C,EAA8D;AAC5F,SACKJ,WAAW,CAACC,IAAZ,GAAmBD,WAAW,CAACG,KAAhC,GAAyCA,KAAzC,IACCH,WAAW,CAACE,GAAZ,GAAkBF,WAAW,CAACI,MAA/B,GAAyCA,MAF7C;AAIH,C;;AA5LgBzB,a,CA8LHyD,e,GAAkB,UAACpC,WAAD,EAAyC;AACrE,SAAO,CACH;AACIQ,IAAAA,CAAC,EAAER,WAAW,CAACC,IADnB;AAEIQ,IAAAA,CAAC,EAAET,WAAW,CAACE;AAFnB,GADG,EAKH;AACIM,IAAAA,CAAC,EAAER,WAAW,CAACC,IAAZ,GAAmBD,WAAW,CAACG,KADtC;AAEIM,IAAAA,CAAC,EAAET,WAAW,CAACE;AAFnB,GALG,EASH;AACIM,IAAAA,CAAC,EAAER,WAAW,CAACC,IAAZ,GAAmBD,WAAW,CAACG,KADtC;AAEIM,IAAAA,CAAC,EAAET,WAAW,CAACE,GAAZ,GAAkBF,WAAW,CAACI;AAFrC,GATG,EAaH;AACII,IAAAA,CAAC,EAAER,WAAW,CAACC,IADnB;AAEIQ,IAAAA,CAAC,EAAET,WAAW,CAACE,GAAZ,GAAkBF,WAAW,CAACI;AAFrC,GAbG,CAAP;AAkBH,C;;AAjNgBzB,a,CAmNFsD,gB,GAAmB,UAACjC,WAAD,EAA4B8B,gBAA5B,EAAuE;AACrG,2BACO9B,WADP;AAEIC,IAAAA,IAAI,EAAED,WAAW,CAACC,IAAZ,GAAmB6B,gBAAgB,CAACtB,CAF9C;AAGIN,IAAAA,GAAG,EAAEF,WAAW,CAACE,GAAZ,GAAkB4B,gBAAgB,CAACrB;AAH5C;AAKH,C;;AAzNgB9B,a,CA2NFuD,W,GAAc,UAAC7B,MAAD,EAAmByB,gBAAnB,EAAgD;AACzE,SAAOzB,MAAM,CAACC,GAAP,CAAW,UAAC+B,CAAD,EAAO;AACrB,WAAO;AACH7B,MAAAA,CAAC,EAAE6B,CAAC,CAAC7B,CAAF,GAAMsB,gBAAgB,CAACtB,CADvB;AAEHC,MAAAA,CAAC,EAAE4B,CAAC,CAAC5B,CAAF,GAAMqB,gBAAgB,CAACrB;AAFvB,KAAP;AAIH,GALM,CAAP;AAMH,C;;AAlOgB9B,a,CAoOF2D,c,GAAiB,UAAC9C,OAAD,EAAqBgB,CAArB,EAAgCC,CAAhC,EAA8C;AAAA;AAAA;AAAA;;AAAA;AAC1E,0BAAqBjB,OAArB,mIAA8B;AAAA,UAAnBG,MAAmB;;AAC1B,UAAIA,MAAM,CAACK,WAAP,CAAmBC,IAAnB,KAA4BO,CAA5B,IAAiCb,MAAM,CAACK,WAAP,CAAmBE,GAAnB,KAA2BO,CAAhE,EAAmE;AAC/D,eAAO,IAAP;AACH;AACJ;AALyE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAM1E,SAAO,KAAP;AACH,C;;AA3OgB9B,a,CA6OFoD,mB,GACP,UAAC/B,WAAD,EAA4BuC,YAA5B,EAAqDpC,KAArD,EAAoEC,MAApE,EAA+F;AACnG,MAAII,CAAC,GAAGR,WAAW,CAACC,IAApB;AACA,MAAIQ,CAAC,GAAGT,WAAW,CAACE,GAApB;AAEA,MAAIsC,cAAc,GAAG,CAArB;AACA,MAAMC,cAAc,GAAG,CAAvB;;AAEA,MAAIzC,WAAW,CAACI,MAAZ,GAAqBA,MAArB,IAA+BJ,WAAW,CAACG,KAAZ,GAAoBA,KAAvD,EAA8D;AAC1D,UAAM,IAAI3B,QAAJ,CAAaC,SAAS,CAACiE,iBAAvB,EAA0ChE,OAAO,CAACiE,MAAR,CAAeC,sBAAf,CAAsCC,OAAhF,CAAN;AACH;;AAED,MAAI,CAAClE,aAAa,CAACwD,iBAAd,CAAgCnC,WAAhC,EAA6CG,KAA7C,EAAoDC,MAApD,CAAL,EAAkE;AAC9DI,IAAAA,CAAC,GAAGgC,cAAJ;AACA/B,IAAAA,CAAC,GAAGgC,cAAJ;AACH;;AAED,MAAIK,mBAAmB,GAAG,KAA1B;;AAEA,SAAO,CAACA,mBAAR,EAA6B;AACzB,QAAInE,aAAa,CAAC2D,cAAd,CAA6BC,YAA7B,EAA2C/B,CAA3C,EAA8CC,CAA9C,CAAJ,EAAsD;AAClDD,MAAAA,CAAC,IAAI7B,aAAa,CAAC2C,WAAnB;AACAb,MAAAA,CAAC,IAAI9B,aAAa,CAAC2C,WAAnB;AACAwB,MAAAA,mBAAmB,GAAG,KAAtB;AACH,KAJD,MAIO;AACH,UAAMzD,MAAM,GAAG;AACXmB,QAAAA,CAAC,EAAEA,CAAC,GAAGR,WAAW,CAACC,IADR;AAEXQ,QAAAA,CAAC,EAAEA,CAAC,GAAGT,WAAW,CAACE;AAFR,OAAf;;AAIA,UAAM6C,eAAe,qBACd/C,WADc;AAEjBC,QAAAA,IAAI,EAAED,WAAW,CAACC,IAAZ,GAAmBZ,MAAM,CAACmB,CAFf;AAGjBN,QAAAA,GAAG,EAAEF,WAAW,CAACE,GAAZ,GAAkBb,MAAM,CAACoB;AAHb,QAArB;;AAKA,UAAI9B,aAAa,CAACwD,iBAAd,CAAgCY,eAAhC,EAAiD5C,KAAjD,EAAwDC,MAAxD,CAAJ,EAAqE;AACjE,eAAOf,MAAP;AACH,OAFD,MAEO;AACHmB,QAAAA,CAAC,GAAGgC,cAAJ;AACA/B,QAAAA,CAAC,GAAGgC,cAAJ;;AACA,YAAI9D,aAAa,CAAC2D,cAAd,CAA6BC,YAA7B,EAA2CC,cAA3C,EAA2DC,cAA3D,CAAJ,EAAgF;AAC5ED,UAAAA,cAAc,IAAI7D,aAAa,CAAC2C,WAAhC;AACH;AACJ;AACJ;AACJ;AACJ,C;;SA1RgB3C,a","sourcesContent":["import shortid from \"shortid\";\nimport { Point2D } from \"vott-ct/lib/js/CanvasTools/Core/Point2D\";\nimport { RegionData, RegionDataType } from \"vott-ct/lib/js/CanvasTools/Core/RegionData\";\nimport { Tag } from \"vott-ct/lib/js/CanvasTools/Core/Tag\";\nimport { TagsDescriptor } from \"vott-ct/lib/js/CanvasTools/Core/TagsDescriptor\";\nimport Guard from \"../../../../common/guard\";\nimport { IBoundingBox, IRegion, ITag, RegionType,\n    IPoint, AppError, ErrorCode } from \"../../../../models/applicationState\";\nimport { strings } from \"../../../../common/strings\";\n\n/**\n * Static functions to assist in operations within Canvas component\n */\nexport default class CanvasHelpers {\n\n    public static pasteMargin = 10;\n\n    /**\n     * Adds tag to array if it does not contain the tag,\n     * removes tag if already contained. Performs operations in place\n     * @param tags Array of tags\n     * @param tag Tag to toggle\n     */\n    public static toggleTag(tags: string[], tag: string): string[] {\n        const tagIndex = tags.findIndex((existingTag) => existingTag === tag);\n        if (tagIndex === -1) {\n            // Tag isn't found within region tags, add it\n            return [...tags, tag];\n        } else {\n            // Tag is within region tags, remove it\n            return tags.filter((t) => t !== tag);\n        }\n    }\n\n    /**\n     * Adds tag to tags if not contained\n     * @param tags Existing tags array\n     * @param tag Tag to be added if missing\n     */\n    public static addIfMissing(tags: string[], tag: string): string[] {\n        if (!tags.find((t) => t === tag)) {\n            return [...tags, tag];\n        }\n        return tags;\n    }\n\n    /**\n     * Adds all target tags if missing from tags\n     * @param tags Existing tags array\n     * @param newTags Tags to be added if not contained\n     */\n    public static addAllIfMissing(tags: string[], newTags: string[]): string[] {\n        let result = [...tags];\n        for (const newTag of newTags) {\n            result = CanvasHelpers.addIfMissing(result, newTag);\n        }\n        return result;\n    }\n\n    /**\n     * Removes tag from tags if contained\n     * @param tags Existing tags array\n     * @param tag Tag to be removed if contained in `tags`\n     */\n    public static removeIfContained(tags: string[], tag: string): string[] {\n        return tags.filter((t) => t !== tag);\n    }\n\n    /**\n     * Updates any IRegion in `regions` that has the same id as IRegion in `updates`\n     * @param regions Original regions\n     * @param updates Regions that are to be updated in `regions`\n     */\n    public static updateRegions(regions: IRegion[], updates: IRegion[]): IRegion[] {\n        if (!regions || !updates || !updates.length) {\n            return regions;\n        }\n        const result: IRegion[] = [];\n        for (const region of regions) {\n            const update = updates.find((r) => r.id === region.id);\n            if (update) {\n                result.push(update);\n            } else {\n                result.push(region);\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Get RegionData (CanvasTools) from IRegion\n     * @param region IRegion from Canvas component\n     */\n    public static getRegionData(region: IRegion): RegionData {\n        return new RegionData(region.boundingBox.left,\n            region.boundingBox.top,\n            region.boundingBox.width,\n            region.boundingBox.height,\n            region.points.map((point) =>\n                new Point2D(point.x, point.y)),\n            this.regionTypeToType(region.type));\n    }\n\n    /**\n     * Converts a canvas tools RegionData to VoTT IRegion\n     * @param regionData The region data to convert\n     * @param regionType The region type\n     */\n    public static fromRegionData(regionData: RegionData, regionType: RegionType): IRegion {\n        Guard.null(regionData);\n\n        return {\n            id: shortid.generate(),\n            type: regionType,\n            boundingBox: {\n                left: regionData.x,\n                top: regionData.y,\n                width: regionData.width,\n                height: regionData.height,\n            },\n            points: regionData.points.map((point) => new Point2D(point.x, point.y)),\n            tags: [],\n        };\n    }\n\n    public static isEmpty(regionData: RegionData): boolean {\n        return regionData.area === 0 && regionData.x === 0 && regionData.y === 0;\n    }\n\n    /**\n     * Create TagsDescriptor (CanvasTools) from IRegion\n     * @param region IRegion from Canvas\n     */\n    public static getTagsDescriptor(projectTags: ITag[], region: IRegion): TagsDescriptor {\n        if (!projectTags || !projectTags.length) {\n            return null;\n        }\n        Guard.null(region);\n\n        const tags = region.tags\n            .map((tagName) => {\n                const projectTag = projectTags.find((projectTag) => projectTag.name === tagName);\n                return projectTag ? new Tag(projectTag.name, projectTag.color) : null;\n            })\n            .filter((tag) => tag !== null);\n\n        return new TagsDescriptor(tags);\n    }\n\n    /**\n     * Gets RegionDataType (CanvasTools) from RegionType\n     */\n    public static regionTypeToType = (regionType: RegionType) => {\n        let type;\n        switch (regionType) {\n            case RegionType.Rectangle:\n                type = RegionDataType.Rect;\n                break;\n            case RegionType.Polygon:\n                type = RegionDataType.Polygon;\n                break;\n            case RegionType.Point:\n                type = RegionDataType.Point;\n                break;\n            case RegionType.Polyline:\n                type = RegionDataType.Polyline;\n                break;\n            default:\n                break;\n        }\n        return type;\n    }\n\n    /**\n     * Duplicates region with a new ID, and moves it to the next available location by intervals\n     * of `CanvasHelpers.pasteMargin`.\n     * @param regions Regions to duplicate\n     * @param others Other regions existing in the asset (used to not put region on top of other region)\n     */\n    public static duplicateRegionsAndMove =\n            (regions: IRegion[], others: IRegion[], width: number, height: number): IRegion[] => {\n        const result: IRegion[] = [];\n        for (const region of regions) {\n            const shiftCoordinates = CanvasHelpers.getShiftCoordinates(region.boundingBox, others, width, height);\n\n            const newRegion: IRegion = {\n                ...region,\n                id: shortid.generate(),\n                boundingBox: CanvasHelpers.shiftBoundingBox(region.boundingBox, shiftCoordinates),\n                points: CanvasHelpers.shiftPoints(region.points, shiftCoordinates),\n            };\n            result.push(newRegion);\n        }\n        return result;\n    }\n\n    public static boundingBoxWithin = (boundingBox: IBoundingBox, width: number, height: number) => {\n        return (\n            (boundingBox.left + boundingBox.width) < width &&\n            (boundingBox.top + boundingBox.height) < height\n        );\n    }\n\n    public static fromBoundingBox = (boundingBox: IBoundingBox): IPoint[] => {\n        return [\n            {\n                x: boundingBox.left,\n                y: boundingBox.top,\n            },\n            {\n                x: boundingBox.left + boundingBox.width,\n                y: boundingBox.top,\n            },\n            {\n                x: boundingBox.left + boundingBox.width,\n                y: boundingBox.top + boundingBox.height,\n            },\n            {\n                x: boundingBox.left,\n                y: boundingBox.top + boundingBox.height,\n            },\n        ];\n    }\n\n    private static shiftBoundingBox = (boundingBox: IBoundingBox, shiftCoordinates: IPoint): IBoundingBox => {\n        return {\n            ...boundingBox,\n            left: boundingBox.left + shiftCoordinates.x,\n            top: boundingBox.top + shiftCoordinates.y,\n        };\n    }\n\n    private static shiftPoints = (points: IPoint[], shiftCoordinates: IPoint) => {\n        return points.map((p) => {\n            return {\n                x: p.x + shiftCoordinates.x,\n                y: p.y + shiftCoordinates.y,\n            };\n        });\n    }\n\n    private static existsRegionAt = (regions: IRegion[], x: number, y: number) => {\n        for (const region of regions) {\n            if (region.boundingBox.left === x && region.boundingBox.top === y) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private static getShiftCoordinates =\n            (boundingBox: IBoundingBox, otherRegions: IRegion[], width: number, height: number): IPoint => {\n        let x = boundingBox.left;\n        let y = boundingBox.top;\n\n        let defaultTargetX = 0;\n        const defaultTargetY = 0;\n\n        if (boundingBox.height > height || boundingBox.width > width) {\n            throw new AppError(ErrorCode.PasteRegionTooBig, strings.errors.pasteRegionTooBigError.message);\n        }\n\n        if (!CanvasHelpers.boundingBoxWithin(boundingBox, width, height)) {\n            x = defaultTargetX;\n            y = defaultTargetY;\n        }\n\n        let foundRegionAtTarget = false;\n\n        while (!foundRegionAtTarget) {\n            if (CanvasHelpers.existsRegionAt(otherRegions, x, y)) {\n                x += CanvasHelpers.pasteMargin;\n                y += CanvasHelpers.pasteMargin;\n                foundRegionAtTarget = false;\n            } else {\n                const result = {\n                    x: x - boundingBox.left,\n                    y: y - boundingBox.top,\n                };\n                const tempBoundingBox = {\n                    ...boundingBox,\n                    left: boundingBox.left + result.x,\n                    top: boundingBox.top + result.y,\n                };\n                if (CanvasHelpers.boundingBoxWithin(tempBoundingBox, width, height)) {\n                    return result;\n                } else {\n                    x = defaultTargetX;\n                    y = defaultTargetY;\n                    if (CanvasHelpers.existsRegionAt(otherRegions, defaultTargetX, defaultTargetY)) {\n                        defaultTargetX += CanvasHelpers.pasteMargin;\n                    }\n                }\n            }\n        }\n    }\n}\n"]},"metadata":{},"sourceType":"module"}