{"ast":null,"code":"import * as tslib_1 from \"tslib\";\nimport { isNode } from \"@azure/ms-rest-js\";\nimport { BlobDownloadResponse } from \"./BlobDownloadResponse\";\nimport { Blob } from \"./generated/lib/operations\";\nimport { rangeToString } from \"./IRange\";\nimport { StorageURL } from \"./StorageURL\";\nimport { DEFAULT_MAX_DOWNLOAD_RETRY_REQUESTS, URLConstants } from \"./utils/constants\";\nimport { appendToURLPath, setURLParameter } from \"./utils/utils.common\";\n/**\n * A BlobURL represents a URL to an Azure Storage blob; the blob may be a block blob,\n * append blob, or page blob.\n *\n * @export\n * @class BlobURL\n * @extends {StorageURL}\n */\n\nvar BlobURL =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(BlobURL, _super);\n  /**\n   * Creates an instance of BlobURL.\n   * This method accepts an encoded URL or non-encoded URL pointing to a blob.\n   * Encoded URL string will NOT be escaped twice, only special characters in URL path will be escaped.\n   * If a blob name includes ? or %, blob name must be encoded in the URL.\n   *\n   * @param {string} url A URL string pointing to Azure Storage blob, such as\n   *                     \"https://myaccount.blob.core.windows.net/mycontainer/blob\".\n   *                     You can append a SAS if using AnonymousCredential, such as\n   *                     \"https://myaccount.blob.core.windows.net/mycontainer/blob?sasString\".\n   *                     This method accepts an encoded URL or non-encoded URL pointing to a blob.\n   *                     Encoded URL string will NOT be escaped twice, only special characters in URL path will be escaped.\n   *                     However, if a blob name includes ? or %, blob name must be encoded in the URL.\n   *                     Such as a blob named \"my?blob%\", the URL should be \"https://myaccount.blob.core.windows.net/mycontainer/my%3Fblob%25\".\n   * @param {Pipeline} pipeline Call StorageURL.newPipeline() to create a default\n   *                            pipeline, or provide a customized pipeline.\n   * @memberof BlobURL\n   */\n\n\n  function BlobURL(url, pipeline) {\n    var _this = _super.call(this, url, pipeline) || this;\n\n    _this.blobContext = new Blob(_this.storageClientContext);\n    return _this;\n  }\n  /**\n   * Creates a BlobURL object from an ContainerURL object.\n   *\n   * @static\n   * @param {ContainerURL} containerURL A ContainerURL object\n   * @param {string} blobName A blob name\n   * @returns\n   * @memberof BlobURL\n   */\n\n\n  BlobURL.fromContainerURL = function (containerURL, blobName) {\n    return new BlobURL(appendToURLPath(containerURL.url, encodeURIComponent(blobName)), containerURL.pipeline);\n  };\n  /**\n   * Creates a new BlobURL object identical to the source but with the\n   * specified request policy pipeline.\n   *\n   * @param {Pipeline} pipeline\n   * @returns {BlobURL}\n   * @memberof BlobURL\n   */\n\n\n  BlobURL.prototype.withPipeline = function (pipeline) {\n    return new BlobURL(this.url, pipeline);\n  };\n  /**\n   * Creates a new BlobURL object identical to the source but with the specified snapshot timestamp.\n   * Provide \"\" will remove the snapshot and return a URL to the base blob.\n   *\n   * @param {string} snapshot\n   * @returns {BlobURL} A new BlobURL object identical to the source but with the specified snapshot timestamp\n   * @memberof BlobURL\n   */\n\n\n  BlobURL.prototype.withSnapshot = function (snapshot) {\n    return new BlobURL(setURLParameter(this.url, URLConstants.Parameters.SNAPSHOT, snapshot.length === 0 ? undefined : snapshot), this.pipeline);\n  };\n  /**\n   * Reads or downloads a blob from the system, including its metadata and properties.\n   * You can also call Get Blob to read a snapshot.\n   *\n   * * In Node.js, data returns in a Readable stream readableStreamBody\n   * * In browsers, data returns in a promise blobBody\n   *\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/get-blob\n   *\n   * @param {Aborter} aborter Create a new Aborter instance with Aborter.none or Aborter.timeout(),\n   *                          goto documents of Aborter for more examples about request cancellation\n   * @param {number} offset From which position of the blob to download, >= 0\n   * @param {number} [count] How much data to be downloaded, > 0. Will download to the end when undefined\n   * @param {IBlobDownloadOptions} [options]\n   * @returns {Promise<Models.BlobDownloadResponse>}\n   * @memberof BlobURL\n   */\n\n\n  BlobURL.prototype.download = function (aborter, offset, count, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    return tslib_1.__awaiter(this, void 0, void 0, function () {\n      var res;\n\n      var _this = this;\n\n      return tslib_1.__generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            options.blobAccessConditions = options.blobAccessConditions || {};\n            options.blobAccessConditions.modifiedAccessConditions = options.blobAccessConditions.modifiedAccessConditions || {};\n            return [4\n            /*yield*/\n            , this.blobContext.download({\n              abortSignal: aborter,\n              leaseAccessConditions: options.blobAccessConditions.leaseAccessConditions,\n              modifiedAccessConditions: options.blobAccessConditions.modifiedAccessConditions,\n              onDownloadProgress: isNode ? undefined : options.progress,\n              range: offset === 0 && !count ? undefined : rangeToString({\n                offset: offset,\n                count: count\n              }),\n              rangeGetContentMD5: options.rangeGetContentMD5,\n              snapshot: options.snapshot\n            })];\n\n          case 1:\n            res = _a.sent(); // Return browser response immediately\n\n            if (!isNode) {\n              return [2\n              /*return*/\n              , res];\n            } // We support retrying when download stream unexpected ends in Node.js runtime\n            // Following code shouldn't be bundled into browser build, however some\n            // bundlers may try to bundle following code and \"FileReadResponse.ts\".\n            // In this case, \"FileDownloadResponse.browser.ts\" will be used as a shim of \"FileDownloadResponse.ts\"\n            // The config is in package.json \"browser\" field\n\n\n            if (options.maxRetryRequests === undefined || options.maxRetryRequests < 0) {\n              // TODO: Default value or make it a required parameter?\n              options.maxRetryRequests = DEFAULT_MAX_DOWNLOAD_RETRY_REQUESTS;\n            }\n\n            if (res.contentLength === undefined) {\n              throw new RangeError(\"File download response doesn't contain valid content length header\");\n            }\n\n            if (!res.eTag) {\n              throw new RangeError(\"File download response doesn't contain valid etag header\");\n            }\n\n            return [2\n            /*return*/\n            , new BlobDownloadResponse(aborter, res, function (start) {\n              return tslib_1.__awaiter(_this, void 0, void 0, function () {\n                var updatedOptions;\n                return tslib_1.__generator(this, function (_a) {\n                  switch (_a.label) {\n                    case 0:\n                      updatedOptions = {\n                        leaseAccessConditions: options.blobAccessConditions.leaseAccessConditions,\n                        modifiedAccessConditions: {\n                          ifMatch: options.blobAccessConditions.modifiedAccessConditions.ifMatch || res.eTag,\n                          ifModifiedSince: options.blobAccessConditions.modifiedAccessConditions.ifModifiedSince,\n                          ifNoneMatch: options.blobAccessConditions.modifiedAccessConditions.ifNoneMatch,\n                          ifUnmodifiedSince: options.blobAccessConditions.modifiedAccessConditions.ifUnmodifiedSince\n                        },\n                        range: rangeToString({\n                          count: offset + res.contentLength - start,\n                          offset: start\n                        }),\n                        snapshot: options.snapshot\n                      };\n                      return [4\n                      /*yield*/\n                      , this.blobContext.download(tslib_1.__assign({\n                        abortSignal: aborter\n                      }, updatedOptions))];\n\n                    case 1:\n                      // Debug purpose only\n                      // console.log(\n                      //   `Read from internal stream, range: ${\n                      //     updatedOptions.range\n                      //   }, options: ${JSON.stringify(updatedOptions)}`\n                      // );\n                      return [2\n                      /*return*/\n                      , _a.sent().readableStreamBody];\n                  }\n                });\n              });\n            }, offset, res.contentLength, {\n              maxRetryRequests: options.maxRetryRequests,\n              progress: options.progress\n            })];\n        }\n      });\n    });\n  };\n  /**\n   * Returns all user-defined metadata, standard HTTP properties, and system properties\n   * for the blob. It does not return the content of the blob.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/get-blob-properties\n   *\n   * @param {Aborter} aborter Create a new Aborter instance with Aborter.none or Aborter.timeout(),\n   *                          goto documents of Aborter for more examples about request cancellation\n   * @param {IBlobGetPropertiesOptions} [options]\n   * @returns {Promise<Models.BlobGetPropertiesResponse>}\n   * @memberof BlobURL\n   */\n\n\n  BlobURL.prototype.getProperties = function (aborter, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    return tslib_1.__awaiter(this, void 0, void 0, function () {\n      return tslib_1.__generator(this, function (_a) {\n        options.blobAccessConditions = options.blobAccessConditions || {};\n        return [2\n        /*return*/\n        , this.blobContext.getProperties({\n          abortSignal: aborter,\n          leaseAccessConditions: options.blobAccessConditions.leaseAccessConditions,\n          modifiedAccessConditions: options.blobAccessConditions.modifiedAccessConditions\n        })];\n      });\n    });\n  };\n  /**\n   * Marks the specified blob or snapshot for deletion. The blob is later deleted\n   * during garbage collection. Note that in order to delete a blob, you must delete\n   * all of its snapshots. You can delete both at the same time with the Delete\n   * Blob operation.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/delete-blob\n   *\n   * @param {Aborter} aborter Create a new Aborter instance with Aborter.none or Aborter.timeout(),\n   *                          goto documents of Aborter for more examples about request cancellation\n   * @param {IBlobDeleteOptions} [options]\n   * @returns {Promise<Models.BlobDeleteResponse>}\n   * @memberof BlobURL\n   */\n\n\n  BlobURL.prototype.delete = function (aborter, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    return tslib_1.__awaiter(this, void 0, void 0, function () {\n      return tslib_1.__generator(this, function (_a) {\n        options.blobAccessConditions = options.blobAccessConditions || {};\n        return [2\n        /*return*/\n        , this.blobContext.deleteMethod({\n          abortSignal: aborter,\n          deleteSnapshots: options.deleteSnapshots,\n          leaseAccessConditions: options.blobAccessConditions.leaseAccessConditions,\n          modifiedAccessConditions: options.blobAccessConditions.modifiedAccessConditions\n        })];\n      });\n    });\n  };\n  /**\n   * Restores the contents and metadata of soft deleted blob and any associated\n   * soft deleted snapshots. Undelete Blob is supported only on version 2017-07-29\n   * or later.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/undelete-blob\n   *\n   * @param {Aborter} aborter Create a new Aborter instance with Aborter.none or Aborter.timeout(),\n   *                          goto documents of Aborter for more examples about request cancellation\n   * @returns {Promise<Models.BlobUndeleteResponse>}\n   * @memberof BlobURL\n   */\n\n\n  BlobURL.prototype.undelete = function (aborter) {\n    return tslib_1.__awaiter(this, void 0, void 0, function () {\n      return tslib_1.__generator(this, function (_a) {\n        return [2\n        /*return*/\n        , this.blobContext.undelete({\n          abortSignal: aborter\n        })];\n      });\n    });\n  };\n  /**\n   * Sets system properties on the blob.\n   *\n   * If no value provided, or no value provided for the specificed blob HTTP headers,\n   * these blob HTTP headers without a value will be cleared.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-blob-properties\n   *\n   * @param {Aborter} aborter Create a new Aborter instance with Aborter.none or Aborter.timeout(),\n   *                          goto documents of Aborter for more examples about request cancellation\n   * @param {Models.BlobHTTPHeaders} [blobHTTPHeaders] If no value provided, or no value provided for\n   *                                                   the specificed blob HTTP headers, these blob HTTP\n   *                                                   headers without a value will be cleared.\n   * @param {IBlobSetHTTPHeadersOptions} [options]\n   * @returns {Promise<Models.BlobSetHTTPHeadersResponse>}\n   * @memberof BlobURL\n   */\n\n\n  BlobURL.prototype.setHTTPHeaders = function (aborter, blobHTTPHeaders, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    return tslib_1.__awaiter(this, void 0, void 0, function () {\n      return tslib_1.__generator(this, function (_a) {\n        options.blobAccessConditions = options.blobAccessConditions || {};\n        return [2\n        /*return*/\n        , this.blobContext.setHTTPHeaders({\n          abortSignal: aborter,\n          blobHTTPHeaders: blobHTTPHeaders,\n          leaseAccessConditions: options.blobAccessConditions.leaseAccessConditions,\n          modifiedAccessConditions: options.blobAccessConditions.modifiedAccessConditions\n        })];\n      });\n    });\n  };\n  /**\n   * Sets user-defined metadata for the specified blob as one or more name-value pairs.\n   *\n   * If no option provided, or no metadata defined in the parameter, the blob\n   * metadata will be removed.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-blob-metadata\n   *\n   * @param {Aborter} aborter Create a new Aborter instance with Aborter.none or Aborter.timeout(),\n   *                          goto documents of Aborter for more examples about request cancellation\n   * @param {IMetadata} [metadata] Replace existing metadata with this value.\n   *                               If no value provided the existing metadata will be removed.\n   * @param {IBlobSetMetadataOptions} [options]\n   * @returns {Promise<Models.BlobSetMetadataResponse>}\n   * @memberof BlobURL\n   */\n\n\n  BlobURL.prototype.setMetadata = function (aborter, metadata, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    return tslib_1.__awaiter(this, void 0, void 0, function () {\n      return tslib_1.__generator(this, function (_a) {\n        options.blobAccessConditions = options.blobAccessConditions || {};\n        return [2\n        /*return*/\n        , this.blobContext.setMetadata({\n          abortSignal: aborter,\n          leaseAccessConditions: options.blobAccessConditions.leaseAccessConditions,\n          metadata: metadata,\n          modifiedAccessConditions: options.blobAccessConditions.modifiedAccessConditions\n        })];\n      });\n    });\n  };\n  /**\n   * Establishes and manages a lock on a blob for write and delete operations.\n   * The lock duration can be 15 to 60 seconds, or can be infinite.\n   * In versions prior to 2012-02-12, the lock duration is 60 seconds.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/lease-blob\n   *\n   * @param {Aborter} aborter Create a new Aborter instance with Aborter.none or Aborter.timeout(),\n   *                          goto documents of Aborter for more examples about request cancellation\n   * @param {string} proposedLeaseId Can be specified in any valid GUID string format\n   * @param {number} durationÂ The lock duration can be 15 to 60 seconds, or can be infinite\n   * @param {IBlobAcquireLeaseOptions} [options]\n   * @returns {Promise<Models.BlobAcquireLeaseResponse>}\n   * @memberof BlobURL\n   */\n\n\n  BlobURL.prototype.acquireLease = function (aborter, proposedLeaseId, duration, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    return tslib_1.__awaiter(this, void 0, void 0, function () {\n      return tslib_1.__generator(this, function (_a) {\n        return [2\n        /*return*/\n        , this.blobContext.acquireLease({\n          abortSignal: aborter,\n          duration: duration,\n          modifiedAccessConditions: options.modifiedAccessConditions,\n          proposedLeaseId: proposedLeaseId\n        })];\n      });\n    });\n  };\n  /**\n   * To free the lease if it is no longer needed so that another client may immediately\n   * acquire a lease against the blob.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/lease-blob\n   *\n   * @param {Aborter} aborter Create a new Aborter instance with Aborter.none or Aborter.timeout(),\n   *                          goto documents of Aborter for more examples about request cancellation\n   * @param {string} leaseId\n   * @param {IBlobReleaseLeaseOptions} [options]\n   * @returns {Promise<Models.BlobReleaseLeaseResponse>}\n   * @memberof BlobURL\n   */\n\n\n  BlobURL.prototype.releaseLease = function (aborter, leaseId, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    return tslib_1.__awaiter(this, void 0, void 0, function () {\n      return tslib_1.__generator(this, function (_a) {\n        return [2\n        /*return*/\n        , this.blobContext.releaseLease(leaseId, {\n          abortSignal: aborter,\n          modifiedAccessConditions: options.modifiedAccessConditions\n        })];\n      });\n    });\n  };\n  /**\n   * To renew an existing lease.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/lease-blob\n   *\n   * @param {Aborter} aborter Create a new Aborter instance with Aborter.none or Aborter.timeout(),\n   *                          goto documents of Aborter for more examples about request cancellation\n   * @param {string} leaseId\n   * @param {IBlobRenewLeaseOptions} [options]\n   * @returns {Promise<Models.BlobRenewLeaseResponse>}\n   * @memberof BlobURL\n   */\n\n\n  BlobURL.prototype.renewLease = function (aborter, leaseId, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    return tslib_1.__awaiter(this, void 0, void 0, function () {\n      return tslib_1.__generator(this, function (_a) {\n        return [2\n        /*return*/\n        , this.blobContext.renewLease(leaseId, {\n          abortSignal: aborter,\n          modifiedAccessConditions: options.modifiedAccessConditions\n        })];\n      });\n    });\n  };\n  /**\n   * To change the ID of an existing lease.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/lease-blob\n   *\n   * @param {Aborter} aborter Create a new Aborter instance with Aborter.none or Aborter.timeout(),\n   *                          goto documents of Aborter for more examples about request cancellation\n   * @param {string} leaseId\n   * @param {string} proposedLeaseId\n   * @param {IBlobChangeLeaseOptions} [options]\n   * @returns {Promise<Models.BlobChangeLeaseResponse>}\n   * @memberof BlobURL\n   */\n\n\n  BlobURL.prototype.changeLease = function (aborter, leaseId, proposedLeaseId, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    return tslib_1.__awaiter(this, void 0, void 0, function () {\n      return tslib_1.__generator(this, function (_a) {\n        return [2\n        /*return*/\n        , this.blobContext.changeLease(leaseId, proposedLeaseId, {\n          abortSignal: aborter,\n          modifiedAccessConditions: options.modifiedAccessConditions\n        })];\n      });\n    });\n  };\n  /**\n   * To end the lease but ensure that another client cannot acquire a new lease\n   * until the current lease period has expired.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/lease-blob\n   *\n   * @param {Aborter} aborter Create a new Aborter instance with Aborter.none or Aborter.timeout(),\n   *                          goto documents of Aborter for more examples about request cancellation\n   * @param {number} [breakPeriod]\n   * @param {IBlobBreakLeaseOptions} [options]\n   * @returns {Promise<Models.BlobBreakLeaseResponse>}\n   * @memberof BlobURL\n   */\n\n\n  BlobURL.prototype.breakLease = function (aborter, breakPeriod, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    return tslib_1.__awaiter(this, void 0, void 0, function () {\n      return tslib_1.__generator(this, function (_a) {\n        return [2\n        /*return*/\n        , this.blobContext.breakLease({\n          abortSignal: aborter,\n          breakPeriod: breakPeriod,\n          modifiedAccessConditions: options.modifiedAccessConditions\n        })];\n      });\n    });\n  };\n  /**\n   * Creates a read-only snapshot of a blob.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/snapshot-blob\n   *\n   * @param {Aborter} aborter Create a new Aborter instance with Aborter.none or Aborter.timeout(),\n   *                          goto documents of Aborter for more examples about request cancellation\n   * @param {IBlobCreateSnapshotOptions} [options]\n   * @returns {Promise<Models.BlobCreateSnapshotResponse>}\n   * @memberof BlobURL\n   */\n\n\n  BlobURL.prototype.createSnapshot = function (aborter, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    return tslib_1.__awaiter(this, void 0, void 0, function () {\n      return tslib_1.__generator(this, function (_a) {\n        options.blobAccessConditions = options.blobAccessConditions || {};\n        return [2\n        /*return*/\n        , this.blobContext.createSnapshot({\n          abortSignal: aborter,\n          leaseAccessConditions: options.blobAccessConditions.leaseAccessConditions,\n          metadata: options.metadata,\n          modifiedAccessConditions: options.blobAccessConditions.modifiedAccessConditions\n        })];\n      });\n    });\n  };\n  /**\n   * Copies a blob to a destination within the storage account.\n   * In version 2012-02-12 and later, the source for a Copy Blob operation can be\n   * a committed blob in any Azure storage account.\n   * Beginning with version 2015-02-21, the source for a Copy Blob operation can be\n   * an Azure file in any Azure storage account.\n   * Only storage accounts created on or after June 7th, 2012 allow the Copy Blob\n   * operation to copy from another storage account.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/copy-blob\n   *\n   * @param {Aborter} aborter Create a new Aborter instance with Aborter.none or Aborter.timeout(),\n   *                          goto documents of Aborter for more examples about request cancellation\n   * @param {string} copySource\n   * @param {IBlobStartCopyFromURLOptions} [options]\n   * @returns {Promise<Models.BlobStartCopyFromURLResponse>}\n   * @memberof BlobURL\n   */\n\n\n  BlobURL.prototype.startCopyFromURL = function (aborter, copySource, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    return tslib_1.__awaiter(this, void 0, void 0, function () {\n      return tslib_1.__generator(this, function (_a) {\n        options.blobAccessConditions = options.blobAccessConditions || {};\n        options.sourceModifiedAccessConditions = options.sourceModifiedAccessConditions || {};\n        return [2\n        /*return*/\n        , this.blobContext.startCopyFromURL(copySource, {\n          abortSignal: aborter,\n          leaseAccessConditions: options.blobAccessConditions.leaseAccessConditions,\n          metadata: options.metadata,\n          modifiedAccessConditions: options.blobAccessConditions.modifiedAccessConditions,\n          sourceModifiedAccessConditions: {\n            sourceIfMatch: options.sourceModifiedAccessConditions.ifMatch,\n            sourceIfModifiedSince: options.sourceModifiedAccessConditions.ifModifiedSince,\n            sourceIfNoneMatch: options.sourceModifiedAccessConditions.ifNoneMatch,\n            sourceIfUnmodifiedSince: options.sourceModifiedAccessConditions.ifUnmodifiedSince\n          }\n        })];\n      });\n    });\n  };\n  /**\n   * Aborts a pending Copy Blob operation, and leaves a destination blob with zero\n   * length and full metadata. Version 2012-02-12 and newer.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/abort-copy-blob\n   *\n   * @param {Aborter} aborter Create a new Aborter instance with Aborter.none or Aborter.timeout(),\n   *                          goto documents of Aborter for more examples about request cancellation\n   * @param {string} copyId\n   * @param {IBlobAbortCopyFromURLOptions} [options]\n   * @returns {Promise<Models.BlobAbortCopyFromURLResponse>}\n   * @memberof BlobURL\n   */\n\n\n  BlobURL.prototype.abortCopyFromURL = function (aborter, copyId, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    return tslib_1.__awaiter(this, void 0, void 0, function () {\n      return tslib_1.__generator(this, function (_a) {\n        return [2\n        /*return*/\n        , this.blobContext.abortCopyFromURL(copyId, {\n          abortSignal: aborter,\n          leaseAccessConditions: options.leaseAccessConditions\n        })];\n      });\n    });\n  };\n  /**\n   * Sets the tier on a blob. The operation is allowed on a page blob in a premium\n   * storage account and on a block blob in a blob storage account (locally redundant\n   * storage only). A premium page blob's tier determines the allowed size, IOPS,\n   * and bandwidth of the blob. A block blob's tier determines Hot/Cool/Archive\n   * storage type. This operation does not update the blob's ETag.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-blob-tier\n   *\n   * @param {Aborter} aborter Create a new Aborter instance with Aborter.none or Aborter.timeout(),\n   *                          goto documents of Aborter for more examples about request cancellation\n   * @param {Models.AccessTier} tier\n   * @param {IBlobSetTierOptions} [options]\n   * @returns {Promise<Models.BlobsSetTierResponse>}\n   * @memberof BlobURL\n   */\n\n\n  BlobURL.prototype.setTier = function (aborter, tier, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    return tslib_1.__awaiter(this, void 0, void 0, function () {\n      return tslib_1.__generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.blobContext.setTier(tier, {\n              abortSignal: aborter,\n              leaseAccessConditions: options.leaseAccessConditions\n            })];\n\n          case 1:\n            return [2\n            /*return*/\n            , _a.sent()];\n        }\n      });\n    });\n  };\n\n  return BlobURL;\n}(StorageURL);\n\nexport { BlobURL };","map":null,"metadata":{},"sourceType":"module"}