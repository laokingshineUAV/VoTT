{"ast":null,"code":"import _classCallCheck from \"/home/jw/Documents/code/VoTT/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/jw/Documents/code/VoTT/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport Guard from \"../../../common/guard\";\nimport { TFRecordsImageMessage } from \"./tensorFlowRecordsProtoBuf_pb\";\nimport { crc32c, maskCrc, textDecode, readInt64 } from \"./tensorFlowHelpers\";\nimport { FeatureType } from \"./tensorFlowBuilder\";\n/**\n * @name - TFRecords Read Class\n * @description - Read a TFRecords object\n */\n\nexport var TFRecordsReader =\n/*#__PURE__*/\nfunction () {\n  function TFRecordsReader(tfrecords) {\n    _classCallCheck(this, TFRecordsReader);\n\n    Guard.null(tfrecords);\n    this.imageMessages = [];\n    var position = 0;\n\n    while (position < tfrecords.length) {\n      var lengthBuffer = tfrecords.slice(position, position + 8);\n      var dataLength = readInt64(lengthBuffer);\n      var lengthCrc = maskCrc(crc32c(lengthBuffer));\n      position += 8;\n      var expectedLengthCrc = tfrecords.readUInt32LE(position);\n      position += 4;\n\n      if (lengthCrc !== expectedLengthCrc) {\n        console.log(\"Wrong Length CRC\");\n        break;\n      }\n\n      var dataBuffer = tfrecords.slice(position, position + dataLength);\n      var dataCrc = maskCrc(crc32c(dataBuffer));\n      position += dataLength;\n      var expectedDataCrc = tfrecords.readUInt32LE(position);\n      position += 4;\n\n      if (dataCrc !== expectedDataCrc) {\n        console.log(\"Wrong Data CRC\");\n        break;\n      } // Deserialize TFRecord from dataBuffer\n\n\n      var imageMessage = TFRecordsImageMessage.deserializeBinary(dataBuffer);\n      this.imageMessages.push(imageMessage);\n    }\n  }\n  /**\n   * @description - Return the number of TFRecords read\n   */\n\n\n  _createClass(TFRecordsReader, [{\n    key: \"toArray\",\n\n    /**\n     * @description - Return the TFRecords in a JSON Object Array format\n     */\n    value: function toArray() {\n      return this.imageMessages.map(function (imageMessage) {\n        return imageMessage.toObject();\n      });\n    }\n    /**\n     * @recordPos - Record Position\n     * @key - Feature Key\n     * @type - Feature Type\n     * @description - Get a Int64 | Float | String | Binary value\n     */\n\n  }, {\n    key: \"getFeature\",\n    value: function getFeature(recordPos, key, type) {\n      var message = this.imageMessages[recordPos];\n      var feature = message.getContext().getFeatureMap().get(key);\n\n      switch (type) {\n        case FeatureType.String:\n          return textDecode(feature.getBytesList().array[0][0]);\n\n        case FeatureType.Binary:\n          return feature.getBytesList().array[0][0];\n\n        case FeatureType.Int64:\n          return feature.getInt64List().array[0][0];\n\n        case FeatureType.Float:\n          return feature.getFloatList().array[0][0];\n      }\n    }\n    /**\n     * @recordPos - Record Position\n     * @key - Feature Key\n     * @type - Feature Type\n     * @description - Get an array of Int64 | Float | String | Binary value\n     */\n\n  }, {\n    key: \"getArrayFeature\",\n    value: function getArrayFeature(recordPos, key, type) {\n      var message = this.imageMessages[recordPos];\n      var feature = message.getContext().getFeatureMap().get(key);\n\n      switch (type) {\n        case FeatureType.String:\n          return feature.getBytesList().array[0].map(function (buffer) {\n            return textDecode(buffer);\n          });\n\n        case FeatureType.Binary:\n          return feature.getBytesList().array[0];\n\n        case FeatureType.Int64:\n          return feature.getInt64List().array[0];\n\n        case FeatureType.Float:\n          return feature.getFloatList().array[0];\n      }\n    }\n  }, {\n    key: \"length\",\n    get: function get() {\n      return this.imageMessages.length;\n    }\n  }]);\n\n  return TFRecordsReader;\n}();","map":{"version":3,"sources":["/home/jw/Documents/code/VoTT/src/providers/export/tensorFlowRecords/tensorFlowReader.ts"],"names":["Guard","TFRecordsImageMessage","crc32c","maskCrc","textDecode","readInt64","FeatureType","TFRecordsReader","tfrecords","null","imageMessages","position","length","lengthBuffer","slice","dataLength","lengthCrc","expectedLengthCrc","readUInt32LE","console","log","dataBuffer","dataCrc","expectedDataCrc","imageMessage","deserializeBinary","push","map","toObject","recordPos","key","type","message","feature","getContext","getFeatureMap","get","String","getBytesList","array","Binary","Int64","getInt64List","Float","getFloatList","buffer"],"mappings":"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","sourcesContent":["import Guard from \"../../../common/guard\";\nimport { TFRecordsImageMessage, Features, Feature, FeatureList,\n    BytesList, Int64List, FloatList } from \"./tensorFlowRecordsProtoBuf_pb\";\nimport { crc32c, maskCrc, textDecode, readInt64 } from \"./tensorFlowHelpers\";\nimport { FeatureType } from \"./tensorFlowBuilder\";\n\n/**\n * @name - TFRecords Read Class\n * @description - Read a TFRecords object\n */\nexport class TFRecordsReader {\n    private imageMessages: TFRecordsImageMessage[];\n\n    constructor(tfrecords: Buffer) {\n        Guard.null(tfrecords);\n\n        this.imageMessages = [];\n        let position = 0;\n\n        while (position < tfrecords.length) {\n            const lengthBuffer = tfrecords.slice(position, position + 8);\n            const dataLength = readInt64(lengthBuffer);\n            const lengthCrc = maskCrc(crc32c(lengthBuffer));\n            position += 8;\n\n            const expectedLengthCrc = tfrecords.readUInt32LE(position);\n            position += 4;\n\n            if (lengthCrc !== expectedLengthCrc) {\n                console.log(\"Wrong Length CRC\");\n                break;\n            }\n\n            const dataBuffer = tfrecords.slice(position, position + dataLength);\n            const dataCrc = maskCrc(crc32c(dataBuffer));\n            position += dataLength;\n\n            const expectedDataCrc = tfrecords.readUInt32LE(position);\n            position += 4;\n\n            if (dataCrc !== expectedDataCrc) {\n                console.log(\"Wrong Data CRC\");\n                break;\n            }\n\n            // Deserialize TFRecord from dataBuffer\n            const imageMessage: TFRecordsImageMessage = TFRecordsImageMessage.deserializeBinary(dataBuffer);\n\n            this.imageMessages.push(imageMessage);\n        }\n    }\n\n    /**\n     * @description - Return the number of TFRecords read\n     */\n    get length(): number {\n        return this.imageMessages.length;\n    }\n\n    /**\n     * @description - Return the TFRecords in a JSON Object Array format\n     */\n    public toArray(): object[] {\n        return this.imageMessages.map((imageMessage) => imageMessage.toObject());\n    }\n\n    /**\n     * @recordPos - Record Position\n     * @key - Feature Key\n     * @type - Feature Type\n     * @description - Get a Int64 | Float | String | Binary value\n     */\n    public getFeature(recordPos: number, key: string, type: FeatureType): string | number | Uint8Array {\n        const message = this.imageMessages[recordPos];\n        const feature = message.getContext().getFeatureMap().get(key);\n\n        switch (type) {\n            case FeatureType.String:\n                return textDecode(feature.getBytesList().array[0][0]);\n            case FeatureType.Binary:\n                return feature.getBytesList().array[0][0];\n            case FeatureType.Int64:\n                return feature.getInt64List().array[0][0];\n            case FeatureType.Float:\n                return feature.getFloatList().array[0][0];\n        }\n    }\n\n    /**\n     * @recordPos - Record Position\n     * @key - Feature Key\n     * @type - Feature Type\n     * @description - Get an array of Int64 | Float | String | Binary value\n     */\n    public getArrayFeature(recordPos: number, key: string, type: FeatureType): string[] | number[] | Uint8Array[] {\n        const message = this.imageMessages[recordPos];\n        const feature = message.getContext().getFeatureMap().get(key);\n\n        switch (type) {\n            case FeatureType.String:\n                return feature.getBytesList().array[0].map((buffer) => textDecode(buffer));\n            case FeatureType.Binary:\n                return feature.getBytesList().array[0];\n            case FeatureType.Int64:\n                return feature.getInt64List().array[0];\n            case FeatureType.Float:\n                return feature.getFloatList().array[0];\n        }\n    }\n}\n"]},"metadata":{},"sourceType":"module"}