{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/home/jw/Documents/code/VoTT/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/jw/Documents/code/VoTT/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\r\n * Invertion filter.\r\n * @param canvas - Source HTMLCanvas element.\r\n */\n\nfunction InvertFilter(canvas) {\n  var context = canvas.getContext(\"2d\");\n  var imageData = context.getImageData(0, 0, canvas.width, canvas.height);\n  var buff = document.createElement(\"canvas\");\n  buff.width = canvas.width;\n  buff.height = canvas.height;\n  var data = imageData.data;\n\n  for (var i = 0; i < data.length; i += 4) {\n    data[i] = 255 - data[i]; // red\n\n    data[i + 1] = 255 - data[i + 1]; // green\n\n    data[i + 2] = 255 - data[i + 2]; // blue\n  }\n\n  buff.getContext(\"2d\").putImageData(imageData, 0, 0);\n  return new Promise(function (resolve, reject) {\n    return resolve(buff);\n  });\n}\n\nexports.InvertFilter = InvertFilter;\n/**\r\n * Grayscale filter.\r\n * @param canvas - Source HTMLCanvas element.\r\n */\n\nfunction GrayscaleFilter(canvas) {\n  var context = canvas.getContext(\"2d\");\n  var imageData = context.getImageData(0, 0, canvas.width, canvas.height);\n  var buff = document.createElement(\"canvas\");\n  buff.width = canvas.width;\n  buff.height = canvas.height;\n  var data = imageData.data;\n\n  for (var i = 0; i < data.length; i += 4) {\n    var gray = 0.2126 * data[i] + 0.7152 * data[i + 1] + 0.0722 * data[i + 2];\n    data[i] = gray; // red\n\n    data[i + 1] = gray; // green\n\n    data[i + 2] = gray; // blue\n  }\n\n  buff.getContext(\"2d\").putImageData(imageData, 0, 0);\n  return new Promise(function (resolve, reject) {\n    return resolve(buff);\n  });\n}\n\nexports.GrayscaleFilter = GrayscaleFilter;\n/**\r\n * Experimental blur difference filter.\r\n * @param factor - Bluring factor (in pixels).\r\n */\n\nfunction BlurDiffFilter(factor) {\n  // http://blog.ivank.net/fastest-gaussian-blur.html\n  function boxesForGauss(sigma, n) {\n    var wIdeal = Math.sqrt(12 * sigma * sigma / n + 1); // Ideal averaging filter width\n\n    var wl = Math.floor(wIdeal);\n\n    if (wl % 2 === 0) {\n      wl--;\n    }\n\n    var wu = wl + 2;\n    var mIdeal = (12 * sigma * sigma - n * wl * wl - 4 * n * wl - 3 * n) / (-4 * wl - 4);\n    var m = Math.round(mIdeal); // var sigmaActual = Math.sqrt( (m*wl*wl + (n-m)*wu*wu - n)/12 );\n\n    var sizes = [];\n\n    for (var i = 0; i < n; i++) {\n      sizes.push(i < m ? wl : wu);\n    }\n\n    return sizes;\n  }\n\n  function gaussBlur_4(scl, tcl, w, h, r) {\n    var bxs = boxesForGauss(r, 3);\n    boxBlur_4(scl, tcl, w, h, (bxs[0] - 1) / 2);\n    boxBlur_4(tcl, scl, w, h, (bxs[1] - 1) / 2);\n    boxBlur_4(scl, tcl, w, h, (bxs[2] - 1) / 2);\n  }\n\n  function boxBlur_4(scl, tcl, w, h, r) {\n    for (var i = 0; i < scl.length; i++) {\n      tcl[i] = scl[i];\n    }\n\n    boxBlurH_4(tcl, scl, w, h, r);\n    boxBlurT_4(scl, tcl, w, h, r);\n  }\n\n  function boxBlurH_4(scl, tcl, w, h, r) {\n    var iarr = 1 / (r + r + 1);\n\n    for (var i = 0; i < h; i++) {\n      var ti = i * w;\n      var li = ti;\n      var ri = ti + r;\n      var fv = scl[ti];\n      var lv = scl[ti + w - 1];\n      var val = (r + 1) * fv;\n\n      for (var j = 0; j < r; j++) {\n        val += scl[ti + j];\n      }\n\n      for (var _j = 0; _j <= r; _j++) {\n        val += scl[ri++] - fv;\n        tcl[ti++] = Math.round(val * iarr);\n      }\n\n      for (var _j2 = r + 1; _j2 < w - r; _j2++) {\n        val += scl[ri++] - scl[li++];\n        tcl[ti++] = Math.round(val * iarr);\n      }\n\n      for (var _j3 = w - r; _j3 < w; _j3++) {\n        val += lv - scl[li++];\n        tcl[ti++] = Math.round(val * iarr);\n      }\n    }\n  }\n\n  function boxBlurT_4(scl, tcl, w, h, r) {\n    var iarr = 1 / (r + r + 1);\n\n    for (var i = 0; i < w; i++) {\n      var ti = i;\n      var li = ti;\n      var ri = ti + r * w;\n      var fv = scl[ti];\n      var lv = scl[ti + w * (h - 1)];\n      var val = (r + 1) * fv;\n\n      for (var j = 0; j < r; j++) {\n        val += scl[ti + j * w];\n      }\n\n      for (var _j4 = 0; _j4 <= r; _j4++) {\n        val += scl[ri] - fv;\n        tcl[ti] = Math.round(val * iarr);\n        ri += w;\n        ti += w;\n      }\n\n      for (var _j5 = r + 1; _j5 < h - r; _j5++) {\n        val += scl[ri] - scl[li];\n        tcl[ti] = Math.round(val * iarr);\n        li += w;\n        ri += w;\n        ti += w;\n      }\n\n      for (var _j6 = h - r; _j6 < h; _j6++) {\n        val += lv - scl[li];\n        tcl[ti] = Math.round(val * iarr);\n        li += w;\n        ti += w;\n      }\n    }\n  }\n\n  return function (canvas) {\n    var context = canvas.getContext(\"2d\");\n    var imageData = context.getImageData(0, 0, canvas.width, canvas.height);\n    var buff = document.createElement(\"canvas\");\n    buff.width = canvas.width;\n    buff.height = canvas.height;\n    var bludData = buff.getContext(\"2d\").createImageData(buff.width, buff.height);\n    var idata = imageData.data;\n    var bdata = bludData.data;\n    var pixelsNumber = canvas.width * canvas.height;\n    var dataR = new Uint8ClampedArray(pixelsNumber);\n    var dataG = new Uint8ClampedArray(pixelsNumber);\n    var dataB = new Uint8ClampedArray(pixelsNumber);\n    var dataA = new Uint8ClampedArray(pixelsNumber);\n\n    for (var i = 0; i < pixelsNumber; i++) {\n      dataR[i] = idata[4 * i];\n      dataG[i] = idata[4 * i + 1];\n      dataB[i] = idata[4 * i + 2];\n      dataA[i] = idata[4 * i + 3];\n    }\n\n    var blurR = new Uint8ClampedArray(pixelsNumber);\n    var blurG = new Uint8ClampedArray(pixelsNumber);\n    var blurB = new Uint8ClampedArray(pixelsNumber);\n    var blurR2 = new Uint8ClampedArray(pixelsNumber);\n    var blurG2 = new Uint8ClampedArray(pixelsNumber);\n    var blurB2 = new Uint8ClampedArray(pixelsNumber); // let blurA = new Uint8ClampedArray(pixelsNumber);\n\n    var halfFactor = factor / 2;\n    gaussBlur_4(dataR, blurR, buff.width, buff.height, halfFactor);\n    gaussBlur_4(dataG, blurG, buff.width, buff.height, halfFactor);\n    gaussBlur_4(dataB, blurB, buff.width, buff.height, halfFactor);\n    gaussBlur_4(dataR, blurR2, buff.width, buff.height, factor);\n    gaussBlur_4(dataG, blurG2, buff.width, buff.height, factor);\n    gaussBlur_4(dataB, blurB2, buff.width, buff.height, factor);\n    var alphaStep = 127 / factor;\n\n    for (var _i = 0; _i < pixelsNumber; _i++) {\n      var dr = Math.abs(blurR2[_i] - blurR[_i]);\n      var dg = Math.abs(blurG2[_i] - blurG[_i]);\n      var db = Math.abs(blurB2[_i] - blurB[_i]); // const d = 0.2126 * dr + 0.7152 * dg + 0.0722 * db;\n\n      var d = 0.2358 * dr + 0.0700 * dg + 0.6742 * db;\n      /* let dr = Math.abs(blurR2[i] - idata[4 * i + 0]);\r\n      let dg = Math.abs(blurG2[i] - idata[4 * i + 1]);\r\n      let db = Math.abs(blurB2[i] - idata[4 * i + 2]); */\n      // let d = 255 - Math.min(Math.round(Math.max(dr + dg + db - 16, 0)/8) * 16, 255);\n\n      /* bdata[4 * i + 0] = d;\r\n      bdata[4 * i + 1] = d;\r\n      bdata[4 * i + 2] = d; */\n\n      /* bdata[4 * i + 0] = (d < factor) ? Math.round(idata[4 * i + 0] / factor) * factor : idata[4 * i + 0];\r\n      bdata[4 * i + 1] = (d < factor) ? Math.round(idata[4 * i + 1] / factor) * factor : idata[4 * i + 1];\r\n      bdata[4 * i + 2] = (d < factor) ? Math.round(idata[4 * i + 2] / factor) * factor : idata[4 * i + 2]; */\n\n      /* bdata[4 * i + 0] = (dr >= 0.2126 * factor) ?\r\n                          idata[4 * i + 0] :  Math.round(idata[4 * i + 0] / factor) * factor;\r\n      bdata[4 * i + 1] = (dg >= 0.7152 * factor) ?\r\n                          idata[4 * i + 1] :  Math.round(idata[4 * i + 1] / factor) * factor;\r\n      bdata[4 * i + 2] = (db >= 0.0722 * factor) ?\r\n                          idata[4 * i + 2] :  Math.round(idata[4 * i + 2] / factor) * factor; */\n\n      var g = Math.round(0.2358 * idata[4 * _i + 0] + 0.0700 * idata[4 * _i + 1] + 0.6742 * idata[4 * _i + 2]);\n      bdata[4 * _i + 0] = dr >= 0.2358 * halfFactor ? idata[4 * _i + 0] : Math.round(g / factor) * factor;\n      bdata[4 * _i + 1] = dg >= 0.0700 * halfFactor ? idata[4 * _i + 1] : Math.round(g / factor) * factor;\n      bdata[4 * _i + 2] = db >= 0.6742 * halfFactor ? idata[4 * _i + 2] : Math.round(g / factor) * factor;\n      /* bdata[4 * i + 0] = Math.round(idata[4 * i + 0] / 8) * 8;\r\n      bdata[4 * i + 1] = Math.round(idata[4 * i + 1] / 8) * 8;\r\n      bdata[4 * i + 2] = Math.round(idata[4 * i + 2] / 8) * 8; */\n\n      bdata[4 * _i + 3] = d >= factor ? 255 : 0 + Math.round(d * alphaStep);\n    }\n\n    buff.getContext(\"2d\").putImageData(bludData, 0, 0);\n    return new Promise(function (resolve, reject) {\n      return resolve(buff);\n    });\n  };\n}\n\nexports.BlurDiffFilter = BlurDiffFilter;\n/**\r\n * Brightness filter.\r\n * @param brightness - The brightness value in the range [0, 255] to be added to pixels.\r\n */\n\nfunction BrightnessFilter(brightness) {\n  return function (canvas) {\n    var context = canvas.getContext(\"2d\");\n    var imageData = context.getImageData(0, 0, canvas.width, canvas.height);\n    var buff = document.createElement(\"canvas\");\n    buff.width = canvas.width;\n    buff.height = canvas.height;\n    var data = imageData.data;\n\n    for (var i = 0; i < data.length; i += 4) {\n      data[i + 0] = Math.max(0, Math.min(data[i + 0] + brightness, 255));\n      data[i + 1] = Math.max(0, Math.min(data[i + 1] + brightness, 255));\n      data[i + 2] = Math.max(0, Math.min(data[i + 2] + brightness, 255));\n    }\n\n    buff.getContext(\"2d\").putImageData(imageData, 0, 0);\n    return new Promise(function (resolve, reject) {\n      return resolve(buff);\n    });\n  };\n}\n\nexports.BrightnessFilter = BrightnessFilter;\n/**\r\n * Contrast filter.\r\n * @param contrast - The contrast factor in the range [-255, 255] to be applied to pixels.\r\n */\n\nfunction ContrastFilter(contrast) {\n  return function (canvas) {\n    var context = canvas.getContext(\"2d\");\n    var imageData = context.getImageData(0, 0, canvas.width, canvas.height);\n    var buff = document.createElement(\"canvas\");\n    buff.width = canvas.width;\n    buff.height = canvas.height;\n    var data = imageData.data;\n    var factor = 259 * (contrast + 255) / (255 * (259 - contrast));\n\n    for (var i = 0; i < data.length; i += 4) {\n      data[i + 0] = factor * (data[i] - 128) + 128;\n      data[i + 1] = factor * (data[i + 1] - 128) + 128;\n      data[i + 2] = factor * (data[i + 2] - 128) + 128;\n    }\n\n    buff.getContext(\"2d\").putImageData(imageData, 0, 0);\n    return new Promise(function (resolve, reject) {\n      return resolve(buff);\n    });\n  };\n}\n\nexports.ContrastFilter = ContrastFilter;\n/**\r\n * Saturation filter\r\n * @param saturation - The saturation factor in the range [0, 255] to be applied to pixels.\r\n */\n\nfunction SaturationFilter(saturation) {\n  return function (canvas) {\n    var context = canvas.getContext(\"2d\");\n    var imageData = context.getImageData(0, 0, canvas.width, canvas.height);\n    var buff = document.createElement(\"canvas\");\n    buff.width = canvas.width;\n    buff.height = canvas.height;\n    var s = saturation / 255;\n    var data = imageData.data;\n\n    for (var i = 0; i < data.length; i += 4) {\n      var r = data[i + 0];\n      var g = data[i + 1];\n      var b = data[i + 2];\n      var gr = 0.213 * r + 0.715 * g + 0.072 * b;\n      var nr = gr + s * (+0.787 * r - 0.715 * g - 0.072 * b);\n      var ng = gr + s * (-0.213 * r + 0.285 * g - 0.072 * b);\n      var nb = gr + s * (-0.213 * r - 0.715 * g + 0.928 * b);\n      data[i] = Math.round(nr); // red\n\n      data[i + 1] = Math.round(ng); // green\n\n      data[i + 2] = Math.round(nb); // blue\n    }\n\n    buff.getContext(\"2d\").putImageData(imageData, 0, 0);\n    return new Promise(function (resolve, reject) {\n      return resolve(buff);\n    });\n  };\n}\n\nexports.SaturationFilter = SaturationFilter;\n/*     convoluteFilter(canvas, weights, opaque) {\r\n        var context = canvas.getContext('2d');\r\n        var imageData = context.getImageData(0, 0, canvas.width, canvas.height);\r\n\r\n        var side = Math.round(Math.sqrt(weights.length));\r\n        var halfSide = Math.floor(side/2);\r\n        var src = imageData.data;\r\n        var sw = imageData.width;\r\n        var sh = imageData.height;\r\n        // pad output by the convolution matrix\r\n        var w = sw;\r\n        var h = sh;\r\n        var output = new ImageData(w, h);\r\n\r\n        var dst = output.data;\r\n        // go through the destination image pixels\r\n        var alphaFac = opaque ? 1 : 0;\r\n        for (var y=0; y<h; y++) {\r\n            for (var x=0; x<w; x++) {\r\n                var sy = y;\r\n                var sx = x;\r\n                var dstOff = (y*w+x)*4;\r\n                // calculate the weighed sum of the source image pixels that\r\n                // fall under the convolution matrix\r\n                var r=0, g=0, b=0, a=0;\r\n                for (var cy=0; cy<side; cy++) {\r\n                    for (var cx=0; cx<side; cx++) {\r\n                        var scy = sy + cy - halfSide;\r\n                        var scx = sx + cx - halfSide;\r\n                        if (scy >= 0 && scy < sh && scx >= 0 && scx < sw) {\r\n                            var srcOff = (scy*sw+scx)*4;\r\n                            var wt = weights[cy*side+cx];\r\n                            r += src[srcOff] * wt;\r\n                            g += src[srcOff+1] * wt;\r\n                            b += src[srcOff+2] * wt;\r\n                            a += src[srcOff+3] * wt;\r\n                        }\r\n                    }\r\n                }\r\n                dst[dstOff] = r;\r\n                dst[dstOff+1] = g;\r\n                dst[dstOff+2] = b;\r\n                dst[dstOff+3] = a + alphaFac*(255-a);\r\n            }\r\n        }\r\n        return output;\r\n    } */\n\n/**\r\n * The `FilterPipeline` class used to create a pipeline of canvas data transformations\r\n * before displaying it to the user.\r\n */\n\nvar FilterPipeline =\n/*#__PURE__*/\nfunction () {\n  /**\r\n   * Creates new instance of the `FilterPipeline`.\r\n   */\n  function FilterPipeline() {\n    _classCallCheck(this, FilterPipeline);\n\n    this.pipeline = new Array();\n  }\n  /**\r\n   * Add new filter function to pipeline.\r\n   * @param filter - A new filter function.\r\n   */\n\n\n  _createClass(FilterPipeline, [{\n    key: \"addFilter\",\n    value: function addFilter(filter) {\n      this.pipeline.push(filter);\n    }\n    /**\r\n     * Clear all the filters in pipeline.\r\n     */\n\n  }, {\n    key: \"clearFilters\",\n    value: function clearFilters() {\n      this.pipeline = new Array();\n    }\n    /**\r\n     * Apply filters pipeline to provided source canvas.\r\n     * @param canvas - The source HTML Canvas element.\r\n     * @returns A new `Promise` resolved when all filters are applyed.\r\n     */\n\n  }, {\n    key: \"applyToCanvas\",\n    value: function applyToCanvas(canvas) {\n      var promise = new Promise(function (resolve, reject) {\n        return resolve(canvas);\n      });\n\n      if (this.pipeline.length > 0) {\n        this.pipeline.forEach(function (filter) {\n          promise = promise.then(filter);\n        });\n      }\n\n      return promise;\n    }\n  }]);\n\n  return FilterPipeline;\n}();\n\nexports.FilterPipeline = FilterPipeline;","map":null,"metadata":{},"sourceType":"script"}