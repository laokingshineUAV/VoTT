{"ast":null,"code":"// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\nimport { DateTimeUtils, Util } from '@microsoft/applicationinsights-common';\nimport { CoreUtils, LoggingSeverity, _InternalMessageId } from '@microsoft/applicationinsights-core-js';\n/**\r\n* Class encapsulates sending page views and page view performance telemetry.\r\n*/\n\nvar PageViewManager =\n/** @class */\nfunction () {\n  function PageViewManager(appInsights, overridePageViewDuration, core, pageViewPerformanceManager) {\n    this.pageViewPerformanceSent = false;\n    this.overridePageViewDuration = false;\n    this.overridePageViewDuration = overridePageViewDuration;\n    this.appInsights = appInsights;\n    this._pageViewPerformanceManager = pageViewPerformanceManager;\n\n    if (core) {\n      this._channel = function () {\n        return core.getTransmissionControls();\n      };\n\n      this._logger = core.logger;\n    }\n  }\n  /**\r\n  * Currently supported cases:\r\n  * 1) (default case) track page view called with default parameters, overridePageViewDuration = false. Page view is sent with page view performance when navigation timing data is available.\r\n  *    a. If navigation timing is not supported then page view is sent right away with undefined duration. Page view performance is not sent.\r\n  * 2) overridePageViewDuration = true, custom duration provided. Custom duration is used, page view sends right away.\r\n  * 3) overridePageViewDuration = true, custom duration NOT provided. Page view is sent right away, duration is time spent from page load till now (or undefined if navigation timing is not supported).\r\n  * 4) overridePageViewDuration = false, custom duration is provided. Page view is sent right away with custom duration.\r\n  *\r\n  * In all cases page view performance is sent once (only for the 1st call of trackPageView), or not sent if navigation timing is not supported.\r\n  */\n\n\n  PageViewManager.prototype.trackPageView = function (pageView, customProperties) {\n    var _this = this;\n\n    var name = pageView.name;\n\n    if (CoreUtils.isNullOrUndefined(name) || typeof name !== \"string\") {\n      pageView.name = window.document && window.document.title || \"\";\n    }\n\n    var uri = pageView.uri;\n\n    if (CoreUtils.isNullOrUndefined(uri) || typeof uri !== \"string\") {\n      pageView.uri = window.location && window.location.href || \"\";\n    } // case 1a. if performance timing is not supported by the browser, send the page view telemetry with the duration provided by the user. If the user\n    // do not provide the duration, set duration to undefined\n    // Also this is case 4\n\n\n    if (!this._pageViewPerformanceManager.isPerformanceTimingSupported()) {\n      this.appInsights.sendPageViewInternal(pageView, customProperties);\n\n      this._channel().forEach(function (queues) {\n        queues.forEach(function (q) {\n          return q.flush(true);\n        });\n      }); // no navigation timing (IE 8, iOS Safari 8.4, Opera Mini 8 - see http://caniuse.com/#feat=nav-timing)\n\n\n      this._logger.throwInternal(LoggingSeverity.WARNING, _InternalMessageId.NavigationTimingNotSupported, \"trackPageView: navigation timing API used for calculation of page duration is not supported in this browser. This page view will be collected without duration and timing info.\");\n\n      return;\n    }\n\n    var pageViewSent = false;\n    var customDuration = undefined; // if the performance timing is supported by the browser, calculate the custom duration\n\n    var start = this._pageViewPerformanceManager.getPerformanceTiming().navigationStart;\n\n    customDuration = DateTimeUtils.GetDuration(start, +new Date());\n\n    if (!this._pageViewPerformanceManager.shouldCollectDuration(customDuration)) {\n      customDuration = undefined;\n    } // if the user has provided duration, send a page view telemetry with the provided duration. Otherwise, if\n    // overridePageViewDuration is set to true, send a page view telemetry with the custom duration calculated earlier\n\n\n    var duration = undefined;\n\n    if (!CoreUtils.isNullOrUndefined(customProperties) && !CoreUtils.isNullOrUndefined(customProperties.duration)) {\n      duration = customProperties.duration;\n    }\n\n    if (this.overridePageViewDuration || !isNaN(duration)) {\n      if (isNaN(duration)) {\n        // case 3\n        if (!customProperties) {\n          customProperties = {};\n        }\n\n        customProperties[\"duration\"] = customDuration;\n      } // case 2\n\n\n      this.appInsights.sendPageViewInternal(pageView, customProperties);\n\n      this._channel().forEach(function (queues) {\n        queues.forEach(function (q) {\n          return q.flush(true);\n        });\n      });\n\n      pageViewSent = true;\n    } // now try to send the page view performance telemetry\n\n\n    var maxDurationLimit = 60000;\n\n    if (!customProperties) {\n      customProperties = {};\n    }\n\n    var handle = setInterval(function () {\n      try {\n        if (_this._pageViewPerformanceManager.isPerformanceTimingDataReady()) {\n          clearInterval(handle);\n          var pageViewPerformance = {\n            name: name,\n            uri: uri\n          };\n\n          _this._pageViewPerformanceManager.populatePageViewPerformanceEvent(pageViewPerformance);\n\n          if (!pageViewPerformance.isValid && !pageViewSent) {\n            // If navigation timing gives invalid numbers, then go back to \"override page view duration\" mode.\n            // That's the best value we can get that makes sense.\n            customProperties[\"duration\"] = customDuration;\n\n            _this.appInsights.sendPageViewInternal(pageView, customProperties);\n\n            _this._channel().forEach(function (queues) {\n              queues.forEach(function (q) {\n                return q.flush(true);\n              });\n            });\n          } else {\n            if (!pageViewSent) {\n              customProperties[\"duration\"] = pageViewPerformance.durationMs;\n\n              _this.appInsights.sendPageViewInternal(pageView, customProperties);\n            }\n\n            if (!_this.pageViewPerformanceSent) {\n              _this.appInsights.sendPageViewPerformanceInternal(pageViewPerformance, customProperties);\n\n              _this.pageViewPerformanceSent = true;\n            }\n\n            _this._channel().forEach(function (queues) {\n              queues.forEach(function (q) {\n                return q.flush(true);\n              });\n            });\n          }\n        } else if (DateTimeUtils.GetDuration(start, +new Date()) > maxDurationLimit) {\n          // if performance timings are not ready but we exceeded the maximum duration limit, just log a page view telemetry\n          // with the maximum duration limit. Otherwise, keep waiting until performance timings are ready\n          clearInterval(handle);\n\n          if (!pageViewSent) {\n            customProperties[\"duration\"] = maxDurationLimit;\n\n            _this.appInsights.sendPageViewInternal(pageView, customProperties);\n\n            _this._channel().forEach(function (queues) {\n              queues.forEach(function (q) {\n                return q.flush(true);\n              });\n            });\n          }\n        }\n      } catch (e) {\n        _this._logger.throwInternal(LoggingSeverity.CRITICAL, _InternalMessageId.TrackPVFailedCalc, \"trackPageView failed on page load calculation: \" + Util.getExceptionName(e), {\n          exception: Util.dump(e)\n        });\n      }\n    }, 100);\n  };\n\n  return PageViewManager;\n}();\n\nexport { PageViewManager };","map":null,"metadata":{},"sourceType":"module"}