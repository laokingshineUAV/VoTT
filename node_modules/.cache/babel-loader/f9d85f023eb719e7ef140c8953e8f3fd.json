{"ast":null,"code":"import * as tslib_1 from \"tslib\";\nimport { generateUuid } from \"@azure/ms-rest-js\";\nimport { Batch } from \"./utils/Batch\";\nimport { BLOCK_BLOB_MAX_BLOCKS, BLOCK_BLOB_MAX_STAGE_BLOCK_BYTES, BLOCK_BLOB_MAX_UPLOAD_BLOB_BYTES, DEFAULT_BLOB_DOWNLOAD_BLOCK_BYTES } from \"./utils/constants\";\nimport { generateBlockID } from \"./utils/utils.common\";\n/**\n * ONLY AVAILABLE IN BROWSERS.\n *\n * Uploads a browser Blob/File/ArrayBuffer/ArrayBufferView object to block blob.\n *\n * When buffer length <= 256MB, this method will use 1 upload call to finish the upload.\n * Otherwise, this method will call stageBlock to upload blocks, and finally call commitBlockList\n * to commit the block list.\n *\n * @export\n * @param {Aborter} aborter Create a new Aborter instance with Aborter.none or Aborter.timeout(),\n *                          goto documents of Aborter for more examples about request cancellation\n * @param {Blob | ArrayBuffer | ArrayBufferView} browserData Blob, File, ArrayBuffer or ArrayBufferView\n * @param {BlockBlobURL} blockBlobURL\n * @param {IUploadToBlockBlobOptions} [options]\n * @returns {Promise<BlobUploadCommonResponse>}\n */\n\nexport function uploadBrowserDataToBlockBlob(aborter, browserData, blockBlobURL, options) {\n  return tslib_1.__awaiter(this, void 0, void 0, function () {\n    var browserBlob;\n    return tslib_1.__generator(this, function (_a) {\n      browserBlob = new Blob([browserData]);\n      return [2\n      /*return*/\n      , UploadSeekableBlobToBlockBlob(aborter, function (offset, size) {\n        return browserBlob.slice(offset, offset + size);\n      }, browserBlob.size, blockBlobURL, options)];\n    });\n  });\n}\n/**\n * ONLY AVAILABLE IN BROWSERS.\n *\n * Uploads a browser Blob object to block blob. Requires a blobFactory as the data source,\n * which need to return a Blob object with the offset and size provided.\n *\n * When buffer length <= 256MB, this method will use 1 upload call to finish the upload.\n * Otherwise, this method will call stageBlock to upload blocks, and finally call commitBlockList\n * to commit the block list.\n *\n * @param {Aborter} aborter Create a new Aborter instance with Aborter.none or Aborter.timeout(),\n *                          goto documents of Aborter for more examples about request cancellation\n * @param {(offset: number, size: number) => Blob} blobFactory\n * @param {number} size\n * @param {BlockBlobURL} blockBlobURL\n * @param {IUploadToBlockBlobOptions} [options]\n * @returns {Promise<BlobUploadCommonResponse>}\n */\n\nfunction UploadSeekableBlobToBlockBlob(aborter, blobFactory, size, blockBlobURL, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  return tslib_1.__awaiter(this, void 0, void 0, function () {\n    var numBlocks, blockList, blockIDPrefix, transferProgress, batch, _loop_1, i;\n\n    var _this = this;\n\n    return tslib_1.__generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          if (!options.blockSize) {\n            options.blockSize = 0;\n          }\n\n          if (options.blockSize < 0 || options.blockSize > BLOCK_BLOB_MAX_STAGE_BLOCK_BYTES) {\n            throw new RangeError(\"blockSize option must be >= 0 and <= \" + BLOCK_BLOB_MAX_STAGE_BLOCK_BYTES);\n          }\n\n          if (options.maxSingleShotSize !== 0 && !options.maxSingleShotSize) {\n            options.maxSingleShotSize = BLOCK_BLOB_MAX_UPLOAD_BLOB_BYTES;\n          }\n\n          if (options.maxSingleShotSize < 0 || options.maxSingleShotSize > BLOCK_BLOB_MAX_UPLOAD_BLOB_BYTES) {\n            throw new RangeError(\"maxSingleShotSize option must be >= 0 and <= \" + BLOCK_BLOB_MAX_UPLOAD_BLOB_BYTES);\n          }\n\n          if (options.blockSize === 0) {\n            if (size > BLOCK_BLOB_MAX_STAGE_BLOCK_BYTES * BLOCK_BLOB_MAX_BLOCKS) {\n              throw new RangeError(size + \" is too larger to upload to a block blob.\");\n            }\n\n            if (size > options.maxSingleShotSize) {\n              options.blockSize = Math.ceil(size / BLOCK_BLOB_MAX_BLOCKS);\n\n              if (options.blockSize < DEFAULT_BLOB_DOWNLOAD_BLOCK_BYTES) {\n                options.blockSize = DEFAULT_BLOB_DOWNLOAD_BLOCK_BYTES;\n              }\n            }\n          }\n\n          if (!options.blobHTTPHeaders) {\n            options.blobHTTPHeaders = {};\n          }\n\n          if (!options.blobAccessConditions) {\n            options.blobAccessConditions = {};\n          }\n\n          if (size <= options.maxSingleShotSize) {\n            return [2\n            /*return*/\n            , blockBlobURL.upload(aborter, blobFactory(0, size), size, options)];\n          }\n\n          numBlocks = Math.floor((size - 1) / options.blockSize) + 1;\n\n          if (numBlocks > BLOCK_BLOB_MAX_BLOCKS) {\n            throw new RangeError(\"The buffer's size is too big or the BlockSize is too small;\" + (\"the number of blocks must be <= \" + BLOCK_BLOB_MAX_BLOCKS));\n          }\n\n          blockList = [];\n          blockIDPrefix = generateUuid();\n          transferProgress = 0;\n          batch = new Batch(options.parallelism);\n\n          _loop_1 = function _loop_1(i) {\n            batch.addOperation(function () {\n              return tslib_1.__awaiter(_this, void 0, void 0, function () {\n                var blockID, start, end, contentLength;\n                return tslib_1.__generator(this, function (_a) {\n                  switch (_a.label) {\n                    case 0:\n                      blockID = generateBlockID(blockIDPrefix, i);\n                      start = options.blockSize * i;\n                      end = i === numBlocks - 1 ? size : start + options.blockSize;\n                      contentLength = end - start;\n                      blockList.push(blockID);\n                      return [4\n                      /*yield*/\n                      , blockBlobURL.stageBlock(aborter, blockID, blobFactory(start, contentLength), contentLength, {\n                        leaseAccessConditions: options.blobAccessConditions.leaseAccessConditions\n                      })];\n\n                    case 1:\n                      _a.sent(); // Update progress after block is successfully uploaded to server, in case of block trying\n                      // TODO: Hook with convenience layer progress event in finer level\n\n\n                      transferProgress += contentLength;\n\n                      if (options.progress) {\n                        options.progress({\n                          loadedBytes: transferProgress\n                        });\n                      }\n\n                      return [2\n                      /*return*/\n                      ];\n                  }\n                });\n              });\n            });\n          };\n\n          for (i = 0; i < numBlocks; i++) {\n            _loop_1(i);\n          }\n\n          return [4\n          /*yield*/\n          , batch.do()];\n\n        case 1:\n          _a.sent();\n\n          return [2\n          /*return*/\n          , blockBlobURL.commitBlockList(aborter, blockList, options)];\n      }\n    });\n  });\n}","map":null,"metadata":{},"sourceType":"module"}