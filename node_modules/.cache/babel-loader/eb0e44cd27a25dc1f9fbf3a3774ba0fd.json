{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"/home/jw/Documents/code/VoTT/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _classCallCheck = require(\"/home/jw/Documents/code/VoTT/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/jw/Documents/code/VoTT/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar XYZColor_1 = require(\"./XYZColor\");\n/**\r\n * Represents the CIE LAB color space.\r\n */\n\n\nvar LABColor =\n/*#__PURE__*/\nfunction () {\n  _createClass(LABColor, [{\n    key: \"l\",\n\n    /**\r\n     * The lightness value of the color.\r\n     */\n    get: function get() {\n      return this.values[0];\n    }\n    /**\r\n     * The a-component of the color (green to red).\r\n     */\n\n  }, {\n    key: \"a\",\n    get: function get() {\n      return this.values[1];\n    }\n    /**\r\n     * The b-component of the color (blue to yellow).\r\n     */\n\n  }, {\n    key: \"b\",\n    get: function get() {\n      return this.values[2];\n    }\n    /**\r\n     * Creates new CIE LAB color.\r\n     * @param l - Lightness component in the range [0, 1].\r\n     * @param a - A-component in the range [0, 1].\r\n     * @param b - B-component in the range [0, 1].\r\n     */\n\n  }]);\n\n  function LABColor(l, a, b) {\n    _classCallCheck(this, LABColor);\n\n    this.values = [l, a, b];\n  }\n  /**\r\n   * Computes color difference using the CIE94 formula as defined here:\r\n   * https://en.wikipedia.org/wiki/Color_difference.\r\n   * @remarks It is better to use the CIE DE2000 formula, but it requires significantly more computations.\r\n   * E.g., check this reveiw: http://www.color.org/events/colorimetry/Melgosa_CIEDE2000_Workshop-July4.pdf.\r\n   * @param color - A color to compare.\r\n   * @returns The distance between this and provided colors.\r\n   */\n\n\n  _createClass(LABColor, [{\n    key: \"distanceTo\",\n    value: function distanceTo(color) {\n      var deltaL = this.values[0] - color.values[0];\n      var deltaA = this.values[1] - color.values[1];\n      var deltaB = this.values[2] - color.values[2];\n      var c1 = Math.sqrt(this.values[1] * this.values[1] + this.values[2] * this.values[2]);\n      var c2 = Math.sqrt(color.values[1] * color.values[1] + color.values[2] * color.values[2]);\n      var deltaC = c1 - c2;\n      var deltaH = deltaA * deltaA + deltaB * deltaB - deltaC * deltaC;\n      deltaH = deltaH < 0 ? 0 : Math.sqrt(deltaH);\n      var sc = 1.0 + 0.045 * c1;\n      var sh = 1.0 + 0.015 * c1;\n      var deltaLKlsl = deltaL / 1.0;\n      var deltaCkcsc = deltaC / sc;\n      var deltaHkhsh = deltaH / sh;\n      var i = deltaLKlsl * deltaLKlsl + deltaCkcsc * deltaCkcsc + deltaHkhsh * deltaHkhsh;\n      return i < 0 ? 0 : Math.sqrt(i);\n    }\n  }, {\n    key: \"distanceTo_00\",\n    value: function distanceTo_00(color) {\n      var _this$values = _slicedToArray(this.values, 3),\n          L1 = _this$values[0],\n          a1 = _this$values[1],\n          b1 = _this$values[2];\n\n      var _color$values = _slicedToArray(color.values, 3),\n          L2 = _color$values[0],\n          a2 = _color$values[1],\n          b2 = _color$values[2];\n\n      var kL = 1.0;\n      var kC = 1.0;\n      var kH = 1.0;\n      var K1 = 0.045;\n      var K2 = 0.015;\n      var deg2rad = Math.PI / 180.0;\n      var rad2deg = 180.0 / Math.PI;\n      var deltaL = L2 - L1;\n      var midL = (L1 + L2) / 2;\n      var C1 = Math.sqrt(a1 * a1 + b1 * b1);\n      var C2 = Math.sqrt(a2 * a2 + b2 * b2);\n      var midC = (C1 + C2) / 2;\n      var midC7 = Math.pow(midC, 7);\n      var midC7Root = Math.sqrt(midC7 / (midC7 + Math.pow(25, 7)));\n      var a1t = a1 + 0.5 * a1 * (1 - midC7Root);\n      var a2t = a2 + 0.5 * a2 * (1 - midC7Root);\n      var C1t = Math.sqrt(a1t * a1t + b1 * b1);\n      var C2t = Math.sqrt(a2t * a2t + b2 * b2);\n      var midCt = (C1t + C2t) / 2;\n      var deltaCt = C2t - C1t;\n      var h1 = b1 === 0 && a1t === 0 ? 0 : Math.atan2(b1, a1t) * rad2deg % 360;\n      var h2 = b2 === 0 && a2t === 0 ? 0 : Math.atan2(b2, a2t) * rad2deg % 360;\n      var deltah = h2 - h1;\n      var absDeltah = Math.abs(deltah);\n\n      if (h2 <= h1 && absDeltah > 180) {\n        deltah += 360;\n      }\n\n      if (h2 > h1 && absDeltah > 180) {\n        deltah -= 360;\n      }\n\n      var deltaH = 2 * Math.sqrt(C1t * C2t) * Math.sin(0.5 * deltah * deg2rad);\n      var H = (h1 + h2) / 2;\n\n      if (absDeltah > 180 && h1 + h2 < 360) {\n        H += 180;\n      }\n\n      if (absDeltah > 180 && h1 + h2 >= 360) {\n        H -= 180;\n      }\n\n      var T = 1 - 0.17 * Math.cos((H - 30) * deg2rad) + 0.24 * Math.cos(2 * H * deg2rad) + 0.32 * Math.cos((3 * H + 6) * deg2rad) - 0.20 * Math.cos((4 * H - 63) * deg2rad);\n      var SL = 1 + K2 * (midL - 50) / Math.sqrt(20 + (midL - 50) * (midL - 50));\n      var SC = 1 + K1 * midCt;\n      var SH = 1 + K2 * midCt * T;\n      var RT = -2 * midC7Root * Math.sin(60 * Math.exp(-((H - 275) / 25) * ((H - 275) / 25)) * deg2rad);\n      var diff = Math.sqrt(Math.pow(deltaL / (kL * SL), 2) + Math.pow(deltaCt / (kC * SC), 2) + Math.pow(deltaH / (kH * SH), 2) + RT * (deltaCt / (kC * SC)) * (deltaH / (kH * SH)));\n      return diff;\n    }\n    /**\r\n     * Computes the distance to a=b=0 in the AB-subspace.\r\n     */\n\n  }, {\n    key: \"distanceToGray\",\n    value: function distanceToGray() {\n      return Math.sqrt(this.a * this.a + this.b * this.b);\n    }\n    /**\r\n     * Return a copy of color values in array format as [l, a, b].\r\n     */\n\n  }, {\n    key: \"toArray\",\n    value: function toArray() {\n      // copy\n      return this.values.map(function (v) {\n        return v;\n      });\n    }\n    /**\r\n     * Trasforms color to the XYZ format.\r\n     */\n\n  }, {\n    key: \"toXYZ\",\n    value: function toXYZ() {\n      var y = (this.l * 100 + 16) / 116;\n      var x = this.a / 5 + y;\n      var z = y - this.b / 2;\n\n      var _map = [x, y, z].map(function (v) {\n        var v3 = v * v * v;\n        return v3 > 0.008856451 ? v3 : (v - 16 / 116) / 7.787037;\n      });\n\n      var _map2 = _slicedToArray(_map, 3);\n\n      x = _map2[0];\n      y = _map2[1];\n      z = _map2[2];\n      return new XYZColor_1.XYZColor(x * XYZColor_1.XYZColor.D65.x, y * XYZColor_1.XYZColor.D65.y, z * XYZColor_1.XYZColor.D65.z);\n    }\n    /**\r\n     * Trasforms color to the RGB format.\r\n     */\n\n  }, {\n    key: \"toRGB\",\n    value: function toRGB() {\n      return this.toXYZ().toRGB();\n    }\n    /**\r\n     * Trasforms color to the sRGB format.\r\n     */\n\n  }, {\n    key: \"toSRGB\",\n    value: function toSRGB() {\n      return this.toXYZ().toRGB().toSRGB();\n    }\n  }]);\n\n  return LABColor;\n}();\n\nexports.LABColor = LABColor;","map":null,"metadata":{},"sourceType":"script"}