"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const react_1 = __importDefault(require("react"));
const react_tag_input_1 = require("react-tag-input");
const utils_1 = require("../../common/utils");
const tagColors_1 = require("../common/tagColors");
exports.defaultValues = {
    tagColors: tagColors_1.tagColors,
    delimiters: [utils_1.KeyCodes.comma, utils_1.KeyCodes.enter],
    placeHolder: "Add new tag",
};
/**
 * Component for creating, modifying and using tags
 */
class TagsInput extends react_1.default.Component {
    constructor() {
        super(...arguments);
        this.state = {
            tags: this.props.tags,
            currentTagColorIndex: 0,
        };
        /**
         * Update an existing tag, called after clicking "OK" in modal
         * @param oldTag Tag being edited
         * @param newTag Newly edited version of tag
         */
        this.updateTag = (oldTag, newTag) => {
            /**
             * If this was a name change (ids are not equal), don"t allow
             * the new tag to be named with a name that currently exists
             * in other tags. Probably should include an error message.
             * For now, just doesn"t allow the action to take place. Modal
             * won"t close and user won"t be able to set the name. This is
             * similar to how the component handles duplicate naming at the
             * creation level. If user enters name that already exists in
             * tags, the component just doesn"t do anything.
             */
            if (newTag.name !== oldTag.name && this.state.tags.some((t) => t.name === newTag.name)) {
                return;
            }
            const tags = this.state.tags.map((tag) => (tag.name === oldTag.name) ? newTag : tag);
            this.setState({ tags }, () => this.props.onChange(tags));
        };
        /**
         * Get span element for each tag
         * Protected so that inheriting components can override if necessary
         * Defaults to just returning the name of the tag in the span
         * @param name Name of tag to get
         */
        this.getTagSpan = (name) => {
            if (this.props.getTagSpan) {
                return this.props.getTagSpan(name, this.getTagIndex(name));
            }
            return react_1.default.createElement("span", null, name);
        };
        this.getTagColorKeys = () => {
            return Object.keys(this.getTagColors());
        };
        this.getTagColors = () => {
            return this.props.tagColors || exports.defaultValues.tagColors;
        };
        this.getTagIndex = (name) => {
            return this.state.tags.findIndex((tag) => tag.name === name);
        };
        // UI Handlers
        /**
         * Calls the onTagClick handler if not null with clicked tag
         * @param event Click event
         */
        this.handleTagClick = (event) => {
            const text = this.getTagIdFromClick(event);
            const tag = this.getTag(text);
            if (this.props.onCtrlShiftTagClick && event.ctrlKey && event.shiftKey) {
                this.props.onCtrlShiftTagClick(tag);
            }
            else if (this.props.onCtrlTagClick && (event.ctrlKey || event.metaKey)) {
                this.props.onCtrlTagClick(tag);
            }
            else if (this.props.onShiftTagClick && event.shiftKey) {
                this.props.onShiftTagClick(tag);
            }
            else if (this.props.onTagClick) {
                this.props.onTagClick(tag);
            }
            this.blurInput();
        };
        // Helpers
        /**
         * Gets the tag with the given name
         * @param name string name of tag.
         */
        this.getTag = (name) => {
            const match = this.state.tags.find((tag) => tag.name === name);
            if (!match) {
                throw new Error(`No tag by name: ${name}`);
            }
            return match;
        };
        /**
         * Generate necessary HTML to render tag box appropriately
         * @param name name of tag
         * @param color color of tag
         */
        this.ReactTagHtml = (name, color) => {
            return (react_1.default.createElement("div", { className: "tag inline-block", "data-tag-name": name, onClick: (event) => this.handleTagClick(event) },
                react_1.default.createElement("div", { className: "tag-contents" },
                    react_1.default.createElement("div", { className: "tag-color-box", style: { backgroundColor: color } }),
                    this.getTagSpan(name))));
        };
        /**
         * Allows for click-and-drag re-ordering of tags
         * @param tag Tag being dragged
         * @param currPos Current position of tag
         * @param newPos New position of tag
         */
        this.handleDrag = (tag, currPos, newPos) => {
            const tags = [...this.state.tags];
            const newTags = tags.slice();
            newTags.splice(currPos, 1);
            newTags.splice(newPos, 0, this.toItag(tag));
            // Updating HTML is dependent upon state having most up to date
            // values. Setting filtered state and then setting state with
            // updated HTML in tags
            this.setState({
                tags: newTags,
            }, () => this.props.onChange(this.state.tags));
            this.blurInput();
        };
        // Tag Operations
        /**
         * Adds new tag to state with necessary HTML for rendering
         * Sets the color of the tag to next color, rotates through each
         * @param reactTag - IReactTag - new tag to add to state
         */
        this.handleAddition = (reactTag) => {
            const tag = this.toItag(reactTag);
            const inputElement = document.querySelector(".ReactTags__tagInputField");
            const tagColors = this.getTagColors();
            const tagColorKeys = Object.keys(tagColors);
            tag.color = tagColors[tagColorKeys[this.state.currentTagColorIndex]];
            const currentTags = (this.state.tags && this.state.tags.length) ? this.state.tags : [];
            this.setState((prevState) => {
                return {
                    tags: [...currentTags, tag],
                    currentTagColorIndex: (prevState.currentTagColorIndex + 1) % tagColorKeys.length,
                };
            }, () => this.props.onChange(this.state.tags));
            if (inputElement) {
                setImmediate(() => inputElement.focus());
            }
        };
        /**
         * Deletes tag from state
         * Explicitly prevents deletion with backspace key
         * @param i index of tag being deleted
         * @param event delete event
         */
        this.handleDelete = (i, event) => {
            if (event.keyCode === utils_1.KeyCodes.backspace) {
                return;
            }
            const deletedTag = this.state.tags[i];
            if (this.props.onTagDelete) {
                this.props.onTagDelete(deletedTag);
            }
            const tags = this.state.tags.filter((tag, index) => index !== i);
            // Updating HTML is dependent upon state having most up to date
            // values. Setting filtered state and then setting state with
            // updated HTML in tags
            this.setState({
                tags,
            }, () => this.props.onChange(this.state.tags));
            this.blurInput();
        };
        /**
         * Converts ITag to IReactTag
         * @param tag ITag to convert to IReactTag
         */
        this.toReactTag = (tag) => {
            if (!tag) {
                return null;
            }
            return {
                id: tag.name,
                text: this.ReactTagHtml(tag.name, tag.color),
                color: tag.color,
            };
        };
        /**
         * Adds necessary HTML for tag to render correctly
         * @param tag tag needing Html
         */
        this.addHtml = (tag) => {
            tag.text = this.ReactTagHtml(tag.id, tag.color);
        };
        /**
         * Convert array of ITags to IReactTags
         * @param props properties for component, contains tags in ITag format
         */
        this.toReactTags = (tags) => {
            return tags ? tags.map((element) => this.toReactTag(element)) : [];
        };
        /**
         * Convert array of IReactTags to ITags
         * @param tags array of IReactTags to convert to ITags
         */
        this.toITags = (tags) => {
            return tags.map((element) => this.toItag(element));
        };
        /**
         * Converts IReactTag to ITag
         * @param tag IReactTag to convert to ITag
         */
        this.toItag = (tag) => {
            if (!tag) {
                return null;
            }
            return {
                name: tag.id,
                color: tag.color,
            };
        };
        this.blurInput = () => {
            const inputElement = document.querySelector(".ReactTags__tagInputField");
            if (inputElement) {
                setImmediate(() => inputElement.blur());
            }
        };
    }
    render() {
        const { tags } = this.state;
        return (react_1.default.createElement("div", null,
            react_1.default.createElement(react_tag_input_1.WithContext, { ref: "reactTagsInput", tags: this.toReactTags(this.state.tags), placeholder: this.props.placeHolder || exports.defaultValues.placeHolder, autofocus: false, allowAdditionFromPaste: false, handleDelete: this.handleDelete, handleAddition: this.handleAddition, handleDrag: this.handleDrag, id: "tagInputField", delimiters: this.props.delimiters || exports.defaultValues.delimiters })));
    }
    componentDidMount() {
        this.setState({
            currentTagColorIndex: utils_1.randomIntInRange(0, this.getTagColorKeys().length),
        });
    }
    componentDidUpdate(prevProps) {
        if (prevProps.tags !== this.props.tags) {
            this.setState({
                tags: this.props.tags,
            });
        }
    }
    /**
     * Gets tag ID (name) from a click event
     * @param event Click event
     */
    getTagIdFromClick(event) {
        const attrValue = event.currentTarget.getAttribute("data-tag-name");
        return attrValue ? attrValue.trim() : null;
    }
}
exports.TagsInput = TagsInput;
