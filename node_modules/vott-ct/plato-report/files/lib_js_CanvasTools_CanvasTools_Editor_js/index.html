<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - lib/js/CanvasTools/CanvasTools.Editor.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>lib/js/CanvasTools/CanvasTools.Editor.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">69.34</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">509</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">70.03</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">4.87</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&quot;use strict&quot;;
Object.defineProperty(exports, &quot;__esModule&quot;, { value: true });
const CanvasTools_Filter_1 = require(&quot;./CanvasTools.Filter&quot;);
const Rect_1 = require(&quot;./Core/Rect&quot;);
const RegionsManager_1 = require(&quot;./Region/RegionsManager&quot;);
const AreaSelector_1 = require(&quot;./Selection/AreaSelector&quot;);
const ToolbarIcon_1 = require(&quot;./Toolbar/ToolbarIcon&quot;);
const Toolbar_1 = require(&quot;./Toolbar/Toolbar&quot;);
/**
 * Wraps internal CanvasTools components into one Editor experience.
 */
class Editor {
    constructor(container, areaSelector, regionsManager, filterPipeline) {
        /**
         * Auto-resize flag to automatically update editor internals when the container (window) size is changed.
         */
        this.autoResize = true;
        /**
         * Internal reference to the RegionsManager freezing state.
         */
        this.isRMFrozen = false;
        // Create SVG Element
        this.contentCanvas = this.createCanvasElement();
        this.editorSVG = this.createSVGElement();
        this.editorDiv = container;
        this.editorDiv.classList.add(&quot;CanvasToolsEditor&quot;);
        this.editorDiv.append(this.contentCanvas);
        this.editorDiv.append(this.editorSVG);
        // automatically resize internals on window resize
        window.addEventListener(&quot;resize&quot;, (e) =&gt; {
            if (this.autoResize) {
                this.resize(this.editorDiv.offsetWidth, this.editorDiv.offsetHeight);
            }
        });
        // Init regionsManager
        const rmCallbacks = {
            onChange: null,
            onManipulationBegin: (region) =&gt; {
                this.areaSelector.hide();
                if (typeof this.onManipulationBegin === &quot;function&quot;) {
                    this.onManipulationBegin(region);
                }
            },
            onManipulationEnd: (region) =&gt; {
                this.areaSelector.show();
                if (typeof this.onManipulationEnd === &quot;function&quot;) {
                    this.onManipulationEnd(region);
                }
            },
            onRegionSelected: (id, multiselection) =&gt; {
                if (typeof this.onRegionSelected === &quot;function&quot;) {
                    this.onRegionSelected(id, multiselection);
                }
            },
            onRegionMove: (id, regionData) =&gt; {
                if (typeof this.onRegionMove === &quot;function&quot;) {
                    this.onRegionMove(id, regionData);
                }
            },
            onRegionMoveBegin: (id, regionData) =&gt; {
                if (typeof this.onRegionMoveBegin === &quot;function&quot;) {
                    this.onRegionMoveBegin(id, regionData);
                }
            },
            onRegionMoveEnd: (id, regionData) =&gt; {
                if (typeof this.onRegionMoveEnd === &quot;function&quot;) {
                    this.onRegionMoveEnd(id, regionData);
                }
            },
            onRegionDelete: (id, regionData) =&gt; {
                if (typeof this.onRegionDelete === &quot;function&quot;) {
                    this.onRegionDelete(id, regionData);
                }
            },
        };
        if (regionsManager !== null &amp;&amp; regionsManager !== undefined) {
            this.regionsManager = regionsManager;
            regionsManager.callbacks = rmCallbacks;
        }
        else {
            this.regionsManager = new RegionsManager_1.RegionsManager(this.editorSVG, rmCallbacks);
        }
        // Init areaSeletor
        const asCallbacks = {
            onSelectionBegin: () =&gt; {
                this.isRMFrozen = this.regionsManager.isFrozen;
                this.regionsManager.freeze();
                if (typeof this.onSelectionBegin === &quot;function&quot;) {
                    this.onSelectionBegin();
                }
            },
            onSelectionEnd: (regionData) =&gt; {
                if (!this.isRMFrozen) {
                    this.regionsManager.unfreeze();
                }
                if (typeof this.onSelectionEnd === &quot;function&quot;) {
                    this.onSelectionEnd(regionData);
                }
            },
        };
        if (areaSelector !== null &amp;&amp; areaSelector !== undefined) {
            this.areaSelector = areaSelector;
            this.areaSelector.callbacks = asCallbacks;
        }
        else {
            this.areaSelector = new AreaSelector_1.AreaSelector(this.editorSVG, asCallbacks);
        }
        // Init filterPipeline
        if (filterPipeline !== undefined &amp;&amp; filterPipeline !== null) {
            this.filterPipeline = filterPipeline;
        }
        else {
            this.filterPipeline = new CanvasTools_Filter_1.FilterPipeline();
        }
        // Adjust editor size
        this.resize(container.offsetWidth, container.offsetHeight);
        // Add proxy to regionsManager, areaSelector and filterPipeline;
        this.mergedAPI = new Proxy(this, {
            get: (target, prop) =&gt; {
                let p;
                let t;
                if (prop in target) {
                    t = target;
                    p = t[prop];
                }
                else if (prop in target.regionsManager) {
                    t = target.RM;
                    p = t[prop];
                }
                else if (prop in target.areaSelector) {
                    t = target.AS;
                    p = t[prop];
                }
                else if (prop in target.filterPipeline) {
                    t = target.FP;
                    p = t[prop];
                }
                else {
                    p = undefined;
                }
                if (typeof p === &quot;function&quot;) {
                    return (...args) =&gt; {
                        p.apply(t, args);
                    };
                }
                else {
                    return p;
                }
            },
        });
    }
    /**
     * A proxi wrapper around internal API for the `Editor` itself, `RegionsManager` (`RM`), `AreaSelector` (`AS`) and
     * `FilterPipeline` (`FP`).
     * @remarks As of now those apis do not overlap, so all methods/properties might be mapped from unified API.
     */
    get api() {
        return this.mergedAPI;
    }
    /**
     * Creates a new toolbar in specified div-container
     * @param container - The div-container for the toolbar.
     * @param toolbarSet - Icons set for the toolbar.
     * @param iconsPath - Path to the toolbar icons.
     */
    addToolbar(container, toolbarSet, iconsPath) {
        const svg = this.createSVGElement();
        container.append(svg);
        this.toolbar = new Toolbar_1.Toolbar(svg);
        if (toolbarSet === null) {
            toolbarSet = Editor.FullToolbarSet;
        }
        let activeSelector;
        toolbarSet.forEach((item) =&gt; {
            if (item.type === ToolbarIcon_1.ToolbarItemType.SEPARATOR) {
                this.toolbar.addSeparator();
            }
            else if (item.type === ToolbarIcon_1.ToolbarItemType.SELECTOR) {
                this.toolbar.addSelector({
                    action: item.action,
                    iconUrl: iconsPath + item.iconFile,
                    tooltip: item.tooltip,
                    keycode: item.keycode,
                    width: item.width,
                    height: item.height,
                }, (action) =&gt; {
                    item.actionCallback(action, this.regionsManager, this.areaSelector);
                });
                if (item.activate) {
                    activeSelector = item.action;
                }
            }
            else if (item.type === ToolbarIcon_1.ToolbarItemType.SWITCH) {
                this.toolbar.addSwitch({
                    action: item.action,
                    iconUrl: iconsPath + item.iconFile,
                    tooltip: item.tooltip,
                    keycode: item.keycode,
                    width: item.width,
                    height: item.height,
                }, (action) =&gt; {
                    item.actionCallback(action, this.regionsManager, this.areaSelector);
                });
                this.toolbar.setSwitch(item.action, item.activate);
            }
        });
        this.toolbar.select(activeSelector);
    }
    /**
     * Updates the content source for the editor.
     * @param source - Content source.
     * @returns A new `Promise` resolved when content is drawn and Editor is resized.
     */
    async addContentSource(source) {
        const buffCnvs = document.createElement(&quot;canvas&quot;);
        const context = buffCnvs.getContext(&quot;2d&quot;);
        if (source instanceof HTMLImageElement || source instanceof HTMLCanvasElement) {
            this.sourceWidth = source.width;
            this.sourceHeight = source.height;
        }
        else if (source instanceof HTMLVideoElement) {
            this.sourceWidth = source.videoWidth;
            this.sourceHeight = source.videoHeight;
        }
        buffCnvs.width = this.sourceWidth;
        buffCnvs.height = this.sourceHeight;
        context.drawImage(source, 0, 0, buffCnvs.width, buffCnvs.height);
        return this.filterPipeline.applyToCanvas(buffCnvs).then((bcnvs) =&gt; {
            // Copy buffer to the canvas on screen
            this.contentCanvas.width = bcnvs.width;
            this.contentCanvas.height = bcnvs.height;
            const imgContext = this.contentCanvas.getContext(&quot;2d&quot;);
            imgContext.drawImage(bcnvs, 0, 0, bcnvs.width, bcnvs.height);
        }).then(() =&gt; {
            // resize the editor size to adjust to the new content size
            this.resize(this.editorDiv.offsetWidth, this.editorDiv.offsetHeight);
        });
    }
    /**
     * Resize editor to new width and height.
     * @remarks - Use if the `autoResize` is `false`.
     * @param containerWidth - The new container width.
     * @param containerHeight - The new container height.
     */
    resize(containerWidth, containerHeight) {
        this.frameWidth = containerWidth;
        this.frameHeight = containerHeight;
        const imgRatio = this.contentCanvas.width / this.contentCanvas.height;
        const containerRatio = containerWidth / containerHeight;
        let hpadding = 0;
        let vpadding = 0;
        if (imgRatio &gt; containerRatio) {
            vpadding = (containerHeight - containerWidth / imgRatio) / 2;
            this.editorDiv.style.height = `calc(100% - ${vpadding * 2}px)`;
            this.editorDiv.style.width = &quot;&quot;;
        }
        else {
            hpadding = (containerWidth - containerHeight * imgRatio) / 2;
            this.editorDiv.style.height = &quot;&quot;;
            this.editorDiv.style.width = `calc(100% - ${hpadding * 2}px)`;
        }
        this.editorDiv.style.padding = `${vpadding}px ${hpadding}px`;
        this.frameWidth = this.editorSVG.clientWidth;
        this.frameHeight = this.editorSVG.clientHeight;
        this.areaSelector.resize(this.frameWidth, this.frameHeight);
        this.regionsManager.resize(this.frameWidth, this.frameHeight);
    }
    /**
     * Short reference to the `RegionsManager` component.
     */
    get RM() {
        return this.regionsManager;
    }
    /**
     * Short reference to the `AreaSelector` component.
     */
    get AS() {
        return this.areaSelector;
    }
    /**
     * Short reference to the `FilterPipeline` component.
     */
    get FP() {
        return this.filterPipeline;
    }
    /**
     * Scales the `RegionData` object from frame to source size.
     * @param regionData - The `RegionData` object.
     * @param sourceWidth - [Optional] The source width.
     * @param sourceHeight - [Optional] The source height.
     * @returns Resized `RegionData` object.
     */
    scaleRegionToSourceSize(regionData, sourceWidth, sourceHeight) {
        const sw = (sourceWidth !== undefined) ? sourceWidth : this.sourceWidth;
        const sh = (sourceHeight !== undefined) ? sourceHeight : this.sourceHeight;
        const xf = sw / this.frameWidth;
        const yf = sh / this.frameHeight;
        const rd = regionData.copy();
        rd.scale(xf, yf);
        return rd;
    }
    /**
     * Scales the `RegionData` object from source to frame size.
     * @param regionData - The `RegionData` object.
     * @param sourceWidth - [Optional] The source width.
     * @param sourceHeight - [Optional] The source height.
     * @returns Resized `RegionData` object.
     */
    scaleRegionToFrameSize(regionData, sourceWidth, sourceHeight) {
        const sw = (sourceWidth !== undefined) ? sourceWidth : this.sourceWidth;
        const sh = (sourceHeight !== undefined) ? sourceHeight : this.sourceHeight;
        const xf = this.frameWidth / sw;
        const yf = this.frameHeight / sh;
        const rd = regionData.copy();
        rd.scale(xf, yf);
        return rd;
    }
    /**
     * Internal helper to create a new SVG element.
     */
    createSVGElement() {
        const svg = document.createElementNS(&quot;http://www.w3.org/2000/svg&quot;, &quot;svg&quot;);
        svg.innerHTML = Editor.SVGDefsTemplate;
        return svg;
    }
    /**
     * Internal helper to create a new HTMLCanvas element.
     */
    createCanvasElement() {
        const canvas = document.createElement(&quot;canvas&quot;);
        return canvas;
    }
}
/**
 * The toolbar icons preset with all available features.
 */
Editor.FullToolbarSet = [
    {
        type: ToolbarIcon_1.ToolbarItemType.SELECTOR,
        action: &quot;none-select&quot;,
        iconFile: &quot;none-selection.svg&quot;,
        tooltip: &quot;Regions Manipulation (M)&quot;,
        keycode: &quot;KeyM&quot;,
        actionCallback: (action, rm, sl) =&gt; {
            sl.setSelectionMode(AreaSelector_1.SelectionMode.NONE);
        },
        activate: false,
    },
    {
        type: ToolbarIcon_1.ToolbarItemType.SEPARATOR,
    },
    {
        type: ToolbarIcon_1.ToolbarItemType.SELECTOR,
        action: &quot;point-select&quot;,
        iconFile: &quot;point-selection.svg&quot;,
        tooltip: &quot;Point-selection (P)&quot;,
        keycode: &quot;KeyP&quot;,
        actionCallback: (action, rm, sl) =&gt; {
            sl.setSelectionMode(AreaSelector_1.SelectionMode.POINT);
        },
        activate: false,
    },
    {
        type: ToolbarIcon_1.ToolbarItemType.SELECTOR,
        action: &quot;rect-select&quot;,
        iconFile: &quot;rect-selection.svg&quot;,
        tooltip: &quot;Rectangular box (R)&quot;,
        keycode: &quot;KeyR&quot;,
        actionCallback: (action, rm, sl) =&gt; {
            sl.setSelectionMode(AreaSelector_1.SelectionMode.RECT);
        },
        activate: true,
    },
    {
        type: ToolbarIcon_1.ToolbarItemType.SELECTOR,
        action: &quot;copy-select&quot;,
        iconFile: &quot;copy-t-selection.svg&quot;,
        tooltip: &quot;Template-based box (T)&quot;,
        keycode: &quot;KeyT&quot;,
        actionCallback: (action, rm, sl) =&gt; {
            const rs = rm.getSelectedRegionsBounds();
            if (rs !== undefined &amp;&amp; rs.length &gt; 0) {
                const r = rs[0];
                sl.setSelectionMode(AreaSelector_1.SelectionMode.COPYRECT, { template: new Rect_1.Rect(r.width, r.height) });
            }
            else {
                sl.setSelectionMode(AreaSelector_1.SelectionMode.COPYRECT, { template: new Rect_1.Rect(40, 40) });
            }
        },
        activate: false,
    },
    {
        type: ToolbarIcon_1.ToolbarItemType.SELECTOR,
        action: &quot;polyline-select&quot;,
        iconFile: &quot;polyline-selection.svg&quot;,
        tooltip: &quot;Polyline-selection (Y)&quot;,
        keycode: &quot;KeyY&quot;,
        actionCallback: (action, rm, sl) =&gt; {
            sl.setSelectionMode(AreaSelector_1.SelectionMode.POLYLINE);
        },
        activate: false,
    },
    {
        type: ToolbarIcon_1.ToolbarItemType.SELECTOR,
        action: &quot;polygon-select&quot;,
        iconFile: &quot;polygon-selection.svg&quot;,
        tooltip: &quot;Polygon-selection (O)&quot;,
        keycode: &quot;KeyO&quot;,
        actionCallback: (action, rm, sl) =&gt; {
            sl.setSelectionMode(AreaSelector_1.SelectionMode.POLYGON);
        },
        activate: false,
    },
    {
        type: ToolbarIcon_1.ToolbarItemType.SEPARATOR,
    },
    {
        type: ToolbarIcon_1.ToolbarItemType.SWITCH,
        action: &quot;selection-lock&quot;,
        iconFile: &quot;selection-lock.svg&quot;,
        tooltip: &quot;Lock/unlock regions (L)&quot;,
        keycode: &quot;KeyL&quot;,
        actionCallback: (action, rm, sl) =&gt; {
            rm.toggleFreezeMode();
        },
        activate: false,
    },
];
/**
 * The toolbar icons preset with only rect-related features.
 */
Editor.RectToolbarSet = [
    {
        type: ToolbarIcon_1.ToolbarItemType.SELECTOR,
        action: &quot;none-select&quot;,
        iconFile: &quot;none-selection.svg&quot;,
        tooltip: &quot;Regions Manipulation (M)&quot;,
        keycode: &quot;KeyM&quot;,
        actionCallback: (action, rm, sl) =&gt; {
            sl.setSelectionMode(AreaSelector_1.SelectionMode.NONE);
        },
        activate: false,
    },
    {
        type: ToolbarIcon_1.ToolbarItemType.SEPARATOR,
    },
    {
        type: ToolbarIcon_1.ToolbarItemType.SELECTOR,
        action: &quot;rect-select&quot;,
        iconFile: &quot;rect-selection.svg&quot;,
        tooltip: &quot;Rectangular box (R)&quot;,
        keycode: &quot;KeyR&quot;,
        actionCallback: (action, rm, sl) =&gt; {
            sl.setSelectionMode(AreaSelector_1.SelectionMode.RECT);
        },
        activate: true,
    },
    {
        type: ToolbarIcon_1.ToolbarItemType.SELECTOR,
        action: &quot;copy-select&quot;,
        iconFile: &quot;copy-t-selection.svg&quot;,
        tooltip: &quot;Template-based box (T)&quot;,
        keycode: &quot;KeyT&quot;,
        actionCallback: (action, rm, sl) =&gt; {
            const rs = rm.getSelectedRegionsBounds();
            if (rs !== undefined &amp;&amp; rs.length &gt; 0) {
                const r = rs[0];
                sl.setSelectionMode(AreaSelector_1.SelectionMode.COPYRECT, { template: new Rect_1.Rect(r.width, r.height) });
            }
            else {
                sl.setSelectionMode(AreaSelector_1.SelectionMode.COPYRECT, { template: new Rect_1.Rect(40, 40) });
            }
        },
        activate: false,
    },
    {
        type: ToolbarIcon_1.ToolbarItemType.SEPARATOR,
    },
    {
        type: ToolbarIcon_1.ToolbarItemType.SWITCH,
        action: &quot;selection-lock&quot;,
        iconFile: &quot;selection-lock.svg&quot;,
        tooltip: &quot;Lock/unlock regions (L)&quot;,
        keycode: &quot;KeyL&quot;,
        actionCallback: (action, rm, sl) =&gt; {
            rm.toggleFreezeMode();
        },
        activate: false,
    },
];
/**
 * Internal SVG template to define shadow filter.
 */
Editor.SVGDefsTemplate = `
        &lt;defs&gt;
            &lt;filter id=&quot;black-glow&quot;&gt;
                &lt;feGaussianBlur in=&quot;SourceAlpha&quot; stdDeviation=&quot;2&quot; /&gt;
                &lt;feOffset dx=&quot;0&quot; dy=&quot;0&quot; result=&quot;offsetblur&quot; /&gt;
                &lt;feComponentTransfer&gt;
                    &lt;feFuncA type=&quot;linear&quot; slope=&quot;0.8&quot; /&gt;
                &lt;/feComponentTransfer&gt;
                &lt;feMerge&gt;
                    &lt;feMergeNode /&gt;
                    &lt;feMergeNode in=&quot;SourceGraphic&quot; /&gt;
                &lt;/feMerge&gt;
            &lt;/filter&gt;
        &lt;/defs&gt;`;
exports.Editor = Editor;
//# sourceMappingURL=CanvasTools.Editor.js.map</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
