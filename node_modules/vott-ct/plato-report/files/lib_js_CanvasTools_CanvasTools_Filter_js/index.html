<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - lib/js/CanvasTools/CanvasTools.Filter.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato.css" rel="stylesheet" type="text/css">
  <link href="../../assets/css/plato-file.css" rel="stylesheet" type="text/css">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="https://github.com/the-simian/es6-plato">ES6 Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
      <li class="active">
        <a href="display.html">Summary Display</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>lib/js/CanvasTools/CanvasTools.Filter.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">61.15</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">388</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">130.51</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">4.93</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&quot;use strict&quot;;
Object.defineProperty(exports, &quot;__esModule&quot;, { value: true });
/**
 * Invertion filter.
 * @param canvas - Source HTMLCanvas element.
 */
function InvertFilter(canvas) {
    const context = canvas.getContext(&quot;2d&quot;);
    const imageData = context.getImageData(0, 0, canvas.width, canvas.height);
    const buff = document.createElement(&quot;canvas&quot;);
    buff.width = canvas.width;
    buff.height = canvas.height;
    const data = imageData.data;
    for (let i = 0; i &lt; data.length; i += 4) {
        data[i] = 255 - data[i]; // red
        data[i + 1] = 255 - data[i + 1]; // green
        data[i + 2] = 255 - data[i + 2]; // blue
    }
    buff.getContext(&quot;2d&quot;).putImageData(imageData, 0, 0);
    return new Promise((resolve, reject) =&gt; {
        return resolve(buff);
    });
}
exports.InvertFilter = InvertFilter;
/**
 * Grayscale filter.
 * @param canvas - Source HTMLCanvas element.
 */
function GrayscaleFilter(canvas) {
    const context = canvas.getContext(&quot;2d&quot;);
    const imageData = context.getImageData(0, 0, canvas.width, canvas.height);
    const buff = document.createElement(&quot;canvas&quot;);
    buff.width = canvas.width;
    buff.height = canvas.height;
    const data = imageData.data;
    for (let i = 0; i &lt; data.length; i += 4) {
        const gray = 0.2126 * data[i] + 0.7152 * data[i + 1] + 0.0722 * data[i + 2];
        data[i] = gray; // red
        data[i + 1] = gray; // green
        data[i + 2] = gray; // blue
    }
    buff.getContext(&quot;2d&quot;).putImageData(imageData, 0, 0);
    return new Promise((resolve, reject) =&gt; {
        return resolve(buff);
    });
}
exports.GrayscaleFilter = GrayscaleFilter;
/**
 * Experimental blur difference filter.
 * @param factor - Bluring factor (in pixels).
 */
function BlurDiffFilter(factor) {
    // http://blog.ivank.net/fastest-gaussian-blur.html
    function boxesForGauss(sigma, n) {
        const wIdeal = Math.sqrt((12 * sigma * sigma / n) + 1); // Ideal averaging filter width
        let wl = Math.floor(wIdeal);
        if (wl % 2 === 0) {
            wl--;
        }
        const wu = wl + 2;
        const mIdeal = (12 * sigma * sigma - n * wl * wl - 4 * n * wl - 3 * n) / (-4 * wl - 4);
        const m = Math.round(mIdeal);
        // var sigmaActual = Math.sqrt( (m*wl*wl + (n-m)*wu*wu - n)/12 );
        const sizes = [];
        for (let i = 0; i &lt; n; i++) {
            sizes.push(i &lt; m ? wl : wu);
        }
        return sizes;
    }
    function gaussBlur_4(scl, tcl, w, h, r) {
        const bxs = boxesForGauss(r, 3);
        boxBlur_4(scl, tcl, w, h, (bxs[0] - 1) / 2);
        boxBlur_4(tcl, scl, w, h, (bxs[1] - 1) / 2);
        boxBlur_4(scl, tcl, w, h, (bxs[2] - 1) / 2);
    }
    function boxBlur_4(scl, tcl, w, h, r) {
        for (let i = 0; i &lt; scl.length; i++) {
            tcl[i] = scl[i];
        }
        boxBlurH_4(tcl, scl, w, h, r);
        boxBlurT_4(scl, tcl, w, h, r);
    }
    function boxBlurH_4(scl, tcl, w, h, r) {
        const iarr = 1 / (r + r + 1);
        for (let i = 0; i &lt; h; i++) {
            let ti = i * w;
            let li = ti;
            let ri = ti + r;
            const fv = scl[ti];
            const lv = scl[ti + w - 1];
            let val = (r + 1) * fv;
            for (let j = 0; j &lt; r; j++) {
                val += scl[ti + j];
            }
            for (let j = 0; j &lt;= r; j++) {
                val += scl[ri++] - fv;
                tcl[ti++] = Math.round(val * iarr);
            }
            for (let j = r + 1; j &lt; w - r; j++) {
                val += scl[ri++] - scl[li++];
                tcl[ti++] = Math.round(val * iarr);
            }
            for (let j = w - r; j &lt; w; j++) {
                val += lv - scl[li++];
                tcl[ti++] = Math.round(val * iarr);
            }
        }
    }
    function boxBlurT_4(scl, tcl, w, h, r) {
        const iarr = 1 / (r + r + 1);
        for (let i = 0; i &lt; w; i++) {
            let ti = i;
            let li = ti;
            let ri = ti + r * w;
            const fv = scl[ti];
            const lv = scl[ti + w * (h - 1)];
            let val = (r + 1) * fv;
            for (let j = 0; j &lt; r; j++) {
                val += scl[ti + j * w];
            }
            for (let j = 0; j &lt;= r; j++) {
                val += scl[ri] - fv;
                tcl[ti] = Math.round(val * iarr);
                ri += w;
                ti += w;
            }
            for (let j = r + 1; j &lt; h - r; j++) {
                val += scl[ri] - scl[li];
                tcl[ti] = Math.round(val * iarr);
                li += w;
                ri += w;
                ti += w;
            }
            for (let j = h - r; j &lt; h; j++) {
                val += lv - scl[li];
                tcl[ti] = Math.round(val * iarr);
                li += w;
                ti += w;
            }
        }
    }
    return (canvas) =&gt; {
        const context = canvas.getContext(&quot;2d&quot;);
        const imageData = context.getImageData(0, 0, canvas.width, canvas.height);
        const buff = document.createElement(&quot;canvas&quot;);
        buff.width = canvas.width;
        buff.height = canvas.height;
        const bludData = buff.getContext(&quot;2d&quot;).createImageData(buff.width, buff.height);
        const idata = imageData.data;
        const bdata = bludData.data;
        const pixelsNumber = canvas.width * canvas.height;
        const dataR = new Uint8ClampedArray(pixelsNumber);
        const dataG = new Uint8ClampedArray(pixelsNumber);
        const dataB = new Uint8ClampedArray(pixelsNumber);
        const dataA = new Uint8ClampedArray(pixelsNumber);
        for (let i = 0; i &lt; pixelsNumber; i++) {
            dataR[i] = idata[4 * i];
            dataG[i] = idata[4 * i + 1];
            dataB[i] = idata[4 * i + 2];
            dataA[i] = idata[4 * i + 3];
        }
        const blurR = new Uint8ClampedArray(pixelsNumber);
        const blurG = new Uint8ClampedArray(pixelsNumber);
        const blurB = new Uint8ClampedArray(pixelsNumber);
        const blurR2 = new Uint8ClampedArray(pixelsNumber);
        const blurG2 = new Uint8ClampedArray(pixelsNumber);
        const blurB2 = new Uint8ClampedArray(pixelsNumber);
        // let blurA = new Uint8ClampedArray(pixelsNumber);
        const halfFactor = factor / 2;
        gaussBlur_4(dataR, blurR, buff.width, buff.height, halfFactor);
        gaussBlur_4(dataG, blurG, buff.width, buff.height, halfFactor);
        gaussBlur_4(dataB, blurB, buff.width, buff.height, halfFactor);
        gaussBlur_4(dataR, blurR2, buff.width, buff.height, factor);
        gaussBlur_4(dataG, blurG2, buff.width, buff.height, factor);
        gaussBlur_4(dataB, blurB2, buff.width, buff.height, factor);
        const alphaStep = 127 / factor;
        for (let i = 0; i &lt; pixelsNumber; i++) {
            const dr = Math.abs(blurR2[i] - blurR[i]);
            const dg = Math.abs(blurG2[i] - blurG[i]);
            const db = Math.abs(blurB2[i] - blurB[i]);
            // const d = 0.2126 * dr + 0.7152 * dg + 0.0722 * db;
            const d = 0.2358 * dr + 0.0700 * dg + 0.6742 * db;
            /* let dr = Math.abs(blurR2[i] - idata[4 * i + 0]);
            let dg = Math.abs(blurG2[i] - idata[4 * i + 1]);
            let db = Math.abs(blurB2[i] - idata[4 * i + 2]); */
            // let d = 255 - Math.min(Math.round(Math.max(dr + dg + db - 16, 0)/8) * 16, 255);
            /* bdata[4 * i + 0] = d;
            bdata[4 * i + 1] = d;
            bdata[4 * i + 2] = d; */
            /* bdata[4 * i + 0] = (d &lt; factor) ? Math.round(idata[4 * i + 0] / factor) * factor : idata[4 * i + 0];
            bdata[4 * i + 1] = (d &lt; factor) ? Math.round(idata[4 * i + 1] / factor) * factor : idata[4 * i + 1];
            bdata[4 * i + 2] = (d &lt; factor) ? Math.round(idata[4 * i + 2] / factor) * factor : idata[4 * i + 2]; */
            /* bdata[4 * i + 0] = (dr &gt;= 0.2126 * factor) ?
                                idata[4 * i + 0] :  Math.round(idata[4 * i + 0] / factor) * factor;
            bdata[4 * i + 1] = (dg &gt;= 0.7152 * factor) ?
                                idata[4 * i + 1] :  Math.round(idata[4 * i + 1] / factor) * factor;
            bdata[4 * i + 2] = (db &gt;= 0.0722 * factor) ?
                                idata[4 * i + 2] :  Math.round(idata[4 * i + 2] / factor) * factor; */
            const g = Math.round(0.2358 * idata[4 * i + 0] + 0.0700 * idata[4 * i + 1] + 0.6742 * idata[4 * i + 2]);
            bdata[4 * i + 0] = (dr &gt;= 0.2358 * halfFactor) ?
                idata[4 * i + 0] : Math.round(g / factor) * factor;
            bdata[4 * i + 1] = (dg &gt;= 0.0700 * halfFactor) ?
                idata[4 * i + 1] : Math.round(g / factor) * factor;
            bdata[4 * i + 2] = (db &gt;= 0.6742 * halfFactor) ?
                idata[4 * i + 2] : Math.round(g / factor) * factor;
            /* bdata[4 * i + 0] = Math.round(idata[4 * i + 0] / 8) * 8;
            bdata[4 * i + 1] = Math.round(idata[4 * i + 1] / 8) * 8;
            bdata[4 * i + 2] = Math.round(idata[4 * i + 2] / 8) * 8; */
            bdata[4 * i + 3] = (d &gt;= factor) ? 255 : 0 + Math.round(d * alphaStep);
        }
        buff.getContext(&quot;2d&quot;).putImageData(bludData, 0, 0);
        return new Promise((resolve, reject) =&gt; {
            return resolve(buff);
        });
    };
}
exports.BlurDiffFilter = BlurDiffFilter;
/**
 * Brightness filter.
 * @param brightness - The brightness value in the range [0, 255] to be added to pixels.
 */
function BrightnessFilter(brightness) {
    return (canvas) =&gt; {
        const context = canvas.getContext(&quot;2d&quot;);
        const imageData = context.getImageData(0, 0, canvas.width, canvas.height);
        const buff = document.createElement(&quot;canvas&quot;);
        buff.width = canvas.width;
        buff.height = canvas.height;
        const data = imageData.data;
        for (let i = 0; i &lt; data.length; i += 4) {
            data[i + 0] = Math.max(0, Math.min(data[i + 0] + brightness, 255));
            data[i + 1] = Math.max(0, Math.min(data[i + 1] + brightness, 255));
            data[i + 2] = Math.max(0, Math.min(data[i + 2] + brightness, 255));
        }
        buff.getContext(&quot;2d&quot;).putImageData(imageData, 0, 0);
        return new Promise((resolve, reject) =&gt; {
            return resolve(buff);
        });
    };
}
exports.BrightnessFilter = BrightnessFilter;
/**
 * Contrast filter.
 * @param contrast - The contrast factor in the range [-255, 255] to be applied to pixels.
 */
function ContrastFilter(contrast) {
    return (canvas) =&gt; {
        const context = canvas.getContext(&quot;2d&quot;);
        const imageData = context.getImageData(0, 0, canvas.width, canvas.height);
        const buff = document.createElement(&quot;canvas&quot;);
        buff.width = canvas.width;
        buff.height = canvas.height;
        const data = imageData.data;
        const factor = (259 * (contrast + 255)) / (255 * (259 - contrast));
        for (let i = 0; i &lt; data.length; i += 4) {
            data[i + 0] = factor * (data[i] - 128) + 128;
            data[i + 1] = factor * (data[i + 1] - 128) + 128;
            data[i + 2] = factor * (data[i + 2] - 128) + 128;
        }
        buff.getContext(&quot;2d&quot;).putImageData(imageData, 0, 0);
        return new Promise((resolve, reject) =&gt; {
            return resolve(buff);
        });
    };
}
exports.ContrastFilter = ContrastFilter;
/**
 * Saturation filter
 * @param saturation - The saturation factor in the range [0, 255] to be applied to pixels.
 */
function SaturationFilter(saturation) {
    return (canvas) =&gt; {
        const context = canvas.getContext(&quot;2d&quot;);
        const imageData = context.getImageData(0, 0, canvas.width, canvas.height);
        const buff = document.createElement(&quot;canvas&quot;);
        buff.width = canvas.width;
        buff.height = canvas.height;
        const s = saturation / 255;
        const data = imageData.data;
        for (let i = 0; i &lt; data.length; i += 4) {
            const r = data[i + 0];
            const g = data[i + 1];
            const b = data[i + 2];
            const gr = 0.213 * r + 0.715 * g + 0.072 * b;
            const nr = gr + s * (+0.787 * r - 0.715 * g - 0.072 * b);
            const ng = gr + s * (-0.213 * r + 0.285 * g - 0.072 * b);
            const nb = gr + s * (-0.213 * r - 0.715 * g + 0.928 * b);
            data[i] = Math.round(nr); // red
            data[i + 1] = Math.round(ng); // green
            data[i + 2] = Math.round(nb); // blue
        }
        buff.getContext(&quot;2d&quot;).putImageData(imageData, 0, 0);
        return new Promise((resolve, reject) =&gt; {
            return resolve(buff);
        });
    };
}
exports.SaturationFilter = SaturationFilter;
/*     convoluteFilter(canvas, weights, opaque) {
        var context = canvas.getContext(&#039;2d&#039;);
        var imageData = context.getImageData(0, 0, canvas.width, canvas.height);

        var side = Math.round(Math.sqrt(weights.length));
        var halfSide = Math.floor(side/2);
        var src = imageData.data;
        var sw = imageData.width;
        var sh = imageData.height;
        // pad output by the convolution matrix
        var w = sw;
        var h = sh;
        var output = new ImageData(w, h);

        var dst = output.data;
        // go through the destination image pixels
        var alphaFac = opaque ? 1 : 0;
        for (var y=0; y&lt;h; y++) {
            for (var x=0; x&lt;w; x++) {
                var sy = y;
                var sx = x;
                var dstOff = (y*w+x)*4;
                // calculate the weighed sum of the source image pixels that
                // fall under the convolution matrix
                var r=0, g=0, b=0, a=0;
                for (var cy=0; cy&lt;side; cy++) {
                    for (var cx=0; cx&lt;side; cx++) {
                        var scy = sy + cy - halfSide;
                        var scx = sx + cx - halfSide;
                        if (scy &gt;= 0 &amp;&amp; scy &lt; sh &amp;&amp; scx &gt;= 0 &amp;&amp; scx &lt; sw) {
                            var srcOff = (scy*sw+scx)*4;
                            var wt = weights[cy*side+cx];
                            r += src[srcOff] * wt;
                            g += src[srcOff+1] * wt;
                            b += src[srcOff+2] * wt;
                            a += src[srcOff+3] * wt;
                        }
                    }
                }
                dst[dstOff] = r;
                dst[dstOff+1] = g;
                dst[dstOff+2] = b;
                dst[dstOff+3] = a + alphaFac*(255-a);
            }
        }
        return output;
    } */
/**
 * The `FilterPipeline` class used to create a pipeline of canvas data transformations
 * before displaying it to the user.
 */
class FilterPipeline {
    /**
     * Creates new instance of the `FilterPipeline`.
     */
    constructor() {
        this.pipeline = new Array();
    }
    /**
     * Add new filter function to pipeline.
     * @param filter - A new filter function.
     */
    addFilter(filter) {
        this.pipeline.push(filter);
    }
    /**
     * Clear all the filters in pipeline.
     */
    clearFilters() {
        this.pipeline = new Array();
    }
    /**
     * Apply filters pipeline to provided source canvas.
     * @param canvas - The source HTML Canvas element.
     * @returns A new `Promise` resolved when all filters are applyed.
     */
    applyToCanvas(canvas) {
        let promise = new Promise((resolve, reject) =&gt; {
            return resolve(canvas);
        });
        if (this.pipeline.length &gt; 0) {
            this.pipeline.forEach((filter) =&gt; {
                promise = promise.then(filter);
            });
        }
        return promise;
    }
}
exports.FilterPipeline = FilterPipeline;
//# sourceMappingURL=CanvasTools.Filter.js.map</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
