import { EventsDiscardedReason } from "../JavaScriptSDK.Enums/EventsDiscardedReason";
import { CoreUtils } from "./CoreUtils";
import { NotificationManager } from "./NotificationManager";
import { _InternalLogMessage, DiagnosticLogger } from "./DiagnosticLogger";
"use strict";
var AppInsightsCore = /** @class */ (function () {
    function AppInsightsCore() {
        this._isInitialized = false;
        this._extensions = new Array();
        this._channelController = new ChannelController();
    }
    AppInsightsCore.prototype.initialize = function (config, extensions) {
        var _this = this;
        // Make sure core is only initialized once
        if (this._isInitialized) {
            throw Error("Core should not be initialized more than once");
        }
        if (!config || CoreUtils.isNullOrUndefined(config.instrumentationKey)) {
            throw Error("Please provide instrumentation key");
        }
        this.config = config;
        this._notificationManager = new NotificationManager();
        this.config.extensions = CoreUtils.isNullOrUndefined(this.config.extensions) ? [] : this.config.extensions;
        // add notification to the extensions in the config so other plugins can access it
        this.config.extensionConfig = CoreUtils.isNullOrUndefined(this.config.extensionConfig) ? {} : this.config.extensionConfig;
        this.config.extensionConfig.NotificationManager = this._notificationManager;
        this.logger = new DiagnosticLogger(config);
        // Initial validation
        extensions.forEach(function (extension) {
            if (CoreUtils.isNullOrUndefined(extension.initialize)) {
                throw Error(validationError);
            }
        });
        if (this.config.extensions.length > 0) {
            var isValid_1 = true;
            var containsChannels_1 = false;
            this.config.extensions.forEach(function (item) {
                if (CoreUtils.isNullOrUndefined(item)) {
                    isValid_1 = false;
                }
                if (item.priority > ChannelControllerPriority) {
                    containsChannels_1 = true;
                }
            });
            if (!isValid_1) {
                throw Error(validationError);
            }
            if (containsChannels_1) {
                throw Error(validationErrorInExt);
            }
        }
        // Initial validation complete
        // Concat all available extensions before sorting by priority
        (_a = this._extensions).push.apply(_a, [this._channelController].concat(extensions, this.config.extensions));
        this._extensions = this._extensions.sort(function (a, b) {
            var extA = a;
            var extB = b;
            var typeExtA = typeof extA.processTelemetry;
            var typeExtB = typeof extB.processTelemetry;
            if (typeExtA === 'function' && typeExtB === 'function') {
                return extA.priority - extB.priority;
            }
            if (typeExtA === 'function' && typeExtB !== 'function') {
                // keep non telemetryplugin specific extensions at start
                return 1;
            }
            if (typeExtA !== 'function' && typeExtB === 'function') {
                return -1;
            }
        });
        // sort complete
        // Check if any two extensions have the same priority, then warn to console
        var priority = {};
        this._extensions.forEach(function (ext) {
            var t = ext;
            if (t && t.priority) {
                if (!CoreUtils.isNullOrUndefined(priority[t.priority])) {
                    _this.logger.warnToConsole("Two extensions have same priority" + priority[t.priority] + ", " + t.identifier);
                }
                else {
                    priority[t.priority] = t.identifier; // set a value
                }
            }
        });
        var c = -1;
        // Set next plugin for all until channel controller
        for (var idx = 0; idx < this._extensions.length - 1; idx++) {
            var curr = (this._extensions[idx]);
            if (curr && typeof curr.processTelemetry !== 'function') {
                // these are initialized only, allowing an entry point for extensions to be initialized when SDK initializes
                continue;
            }
            if (curr.priority === ChannelControllerPriority) {
                c = idx + 1;
                break; // channel controller will set remaining pipeline
            }
            this._extensions[idx].setNextPlugin(this._extensions[idx + 1]); // set next plugin
        }
        // initialize channel controller first, this will initialize all channel plugins
        this._channelController.initialize(this.config, this, this._extensions);
        // initialize remaining regular plugins
        this._extensions.forEach(function (ext) {
            var e = ext;
            if (e && e.priority < ChannelControllerPriority) {
                ext.initialize(_this.config, _this, _this._extensions); // initialize
            }
        });
        // Remove sender channels from main list
        if (c < this._extensions.length) {
            this._extensions.splice(c);
        }
        if (this.getTransmissionControls().length === 0) {
            throw new Error("No channels available");
        }
        this._isInitialized = true;
        var _a;
    };
    AppInsightsCore.prototype.getTransmissionControls = function () {
        return this._channelController.ChannelControls;
    };
    AppInsightsCore.prototype.track = function (telemetryItem) {
        if (telemetryItem === null) {
            this._notifiyInvalidEvent(telemetryItem);
            // throw error
            throw Error("Invalid telemetry item");
        }
        if (telemetryItem.baseData && !telemetryItem.baseType) {
            this._notifiyInvalidEvent(telemetryItem);
            throw Error("Provide data.baseType for data.baseData");
        }
        if (!telemetryItem.baseType) {
            // Hard coded from Common::Event.ts::Event.dataType
            telemetryItem.baseType = "EventData";
        }
        if (!telemetryItem.iKey) {
            // setup default iKey if not passed in
            telemetryItem.iKey = this.config.instrumentationKey;
        }
        if (!telemetryItem.time) {
            // add default timestamp if not passed in
            telemetryItem.time = new Date().toISOString();
        }
        if (CoreUtils.isNullOrUndefined(telemetryItem.ver)) {
            // CommonSchema 4.0
            telemetryItem.ver = "4.0";
        }
        // do basic validation before sending it through the pipeline
        this._validateTelmetryItem(telemetryItem);
        this._updateSdkVersion(telemetryItem);
        // invoke any common telemetry processors before sending through pipeline
        var i = 0;
        while (i < this._extensions.length) {
            if (this._extensions[i].processTelemetry) {
                this._extensions[i].processTelemetry(telemetryItem); // pass on to first extension that can support processing
                break;
            }
            i++;
        }
    };
    /**
     * Adds a notification listener. The SDK calls methods on the listener when an appropriate notification is raised.
     * The added plugins must raise notifications. If the plugins do not implement the notifications, then no methods will be
     * called.
     * @param {INotificationListener} listener - An INotificationListener object.
     */
    AppInsightsCore.prototype.addNotificationListener = function (listener) {
        this._notificationManager.addNotificationListener(listener);
    };
    /**
     * Removes all instances of the listener.
     * @param {INotificationListener} listener - INotificationListener to remove.
     */
    AppInsightsCore.prototype.removeNotificationListener = function (listener) {
        this._notificationManager.removeNotificationListener(listener);
    };
    /**
     * Periodically check logger.queue for
     */
    AppInsightsCore.prototype.pollInternalLogs = function () {
        var _this = this;
        var interval = this.config.diagnosticLogInterval;
        if (!(interval > 0)) {
            interval = 10000;
        }
        return setInterval(function () {
            var queue = _this.logger.queue;
            queue.forEach(function (logMessage) {
                var item = {
                    name: "InternalMessageId: " + logMessage.messageId,
                    iKey: _this.config.instrumentationKey,
                    time: new Date().toISOString(),
                    baseType: _InternalLogMessage.dataType,
                    baseData: { message: logMessage.message }
                };
                _this.track(item);
            });
            queue.length = 0;
        }, interval);
    };
    AppInsightsCore.prototype._validateTelmetryItem = function (telemetryItem) {
        if (CoreUtils.isNullOrUndefined(telemetryItem.name)) {
            this._notifiyInvalidEvent(telemetryItem);
            throw Error("telemetry name required");
        }
        if (CoreUtils.isNullOrUndefined(telemetryItem.time)) {
            this._notifiyInvalidEvent(telemetryItem);
            throw Error("telemetry timestamp required");
        }
        if (CoreUtils.isNullOrUndefined(telemetryItem.iKey)) {
            this._notifiyInvalidEvent(telemetryItem);
            throw Error("telemetry instrumentationKey required");
        }
    };
    AppInsightsCore.prototype._updateSdkVersion = function (telemetryItem) {
        if (!telemetryItem.ext) {
            telemetryItem.ext = {};
        }
        if (!telemetryItem.ext.sdk) {
            telemetryItem.ext.sdk = {};
        }
        var version = "";
        for (var i = 0; i < this._extensions.length; i++) {
            var ext = this._extensions[i];
            if (ext.identifier && ext.version) {
                var str = ext.identifier + ":" + ext.version + ";";
                version = version.concat(str);
            }
        }
        if (version != "") {
            telemetryItem.ext.sdk['libVer'] = version;
        }
    };
    AppInsightsCore.prototype._notifiyInvalidEvent = function (telemetryItem) {
        this._notificationManager.eventsDiscarded([telemetryItem], EventsDiscardedReason.InvalidEvent);
    };
    return AppInsightsCore;
}());
export { AppInsightsCore };
var ChannelController = /** @class */ (function () {
    function ChannelController() {
        this.identifier = "ChannelControllerPlugin";
        this.priority = ChannelControllerPriority; // in reserved range 100 to 200
    }
    ChannelController.prototype.processTelemetry = function (item) {
        this.channelQueue.forEach(function (queues) {
            // pass on to first item in queue
            if (queues.length > 0) {
                queues[0].processTelemetry(item);
            }
        });
    };
    Object.defineProperty(ChannelController.prototype, "ChannelControls", {
        get: function () {
            return this.channelQueue;
        },
        enumerable: true,
        configurable: true
    });
    ChannelController.prototype.initialize = function (config, core, extensions) {
        var _this = this;
        this.channelQueue = new Array();
        if (config.channels) {
            var invalidChannelIdentifier_1 = undefined;
            config.channels.forEach(function (queue) {
                if (queue && queue.length > 0) {
                    queue = queue.sort(function (a, b) {
                        return a.priority - b.priority;
                    });
                    // Initialize each plugin
                    queue.forEach(function (queueItem) {
                        if (queueItem.priority < ChannelControllerPriority) {
                            invalidChannelIdentifier_1 = queueItem.identifier;
                        }
                        queueItem.initialize(config, core, extensions);
                    });
                    if (invalidChannelIdentifier_1) {
                        throw Error(ChannelValidationMessage + invalidChannelIdentifier_1);
                    }
                    for (var i = 1; i < queue.length; i++) {
                        queue[i - 1].setNextPlugin(queue[i]); // setup processing chain
                    }
                    _this.channelQueue.push(queue);
                }
            });
        }
        var arr = new Array();
        for (var i = 0; i < extensions.length; i++) {
            var plugin = extensions[i];
            if (plugin.priority > ChannelControllerPriority) {
                arr.push(plugin);
            }
        }
        if (arr.length > 0) {
            // sort if not sorted
            arr = arr.sort(function (a, b) {
                return a.priority - b.priority;
            });
            // Initialize each plugin
            arr.forEach(function (queueItem) { return queueItem.initialize(config, core, extensions); });
            // setup next plugin
            for (var i = 1; i < arr.length; i++) {
                arr[i - 1].setNextPlugin(arr[i]);
            }
            this.channelQueue.push(arr);
        }
    };
    return ChannelController;
}());
var validationError = "Extensions must provide callback to initialize";
var validationErrorInExt = "Channels must be provided through config.channels only";
var ChannelControllerPriority = 500;
var ChannelValidationMessage = "Channel has invalid priority";
//# sourceMappingURL=AppInsightsCore.js.map